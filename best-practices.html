<!doctype html>
<html>
  <head>
    <title>Skate</title>
    <link rel="stylesheet" href="styles/index.css">
    <script src="scripts/index.js"></script>
  </head>
  <body class="container">
    <skate>skate</skate>
    <skate-nav>
      <skate-item><a href="index.html">Skate</a></skate-item>
      <skate-item><a href="usage.html">Usage</a></skate-item>
      <skate-item><a href="best-practices.html">Best Practices</a></skate-item>
      <skate-item><a href="contributing.html">Contributing</a></skate-item>
      <skate-item><a href="license.html">License</a></skate-item>
    </skate-nav>
    <h2 id="best-practices">Best Practices</h2>
<p>There are some things to consider when building a web component that aren&#39;t quite obvious at first. Things like having compound components; ones that have parents and children that are all components and are supposed to interact with each other. There&#39;s also some gotcha&#39;s when working with polyfilled components vs native web components.</p>
<h2 id="setup">Setup</h2>
<p>The most basic component needn&#39;t have anything in it but there are still some important parts to this first step:</p>
<pre><code class="lang-js">// File: my-component.js

// Imports from NPM using Browserify,
// Galvatron or something like that
// as your build step.
import skate from &#39;skatejs&#39;;

// Exposes the component constructor.
export default skate(&#39;my-component&#39;, {

});
</code></pre>
<p>You&#39;ll notice it&#39;s using ES6 modules. Regardless of the module system, you should make sure that your component constructor is available to use by an API consumer. The <code>export default skate...</code> line does just that. If you <code>import</code> this component, you can now use its constructor.</p>
<pre><code class="lang-js">// File: main.js

// Imports &quot;my-component.js&quot;.
import MyComponent from &#39;my-component&#39;;

// &lt;my-component&gt;&lt;/my-component&gt;
var myComponent = new MyComponent();
</code></pre>
<h2 id="which-callback-is-right-for-you-">Which callback is right for you?</h2>
<p>If you&#39;re building a static component; something that will set itself up and not respond to much, you&#39;ll probably just end up using one of the lifecycle callbacks. For example, the <code>created</code> callback is called when the element is created, but not yet in the DOM. See notes below.</p>
<pre><code class="lang-js">skate(&#39;my-component&#39;, {
  created: function (element) {
    ...
  }
});
</code></pre>
<p><em>BEWARE that when using native custom elements and polyfilled custom elements that the <code>created</code> callback behaves differently. In native, your element will not have a parent or any children even if the HTML you&#39;ve written begs to differ. This is because the element is created the instant the HTML parser encounters it. In polyfill land, we can&#39;t only detect changes to the DOM once it&#39;s already added, so it would already be in the DOM along with its children by the time you get into this callback.</em></p>
<p><em>Because of this, <strong>never</strong> ever assume structure in your <code>created</code> callback. Use the <code>attached</code> callback instead.</em></p>
<p>If you need to do something when the element is inserted into the DOM, then use the <code>attached</code> callback.</p>
<pre><code class="lang-js">skate(&#39;my-component&#39;, {
  attached: function (element) {
    ...
  }
});
</code></pre>
<p><em>REMEMBER the <code>attached</code> callback gets called every time the element is inserted into the DOM. This means that if you remove it and then reinsert it, no matter if you do it manually or if something moved it somewhere else, it will be called.</em></p>
<p>If you need to do something whenever an attribute changes, then use the <code>attributes</code> option.</p>
<pre><code class="lang-js">skate(&#39;my-component&#39;, {
  attributes: {
    &#39;my-attribute&#39;: function (element, data) {
      ...
    }
  }
});
</code></pre>
<p>The attribute hooks are a great place to put any functionality that requires you do something based on its value. A good rule of thumb is that if you start typing <code>getAttribute</code> in the <code>created</code> or <code>attached</code> lifecycle callbacks, theres a good chance that you can do what you need to do within the attribute listener. This avoids any sort of duplication and ensures that your element can respond to updates.</p>
<h2 id="unidirectional-data-flow">Unidirectional data-flow</h2>
<p>Parents should control and know about their children and the children should not know about their parents or their siblings. Maintaining this philosophy will help to ensure that you do not couple any behavoiur with how you&#39;ve structured your component.</p>
<p>If a parent needs to respond to a change within a child, respond to an event.</p>
<pre><code class="lang-js">var MyParent = skate(&#39;my-parent&#39;, {
  events: {
    &#39;update my-child&#39;: function (element, e, target) {
      console.log(&#39;my-child got updated&#39;);
    }
  }
});

var MyChild = skate(&#39;my-child&#39;, {
  prototype: {
    update: function () {
      this.dispatchEvent(new CustomEvent(&#39;updated&#39;, { bubbles: true }));
    }
  }
});

var myParent = new MyParent();
var myChild = new MyChild();

myParent.appendChild(myChild);

// Logs: &quot;my-child got updated&quot;.
myChild.update();
</code></pre>
<h2 id="keep-things-concise">Keep things concise</h2>
<p>When you define attributes on your component:</p>
<pre><code class="lang-js">var MyComponent = skate(&#39;my-component&#39;, {
  attributes: {
    &#39;my-attribute-1&#39;: ...,
    &#39;my-attribute-2&#39;: ...
  }
});
</code></pre>
<p>Skate will create property links for those attributes:</p>
<pre><code class="lang-js">var myComponent = new MyComponent();
myComponent.myAttribute1 = &#39;testing&#39;;

// &quot;testing&quot;
myComponent.myAttribute1;
myComponent.getAttribute(&#39;my-attribute-1&#39;);
</code></pre>
<p>This makes the behaviour consistent with properties / attributes like <code>id</code> and <code>name</code> that are linked by default.</p>
<h2 id="data-binding-sort-of-">Data-binding. Sort of.</h2>
<p>Being able to use attribute listeners is kinda like having an abstract way to use data-binding. As seen above we can use property links to manipulate attributes which, visually, looks more like a view model - and for all intents and purposes, it <em>is</em> a view model. This means you can do some really cool stuff with a very small amount of code.</p>
<p>For example, you can write a helper to take an attiribute change and apply it to an element.</p>
<pre><code class="lang-js">// File: helper/text.js

export default function text (selector) {
  return function (element, data) {
    [].slice.call(element.querySelectorAll(selector)).forEach(function (descendant) {
      descendant.textContent = data.newValue;
    });
  };
}
</code></pre>
<p>And then use it in your component:</p>
<pre><code class="lang-js">// File: my-component.js
import text from &#39;./helper/text&#39;;

export default skate(&#39;my-component&#39;, {
  attributes: {
    name: text(&#39;.name&#39;)
  },

  template: function (element) {
    element.innerHTML = &#39;&lt;div class=&quot;name&quot;&gt;&lt;/div&gt;&#39;;
  }
});
</code></pre>
<p>When you set the <code>name</code> attribute of the element, it will update the descendants:</p>
<pre><code class="lang-js">// File main.js
import MyComponent from &#39;my-component&#39;;

var myComponent = new MyComponent();

myComponent.name = &#39;Trey&#39;;

// Logs: &lt;my-component name=&quot;Trey&quot;&gt;&lt;div class=&quot;name&quot;&gt;Trey&lt;/div&gt;&lt;/my-component&gt;
console.log(myComponent);
</code></pre>
<p>You&#39;re not limited to text either. You can use that functional pattern to set attributes, form field values and manipulate structure.</p>

  </body>
</html>
