<h2>Overview</h2>
<p>Skate is a web component library that allows you to define behaviour for elements without worrying about when that element is inserted into the DOM.</p>
<skate-code title="HTML">
  <my-component></my-component>
</skate-code>
<skate-code lang="javascript" title="JavaScript">
  skate('my-component', function(element) {
    element.textContent = 'Hello, World!';
  });
</skate-code>
<skate-output title="Output">
  Hello, World!
</skate-output>


<h3 skate-heading-link skate-toc-item id="heading-installing">Installing</h3>
<p>You can install Skate using <a is="skate-external-link" href="http://bower.io/">Bower</a> or by downloading the source from the <a skate-external-link href="https://github.com/treshugart/skate">repository</a>.</p>
<skate-code lang="bash">
  bower install skate
</skate-code>


<h4 skate-heading-link id="heading-installing-amd">AMD</h4>
<p>Skate supports AMD if detected and is registered as <code>skate</code>. You must ensure that when you <code>require(['skate'])</code> that you have pointed that module to the correct path. In RequireJS you would use the <code>paths</code> configuration option:</p>
<skate-code lang="javascript">
  require.config({
    paths: {
      skate: 'bower_components/skate/dist/skate'
    }
  });
</skate-code>


<h4 skate-heading-link id="heading-installing-global">Global</h4>
<p>If you're still skating old school, we've got you covered. Just make sure skate is included on the page and you can access it via <code>window.skate</code>.</p>


<h3 skate-heading-link skate-toc-item id="heading-usage">Usage</h3>
<p>Skate revolves around three binding methods - in the following order - that the component id (first argument to <skate-snippet lang="javascript">skate()</skate-snippet>) will attempt to find on an element:</p>
<ol>
  <li>Tags <skate-snippet><my-component></my-component></skate-snippet></li>
  <li>Attributes <skate-snippet><div my-component></div></skate-snippet></li>
  <li>Classes <skate-snippet><div class="my-component"></div></skate-snippet></li>
</ol>


<h4 skate-heading-link>Binding Restrictions</h4>
<p>It is up to the consumer to opt-in to using a component using one of the binding methods. The onus is on the developer of the component to document and place restrictions on how that component is designed to be used.</p>
<p>For example, a component developer can restrict a component to be bound using a custom element and if that element is bound otherwise, an exception will be raised. Binding restrictions are passed as an option using the second argument to the <skate-snippet lang="javascript">skate()</skate-snippet> function. The following component would be restricted to be bound via a tag name:</p>
<skate-code lang="javascript">
  skate('my-component', {
    type: skate.types.TAG
  });
</skate-code>
<p>There are three different types of components:</p>
<ul>
  <li><skate-snippet lang="javascript">skate.types.TAG</skate-snippet> Allows binding only via a tag name.</li>
  <li><skate-snippet lang="javascript">skate.types.ATTR</skate-snippet> Allows binding only via an attribute name.</li>
  <li><skate-snippet lang="javascript">skate.types.CLASS</skate-snippet> Allows binding only via a class name.</li>
</ul>
<p>Additionally, you can mix and match these. For example you may want a component that applies to attributes and tags, but not class names.</p>
<ul>
  <li><skate-snippet lang="javascript">skate.types.ANY</skate-snippet> Allows any type of binding.</li>
  <li><skate-snippet lang="javascript">skate.types.NOTAG</skate-snippet> Allows both attribute and class binding, but not tag binding.</li>
  <li><skate-snippet lang="javascript">skate.types.NOATTR</skate-snippet> Allows both tag and class binding, but not attribute binding.</li>
  <li><skate-snippet lang="javascript">skate.types.NOCLASS</skate-snippet> Allows both tag and attribute binding, but not class binding.</li>
</ul>
<p>You can bind more than one component to an element. Only one tag binding can be applied to an element, but you can have multiple attribute and class bindings.</p>
<skate-code lang="html">
  &lt;my-heading skate-heading-link skate-toc-item id="heading-usage"&gt;
</skate-code>


<h4 skate-heading-link>Lifecycle Callbacks</h4>
<p>There are three callbacks that get called during the lifecycle of an element:</p>
<ul>
  <li><skate-snippet lang="javascript">ready</skate-snippet> called before the element is inserted into the DOM. Without full web-component support, you can only emulate this by ensuring it's hidden via css and then showing it.</li>
  <li><skate-snippet lang="javascript">insert</skate-snippet> called after the element is shown in the DOM.</li>
  <li><skate-snippet lang="javascript">remove</skate-snippet> called when the element is removed from the DOM.</li>
</ul>
<p>If you remember the first example at the top, it passes a function as the second argument:</p>
<skate-code lang="javascript">
  skate('my-component', function(element) {
    element.textContent = 'Hello, World!';
  });
</skate-code>
<p>By default, that function is translated into:</p>
<skate-code lang="javascript">
  skate('my-component', {
    insert: function(element) {
      element.textContent = 'Hello, World!';
    }
  });
</skate-code>
<p>If you wanted to modify this element before it's shown, you'd instead pass the function as the <skate-snippet lang="javascript">ready</skate-snippet> callback:</p>
<skate-code lang="javascript">
  skate('my-component', {
    ready: function(element) {
      element.textContent = 'Hello, World!';
    }
  });
</skate-code>
<p>Doing so ensures that your element is hidden upon insertion and shown only after you have the chance to make modifications to it which eliminates any sort of FOUC.</p>
