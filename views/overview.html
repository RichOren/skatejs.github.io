<h2>Overview</h2>
<p>General overview of usage and theory</p>



<h3 id="heading-usage">Bindings</h3>

<p>A Skate component uses three methods to match a component ID to an element:</p>
<ol>
  <li>Tags <skate-snippet><my-component></my-component></skate-snippet></li>
  <li>Attributes <skate-snippet><div my-component></div></skate-snippet></li>
  <li>Classes <skate-snippet><div class="my-component"></div></skate-snippet></li>
</ol>



<h4>Restrictions</h4>

<p>Components are opt-in, meaning the consumer of a component must use a custom-element name, attribute name or class name in their HTML. The developer of the component must decide which binding method they want to restrict the component to using, if any. If the consumer tries to bind a component using a class name and the developer only allows it to be bound using an attribute, the component is not bound and no errors are raised.</p>
<p>For example, a component developer can restrict a component to be bound using a custom element and if that element is bound otherwise, an exception will be raised. Binding restrictions are passed as an option using the second argument to the <skate-snippet lang="javascript">skate()</skate-snippet> function. The following component would be restricted to be bound via a tag name:</p>
<skate-code lang="javascript">
  skate('my-component', {
    type: skate.types.TAG
  });
</skate-code>

<p>There are three different types of components:</p>
<ul>
  <li><skate-snippet lang="javascript">skate.types.TAG</skate-snippet> Allows binding only via a tag name.</li>
  <li><skate-snippet lang="javascript">skate.types.ATTR</skate-snippet> Allows binding only via an attribute name.</li>
  <li><skate-snippet lang="javascript">skate.types.CLASS</skate-snippet> Allows binding only via a class name.</li>
</ul>

<p>Additionally, you can mix and match these. For example you may want a component that applies to attributes and tags, but not class names.</p>
<ul>
  <li><skate-snippet lang="javascript">skate.types.ANY</skate-snippet> Allows any type of binding. This is the default./li>
  <li><skate-snippet lang="javascript">skate.types.NOTAG</skate-snippet> Allows both attribute and class binding, but not tag binding.</li>
  <li><skate-snippet lang="javascript">skate.types.NOATTR</skate-snippet> Allows both tag and class binding, but not attribute binding.</li>
  <li><skate-snippet lang="javascript">skate.types.NOCLASS</skate-snippet> Allows both tag and attribute binding, but not class binding.</li>
</ul>

<p>You can bind more than one component to an element. Only one tag binding can be applied to an element, but you can have multiple attribute and class bindings.</p>
<skate-code lang="html">
  &lt;my-component-1 my-component-2 class="my-component-3"&gt;
</skate-code>



<h4>Lifecycle Callbacks</h4>

<p>There are three callbacks that get called during the lifecycle of an element:</p>
<ul>
  <li><skate-snippet lang="javascript">ready</skate-snippet> called before the element is inserted into the DOM. Without full web-component support, you can only emulate this by ensuring it's hidden via css and then showing it.</li>
  <li><skate-snippet lang="javascript">insert</skate-snippet> called after the element is shown in the DOM.</li>
  <li><skate-snippet lang="javascript">remove</skate-snippet> called when the element is removed from the DOM.</li>
</ul>

<p>If you remember the first example at the top, it passes a function as the second argument:</p>
<skate-code lang="javascript">
  skate('my-component', function(element) {
    element.textContent = 'Hello, World!';
  });
</skate-code>

<p>By default, that function is translated into:</p>
<skate-code lang="javascript">
  skate('my-component', {
    insert: function(element) {
      element.textContent = 'Hello, World!';
    }
  });
</skate-code>

<p>If you wanted to modify this element before it's shown, you'd instead pass the function as the <skate-snippet lang="javascript">ready</skate-snippet> callback:</p>
<skate-code lang="javascript">
  skate('my-component', {
    ready: function(element) {
      element.textContent = 'Hello, World!';
    }
  });
</skate-code>

<p>Doing so ensures that your element is hidden upon insertion and shown only after you have the chance to make modifications to it which eliminates any sort of FOUC.</p>



<h4>Attribute Listeners</h4>

<p>On top of just lifecycle callbacks, the web component specification has a way for you to listen to attribute changes. Skate in this regard is no different.</p>
<skate-code lang="javascript">
  skate('my-component', {
    attributes: function (element, change) {
      ...
    }
  });
</skate-code>

<p>The element which had its attribute modified and the change information are passed into the callback. The following information is provided in the change information:</p>
<ul>
  <li><skate-snippet>type</skate-snippet> is the type of change that occurred. Types of changes are explained below.</li>
  <li><skate-snippet>name</skate-snippet> is the name of the attribute that was modified.</li>
  <li><skate-snippet>newValue</skate-snippet> is the new value of the attribute.</li>
  <li><skate-snippet>oldValue</skate-snippet> is the old value of the attribute.</li>
</ul>

<p>There are three types of attribute modifications:</p>
<ul>
  <li><skate-snippet>insert</skate-snippet> is specified when an attribute is first added to an element. It is also called when an element with attributes is inserted for the first time.</li>
  <li><skate-snippet>update</skate-snippet> is specified when an attribute is updated.</li>
  <li><skate-snippet>remove</skate-snippet> is specified when an attribute is removed.</li>
</ul>

<p>There are also two other ways to define your attribute callbacks. You can also specify for which attributes you'd like to listen to.</p>
<skate-code lang="javascript">
  skate('my-component', {
    attributes: {
      name: function (element, change) {
        ...
      },
      value: function (element, change) {
        ...
      }
    }
  });
</skate-code>

<p>That would trigger callbacks for both the <skate-snippet>name</skate-snippet> and <skate-snippet>value</skate-snippet> attributes. Finally, you can specify what type of updates you want to listen for on a given attribute:</p>
<skate-code lang="javascript">
  skate('my-component', {
    attributes: {
      id: {
        insert: function (element, change) {
          ...
        }
      }
      name: {
        update: function (element, change) {
          ...
        }
      },
      value: {
        remove: function (element, change) {
          ...
        }
      }
    }
  });
</skate-code>



<h4>Event Binding</h4>

<p>Generally speaking, you can add and remove event listeners manually at any point in your lifecycle callbacks. However, if you use the <skate-snippet>events</skate-snippet> option Skate will manage the binding and unbinding of your listeners during the element's lifecycle so you don't have to.</p>
<skate-code lang="javascript">
  skate('my-component', {
    events: {
      click: function (element, e) {
        ...
      },
      mouseover: function (element, e) {
        ...
      },
      mouseout: function (element, e) {
        ...
      }
    }
  });
</skate-code>

<p>The element in which the event was bound and the event object are passed into the handlers. These handlers will be cleaned up when the element is removed from the DOM even if it still exists in memory.</p>
