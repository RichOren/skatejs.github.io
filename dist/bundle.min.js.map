{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/bundle.min.js","webpack:///webpack/bootstrap 7d1133c1151b73de8d26","webpack:///./src/index.js","webpack:///./src/app/index.js","webpack:///../skatejs/dist/index.js","webpack:///../skatejs/~/incremental-dom/dist/incremental-dom-cjs.js","webpack:///../skatejs/~/regex-native-function/lib/index.js","webpack:///./src/body/index.js","webpack:///./src/body/index.css","webpack:///./~/css-loader/lib/css-base.js","webpack:///./src/footer/index.js","webpack:///./src/footer/index.css","webpack:///./src/header/index.js","webpack:///./src/header/index.css","webpack:///./src/header/logo.png","webpack:///./src/_/title.js","webpack:///./src/index.css"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","App","undefined","_index","_index2","_index3","_index4","document","head","innerHTML","_hasOwn","prototype","hasOwnProperty","_forOwn","object","iterator","prop","_renderArbitrary","child","type","String","_skatejs","vdom","text","__jsxDOMWrapper","Array","isArray","forEach","_body","_body2","_footer","_footer2","_header","_header2","_title","_title2","props","page","string","scrolled","attached","elem","window","addEventListener","_scrollHandler","scrollY","detached","removeEventListener","render","elementOpen","elementClose","global","incrementalDom","isNativeRegex","empty","val","create","def","_len","arguments","length","args","_key","unshift","assign$1","apply","shouldUseShadowDomV0","isNative","v1ShadowDOMProperty","isPolyfill","v0ShadowDOMProperty","shouldUseShadowDomV1","applyEvent","ename","name","events","__events","eFunc","resolveTagName","tname","$name","fallbackToV0","wrapIdomFunc","func","tnameFuncHandler","wrap","stackChren","push","newAttr","key","stackProps","attr","stackOpen","stackClose","chren","pop","toConsumableArray","element","attrs","atype","_typeof","newElementOpenStart","statics","keys","newElementOpenEnd","ctype","newText","newElementClose","data","namespace","__SKATE_DATA","getOwnPropertyDescriptors","getOwnPropertyNames","reduce","prev","curr","getOwnPropertyDescriptor","matches","selector","hasNativeMatchesSelectorDetattachedBug","clone","cloneNode","createElement","appendChild","nativeMatchesSelector","readonly","configurable","get","parseEvent","e","indexOfSpace","indexOf","hasSpace","substring","makeDelegateHandler","handler","parsed","current","path","target","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","makeNormalHandler","bindEvent","event","capture","opts","createRenderer","Ctor","$shadowRoot","sr","shadowDomV1","attachShadow","mode","shadowDomV0","createShadowRoot","patchInner","dashCase","str","split","one","two","idx","dash","toLowerCase","debounce","fn","called","_this","setTimeout","createCustomEvent","CustomEvent","createEvent","initCustomEvent","bubbles","cancelable","detail","emit","disabled","dispatchEvent","getDefaultValue","getInitialValue","initial","createNativePropertyDefinition","enumerable","created","propData","attributeName","attribute","initialValue","shouldSyncAttribute","hasAttribute","deserialize","getAttribute","set","internalValue","coerce","shouldUpdate","newValue","oldValue","shouldRemoveAttribute","propertyHasChanged","canceled","changeData","deb","$rendererDebounced","constructor","$renderer","settingAttribute","serializedValue","serialize","syncingAttribute","removeAttribute","setAttribute","initProps","ensurePropertyFunctions","names","descriptors","descriptorName","ensurePropertyDefinitions","formatLinkedAttributes","observedAttributes","linkedAttr","createInitProps","generateUniqueName","registered","registry","registerUniqueName","uniqueName","Component","extend","$events","$props","customElementsV0","$ctor","NewCtor","registerElement","definePropertyConstructor","customElementsV0Polyfill","customElementsV1","Error","customElements","extends","get$1","state","set$1","newState","getValue","checked","link","localTarget","parts","firstPart","propName","ready","done","info","definedAttribute","readyCallbacks","assign","bind","arg","alwaysUndefinedIfNotANumberOrNumber","isNaN","Number","alwaysUndefinedIfEmptyOrString","array","JSON","parse","stringify","boolean","number","freeze","$created","symbols$1","shadowRoot","div","test","Document","Symbol","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","i","descriptor","writable","protoProps","staticProps","inherits","subClass","superClass","setPrototypeOf","__proto__","possibleConstructorReturn","self","ReferenceError","arr","arr2","from","applyDefault","attributes","symbols","skip","className","applyProp","tagName","newElementOpen","elementOpenEnd","elementOpenStart","newElementVoid","elementVoid","proto","HTMLElement","ctor","_HTMLElement","getPrototypeOf","createdCallback","cb","_constructor","attributeChanged","propertyName","propOpts","_this2","elemData","renderedAttribute","renderer","attributeChangedCallback","connectedCallback","disconnectedCallback","definition","Base","_Base","prot","elProto","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","NodeData","nodeName","createMap","attrsArr","newAttrs","keyMap","keyMapValid","Context","notifications","nodesCreated","deleted","nodesDeleted","has","map","property","initData","node","getData","Element","placeholder","getNamespace","lastIndexOf","applyAttr","el","attrNS","setAttributeNS","applyStyle","style","cssText","elStyle","applyAttributeTyped","updateAttribute","mutator","getNamespaceForTag","tag","parent","namespaceURI","doc","createElementNS","createText","createTextNode","createKeyMap","firstElementChild","nextElementSibling","getKeyMap","getChild","registerChild","markCreated","markDeleted","notifyChanges","context","currentNode","currentParent","patchFactory","run","f","prevContext","prevRoot","prevDoc","prevCurrentNode","prevCurrentParent","ownerDocument","enterNode","exitNode","patchOuter","nextSibling","alignWithDOM","replaceChild","insertBefore","clearUnvisitedDOM","lastChild","removeChild","nextNode","firstChild","coreElementOpen","coreElementClose","coreText","currentElement","ATTRIBUTES_OFFSET","argsBuilder","const_args","attrsChanged","j","_attr","elementPlaceholder","formatted","patch","re","Function","toString","replace","RegExp","locals","body","list","result","item","join","mediaQuery","alreadyImportedModules","_jsxWrapper","wrapper","List","items","_css$locals$item","_css$locals$link","_props$items$item","_item","footer","Docs","_logo","_logo2","Item","href","header","title","header-scrolled","headerScrolled"],"mappings":"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","file":"dist/bundle.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"skatejsGithubIo\"] = factory();\n\telse\n\t\troot[\"skatejsGithubIo\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"skatejsGithubIo\"] = factory();\n\telse\n\t\troot[\"skatejsGithubIo\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.App = undefined;\n\t\n\tvar _index = __webpack_require__(1);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tvar _index3 = __webpack_require__(14);\n\t\n\tvar _index4 = _interopRequireDefault(_index3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tdocument.head.innerHTML += '<style>' + _index4.default + '</style>';\n\texports.App = _index2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar _hasOwn = Object.prototype.hasOwnProperty;\n\t\n\tvar _forOwn = function _forOwn(object, iterator) {\n\t  for (var prop in object) {\n\t    if (_hasOwn.call(object, prop)) iterator(object[prop], prop);\n\t  }\n\t};\n\t\n\tvar _renderArbitrary = function _renderArbitrary(child) {\n\t  var type = typeof child;\n\t\n\t  if (type === 'number' || type === 'string' || type === 'object' && child instanceof String) {\n\t    _skatejs.vdom.text(child);\n\t  } else if (type === 'function' && child.__jsxDOMWrapper) {\n\t    child();\n\t  } else if (Array.isArray(child)) {\n\t    child.forEach(_renderArbitrary);\n\t  } else if (type === 'object' && String(child) === '[object Object]') {\n\t    _forOwn(child, _renderArbitrary);\n\t  }\n\t};\n\t\n\tvar _skatejs = __webpack_require__(2);\n\t\n\tvar _body = __webpack_require__(5);\n\t\n\tvar _body2 = _interopRequireDefault(_body);\n\t\n\tvar _footer = __webpack_require__(8);\n\t\n\tvar _footer2 = _interopRequireDefault(_footer);\n\t\n\tvar _header = __webpack_require__(10);\n\t\n\tvar _header2 = _interopRequireDefault(_header);\n\t\n\tvar _title = __webpack_require__(13);\n\t\n\tvar _title2 = _interopRequireDefault(_title);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = (0, _skatejs.define)('sk-app', {\n\t  props: {\n\t    page: _skatejs.prop.string(),\n\t    scrolled: _skatejs.prop.boolean()\n\t  },\n\t  attached: function attached(elem) {\n\t    window.addEventListener('scroll', elem._scrollHandler = function () {\n\t      return elem.scrolled = !!window.scrollY;\n\t    });\n\t    elem.page = 'testing...';\n\t  },\n\t  detached: function detached(elem) {\n\t    window.removeEventListener('scroll', elem._scrollHandler);\n\t  },\n\t  render: function render(elem) {\n\t    (0, _title2.default)('SkateJS - functional web components');\n\t\n\t    _skatejs.vdom.elementOpen('div');\n\t\n\t    _skatejs.vdom.elementOpen(_header2.default, null, null, 'scrolled', elem.scrolled, 'title', 'SkateJS');\n\t\n\t    _skatejs.vdom.elementClose(_header2.default);\n\t\n\t    _skatejs.vdom.elementOpen(_body2.default);\n\t\n\t    _renderArbitrary(elem.page);\n\t\n\t    _skatejs.vdom.elementClose(_body2.default);\n\t\n\t    _skatejs.vdom.elementOpen(_footer2.default);\n\t\n\t    _skatejs.vdom.elementClose(_footer2.default);\n\t\n\t    return _skatejs.vdom.elementClose('div');\n\t  }\n\t});\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t   true ? factory(exports, __webpack_require__(3), __webpack_require__(4)) : typeof define === 'function' && define.amd ? define(['exports', 'incremental-dom', 'regex-native-function'], factory) : factory(global.skate = global.skate || {}, global.IncrementalDOM, global.isNativeRegex);\n\t})(this, function (exports, incrementalDom, isNativeRegex) {\n\t\n\t  isNativeRegex = 'default' in isNativeRegex ? isNativeRegex['default'] : isNativeRegex;\n\t\n\t  var assign = Object.assign;\n\t  var assign$1 = assign ? assign.bind(Object) : function (obj) {\n\t    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t      args[_key - 1] = arguments[_key];\n\t    }\n\t\n\t    args.forEach(function (arg) {\n\t      return Object.keys(arg).forEach(function (name) {\n\t        return obj[name] = arg[name];\n\t      });\n\t    });\n\t    return obj;\n\t  };\n\t\n\t  function empty(val) {\n\t    return typeof val === 'undefined' || val === null;\n\t  }\n\t\n\t  var alwaysUndefinedIfNotANumberOrNumber = function alwaysUndefinedIfNotANumberOrNumber(val) {\n\t    return isNaN(val) ? undefined : Number(val);\n\t  };\n\t  var alwaysUndefinedIfEmptyOrString = function alwaysUndefinedIfEmptyOrString(val) {\n\t    return empty(val) ? undefined : String(val);\n\t  };\n\t\n\t  function create(def) {\n\t    return function () {\n\t      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t      }\n\t\n\t      args.unshift({}, def);\n\t      return assign$1.apply(null, args);\n\t    };\n\t  }\n\t\n\t  var array = create({\n\t    coerce: function coerce(val) {\n\t      return Array.isArray(val) ? val : [val];\n\t    },\n\t    default: function _default() {\n\t      return [];\n\t    },\n\t    deserialize: JSON.parse,\n\t    serialize: JSON.stringify\n\t  });\n\t\n\t  var boolean = create({\n\t    coerce: function coerce(value) {\n\t      return !!value;\n\t    },\n\t    default: false,\n\t    deserialize: function deserialize(value) {\n\t      return !(value === null);\n\t    },\n\t    serialize: function serialize(value) {\n\t      return value ? '' : undefined;\n\t    }\n\t  });\n\t\n\t  var number = create({\n\t    default: 0,\n\t    coerce: alwaysUndefinedIfNotANumberOrNumber,\n\t    deserialize: alwaysUndefinedIfNotANumberOrNumber,\n\t    serialize: alwaysUndefinedIfNotANumberOrNumber\n\t  });\n\t\n\t  var string = create({\n\t    coerce: alwaysUndefinedIfEmptyOrString,\n\t    deserialize: alwaysUndefinedIfEmptyOrString,\n\t    serialize: alwaysUndefinedIfEmptyOrString\n\t  });\n\t\n\t  var prop = Object.freeze({\n\t    create: create,\n\t    array: array,\n\t    boolean: boolean,\n\t    number: number,\n\t    string: string\n\t  });\n\t\n\t  var $created = '____skate_created';\n\t  var $ctor = '____skate_constructor';\n\t  var $events = '____skate_events';\n\t  var $name = '____skate_name';\n\t  var $props = '____skate_props';\n\t  var $renderer = '____skate_renderer';\n\t  var $rendererDebounced = '____skate_rendererDebounced';\n\t  var $shadowRoot = '____skate_shadowRoot';\n\t\n\t  var symbols$1 = Object.freeze({\n\t    name: $name,\n\t    shadowRoot: $shadowRoot\n\t  });\n\t\n\t  // checks if a function is native using regex\n\t\n\t  var div = document.createElement('div');\n\t  var isNative = function isNative(elem, prop) {\n\t    return isNativeRegex.test(elem[prop]);\n\t  };\n\t  var isPolyfill = function isPolyfill(elem, prop) {\n\t    return !!elem[prop] && !isNative(elem, prop);\n\t  };\n\t\n\t  // property used to check for shadowDOMv0 support\n\t  var v0ShadowDOMProperty = 'createShadowRoot';\n\t\n\t  // property used to check for shadowDOMv1 support\n\t  var v1ShadowDOMProperty = 'attachShadow';\n\t\n\t  function shouldUseShadowDomV0(elem) {\n\t    if (isNative(elem, v1ShadowDOMProperty)) {\n\t      return false;\n\t    } else if (isPolyfill(elem, v1ShadowDOMProperty) && isNative(elem, v0ShadowDOMProperty)) {\n\t      return true;\n\t    } else if (!isPolyfill(elem, v1ShadowDOMProperty) && isNative(elem, v0ShadowDOMProperty)) {\n\t      return true;\n\t    } else {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  function shouldUseShadowDomV1(elem) {\n\t    if (isNative(elem, v1ShadowDOMProperty)) {\n\t      return true;\n\t    } else if (isPolyfill(elem, v1ShadowDOMProperty) && isNative(elem, v0ShadowDOMProperty)) {\n\t      return false;\n\t    } else if (isPolyfill(elem, v1ShadowDOMProperty)) {\n\t      return true;\n\t    } else {\n\t      return false;\n\t    }\n\t  }\n\t\n\t  var customElementsV0 = !!document.registerElement;\n\t  var customElementsV0Polyfill = customElementsV0 && !Document.prototype.registerElement;\n\t  var customElementsV1 = !!window.customElements;\n\t\n\t  var shadowDomV0 = shouldUseShadowDomV0(div);\n\t  var shadowDomV1 = shouldUseShadowDomV1(div);\n\t\n\t  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t    return typeof obj;\n\t  } : function (obj) {\n\t    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n\t  };\n\t\n\t  var classCallCheck = function (instance, Constructor) {\n\t    if (!(instance instanceof Constructor)) {\n\t      throw new TypeError(\"Cannot call a class as a function\");\n\t    }\n\t  };\n\t\n\t  var createClass = function () {\n\t    function defineProperties(target, props) {\n\t      for (var i = 0; i < props.length; i++) {\n\t        var descriptor = props[i];\n\t        descriptor.enumerable = descriptor.enumerable || false;\n\t        descriptor.configurable = true;\n\t        if (\"value\" in descriptor) descriptor.writable = true;\n\t        Object.defineProperty(target, descriptor.key, descriptor);\n\t      }\n\t    }\n\t\n\t    return function (Constructor, protoProps, staticProps) {\n\t      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t      if (staticProps) defineProperties(Constructor, staticProps);\n\t      return Constructor;\n\t    };\n\t  }();\n\t\n\t  var defineProperty = function (obj, key, value) {\n\t    if (key in obj) {\n\t      Object.defineProperty(obj, key, {\n\t        value: value,\n\t        enumerable: true,\n\t        configurable: true,\n\t        writable: true\n\t      });\n\t    } else {\n\t      obj[key] = value;\n\t    }\n\t\n\t    return obj;\n\t  };\n\t\n\t  var inherits = function (subClass, superClass) {\n\t    if (typeof superClass !== \"function\" && superClass !== null) {\n\t      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t    }\n\t\n\t    subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t      constructor: {\n\t        value: subClass,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t  };\n\t\n\t  var possibleConstructorReturn = function (self, call) {\n\t    if (!self) {\n\t      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t    }\n\t\n\t    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t  };\n\t\n\t  var toConsumableArray = function (arr) {\n\t    if (Array.isArray(arr)) {\n\t      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\t\n\t      return arr2;\n\t    } else {\n\t      return Array.from(arr);\n\t    }\n\t  };\n\t\n\t  var applyDefault = incrementalDom.attributes[incrementalDom.symbols.default];\n\t  var fallbackToV0 = !shadowDomV1 && shadowDomV0;\n\t  var stackChren = [];\n\t  var stackProps = [];\n\t\n\t  // Attributes that are not handled by Incremental DOM.\n\t  incrementalDom.attributes.key = incrementalDom.attributes.skip = incrementalDom.attributes.statics = function () {};\n\t\n\t  // Attributes that *must* be set via a property on all elements.\n\t  incrementalDom.attributes.checked = incrementalDom.attributes.className = incrementalDom.attributes.disabled = incrementalDom.attributes.value = incrementalDom.applyProp;\n\t\n\t  // Default attribute applicator.\n\t  incrementalDom.attributes[incrementalDom.symbols.default] = function (elem, name, value) {\n\t    // If the skip attribute was specified, skip\n\t    if (name === 'skip' && value) {\n\t      return incrementalDom.skip();\n\t    }\n\t\n\t    // Custom element properties should be set as properties.\n\t    var props = elem.constructor.props;\n\t    if (props && name in props) {\n\t      return incrementalDom.applyProp(elem, name, value);\n\t    }\n\t\n\t    // Boolean false values should not set attributes at all.\n\t    if (value === false) {\n\t      return;\n\t    }\n\t\n\t    // Handle built-in and custom events.\n\t    if (name.indexOf('on') === 0) {\n\t      return name in elem ? incrementalDom.applyProp(elem, name, value) : applyEvent(elem, name.substring(2), name, value);\n\t    }\n\t\n\t    // Set the select attribute instead of name if it was a <slot> translated to\n\t    // a <content> for v0.\n\t    if (name === 'name' && elem.tagName === 'CONTENT') {\n\t      name = 'select';\n\t      value = '[slot=\"' + value + '\"]';\n\t    }\n\t\n\t    // Fallback to default IncrementalDOM behaviour.\n\t    applyDefault(elem, name, value);\n\t  };\n\t\n\t  // Adds or removes an event listener for an element.\n\t  function applyEvent(elem, ename, name, value) {\n\t    var events = elem.__events;\n\t\n\t    if (!events) {\n\t      events = elem.__events = {};\n\t    }\n\t\n\t    var eFunc = events[ename];\n\t\n\t    // Remove old listener so they don't double up.\n\t    if (eFunc) {\n\t      elem.removeEventListener(ename, eFunc);\n\t    }\n\t\n\t    // Bind new listener.\n\t    if (value) {\n\t      elem.addEventListener(ename, events[ename] = value);\n\t    }\n\t  }\n\t\n\t  function resolveTagName(tname) {\n\t    // If the tag name is a function, a Skate constructor or a standard function\n\t    // is supported.\n\t    //\n\t    // - If a Skate constructor, the tag name is extracted from that.\n\t    // - If a standard function, it is used as a helper.\n\t    if (typeof tname === 'function') {\n\t      return tname[$name] || tname;\n\t    }\n\t\n\t    // Skate allows the consumer to use <slot /> and it will translate it to\n\t    // <content /> if Shadow DOM V0 is preferred.\n\t    if (tname === 'slot' && fallbackToV0) {\n\t      return 'content';\n\t    }\n\t\n\t    // All other tag names are just passed through.\n\t    return tname;\n\t  }\n\t\n\t  function wrapIdomFunc(func) {\n\t    var tnameFuncHandler = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];\n\t\n\t    return function wrap() {\n\t      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t      }\n\t\n\t      var tname = args[0] = resolveTagName(args[0]);\n\t      if (typeof tname === 'function') {\n\t        // If we've encountered a function, handle it according to the type of\n\t        // function that is being wrapped.\n\t        tnameFuncHandler(tname);\n\t      } else if (stackChren.length) {\n\t        // We pass the wrap() function in here so that when it's called as\n\t        // children, it will queue up for the next stack, if there is one.\n\t        stackChren[stackChren.length - 1].push([wrap, args]);\n\t      } else {\n\t        // If there is no stack left, we call Incremental DOM directly.\n\t        return func.apply(undefined, args);\n\t      }\n\t    };\n\t  }\n\t\n\t  function newAttr(key, val) {\n\t    if (stackProps.length) {\n\t      stackProps[stackProps.length - 1][key] = val;\n\t    } else {\n\t      return incrementalDom.attr(key, val);\n\t    }\n\t  }\n\t\n\t  function stackOpen() {\n\t    stackChren.push([]);\n\t    stackProps.push({});\n\t  }\n\t\n\t  function stackClose(tname) {\n\t    var chren = stackChren.pop();\n\t    var props = stackProps.pop();\n\t    tname(props, function () {\n\t      return chren.forEach(function (args) {\n\t        return args[0].apply(args, toConsumableArray(args[1]));\n\t      });\n\t    });\n\t  }\n\t\n\t  // Convenience function for declaring an Incremental DOM element using\n\t  // hyperscript-style syntax.\n\t  function element(tname, attrs, chren) {\n\t    var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);\n\t\n\t    // If attributes are a function, then they should be treated as children.\n\t    if (atype === 'function' || atype === 'string') {\n\t      chren = attrs;\n\t    }\n\t\n\t    // Ensure the attributes are an object.\n\t    if (atype !== 'object') {\n\t      attrs = {};\n\t    }\n\t\n\t    // We open the element so we can set attrs after.\n\t    newElementOpenStart(tname, attrs.key, attrs.statics);\n\t\n\t    // Delete so special attrs don't actually get set.\n\t    delete attrs.key;\n\t    delete attrs.statics;\n\t\n\t    // Set attributes.\n\t    Object.keys(attrs).forEach(function (name) {\n\t      return newAttr(name, attrs[name]);\n\t    });\n\t\n\t    // Close before we render the descendant tree.\n\t    newElementOpenEnd(tname);\n\t\n\t    var ctype = typeof chren === 'undefined' ? 'undefined' : _typeof(chren);\n\t    if (ctype === 'function') {\n\t      chren();\n\t    } else if (ctype === 'string' || ctype === 'number') {\n\t      newText(chren);\n\t    }\n\t\n\t    return newElementClose(tname);\n\t  }\n\t\n\t  // Patch element factories.\n\t  var newElementClose = wrapIdomFunc(incrementalDom.elementClose, stackClose);\n\t  var newElementOpen = wrapIdomFunc(incrementalDom.elementOpen, stackOpen);\n\t  var newElementOpenEnd = wrapIdomFunc(incrementalDom.elementOpenEnd);\n\t  var newElementOpenStart = wrapIdomFunc(incrementalDom.elementOpenStart, stackOpen);\n\t  var newElementVoid = wrapIdomFunc(incrementalDom.elementVoid);\n\t  var newText = wrapIdomFunc(incrementalDom.text);\n\t\n\t  var vdom = Object.freeze({\n\t    element: element,\n\t    attr: newAttr,\n\t    elementClose: newElementClose,\n\t    elementOpen: newElementOpen,\n\t    elementOpenEnd: newElementOpenEnd,\n\t    elementOpenStart: newElementOpenStart,\n\t    elementVoid: newElementVoid,\n\t    text: newText\n\t  });\n\t\n\t  function data(element) {\n\t    var namespace = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\t\n\t    var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n\t    return namespace && (data[namespace] || (data[namespace] = {})) || data;\n\t  }\n\t\n\t  var definePropertyConstructor = function (obj, value) {\n\t    return Object.defineProperty(obj, 'constructor', { enumerable: false, value: value });\n\t  };\n\t\n\t  function getOwnPropertyDescriptors(obj) {\n\t    return Object.getOwnPropertyNames(obj || {}).reduce(function (prev, curr) {\n\t      prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n\t      return prev;\n\t    }, {});\n\t  }\n\t\n\t  // In native Custom Elements v0, you can extend HTMLElement. In the polyfill\n\t  // you cannot, so we ensure the polyfill has a patched HTMLElement constructor.\n\t  if (customElementsV0Polyfill) {\n\t    var proto = HTMLElement.prototype;\n\t    window.HTMLElement = function () {\n\t      var ctor = this[$ctor];\n\t      var name = this[$name];\n\t      var type = ctor.extends;\n\t      return document.createElement(type || name, type ? name : null);\n\t    };\n\t    HTMLElement.prototype = Object.create(proto);\n\t    definePropertyConstructor(HTMLElement.prototype, HTMLElement);\n\t  }\n\t\n\t  var Component = function (_HTMLElement) {\n\t    inherits(Component, _HTMLElement);\n\t\n\t    function Component() {\n\t      classCallCheck(this, Component);\n\t\n\t      var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Component).call(this));\n\t\n\t      _this.createdCallback();\n\t      return _this;\n\t    }\n\t\n\t    createClass(Component, [{\n\t      key: 'connectedCallback',\n\t      value: function connectedCallback() {\n\t        var cb = this.constructor.attached;\n\t        cb && cb(this);\n\t      }\n\t    }, {\n\t      key: 'disconnectedCallback',\n\t      value: function disconnectedCallback() {\n\t        var cb = this.constructor.detached;\n\t        cb && cb(this);\n\t      }\n\t    }, {\n\t      key: 'attributeChangedCallback',\n\t      value: function attributeChangedCallback(name, oldValue, newValue) {\n\t        var _constructor = this.constructor;\n\t        var attributeChanged = _constructor.attributeChanged;\n\t        var observedAttributes = _constructor.observedAttributes;\n\t\n\t        var propertyName = data(this, 'attributeLinks')[name];\n\t\n\t        // In V0 we have to ensure the attribute is being observed.\n\t        if (customElementsV0 && observedAttributes.indexOf(name) === -1) {\n\t          return;\n\t        }\n\t\n\t        if (propertyName) {\n\t          var propData = data(this, 'api/property/' + propertyName);\n\t\n\t          // This ensures a property set doesn't cause the attribute changed\n\t          // handler to run again once we set this flag. This only ever has a\n\t          // chance to run when you set an attribute, it then sets a property and\n\t          // then that causes the attribute to be set again.\n\t          if (propData.syncingAttribute) {\n\t            propData.syncingAttribute = false;\n\t            return;\n\t          }\n\t\n\t          // Sync up the property.\n\t          var propOpts = this.constructor.props[propertyName];\n\t          propData.settingAttribute = true;\n\t          this[propertyName] = newValue !== null && propOpts.deserialize ? propOpts.deserialize(newValue) : newValue;\n\t        }\n\t\n\t        if (attributeChanged) {\n\t          attributeChanged(this, { name: name, newValue: newValue, oldValue: oldValue });\n\t        }\n\t      }\n\t    }, {\n\t      key: 'createdCallback',\n\t      value: function createdCallback() {\n\t        var _this2 = this;\n\t\n\t        // In the polyfill, if you define a custom element after it has been\n\t        // created the polyfill will call the constructor it has on record thus\n\t        // ignoring the one the user has defined for the element. We ensure the\n\t        // constructor is actually the one that was specified in the definition\n\t        // rather than the one the polyfill gives it.\n\t        //\n\t        // In native v0 this behaves normally, so we only need to worry about the\n\t        // polyfill here.\n\t        if (customElementsV0Polyfill) {\n\t          definePropertyConstructor(this, this[$ctor]);\n\t        }\n\t\n\t        var elemData = data(this);\n\t        var readyCallbacks = elemData.readyCallbacks;\n\t        var Ctor = this.constructor;\n\t        var definedAttribute = Ctor.definedAttribute;\n\t        var events = Ctor.events;\n\t        var created = Ctor.created;\n\t        var observedAttributes = Ctor.observedAttributes;\n\t        var props = Ctor.props;\n\t        var ready = Ctor.ready;\n\t        var renderedAttribute = Ctor.renderedAttribute;\n\t\n\t        var renderer = Ctor[$renderer];\n\t\n\t        // TODO: This prevents an element from being initialised multiple times. For\n\t        // some reason this is happening in the event tests. It's possibly creating\n\t        // elements in a way that the causes the custom element v1 polyfill to call\n\t        // the constructor twice.\n\t        if (this[$created]) return;\n\t        this[$created] = true;\n\t\n\t        if (props) {\n\t          Ctor[$props](this);\n\t        }\n\t\n\t        if (events) {\n\t          Ctor[$events](this);\n\t        }\n\t\n\t        if (created) {\n\t          created(this);\n\t        }\n\t\n\t        if (renderer && !this.hasAttribute(renderedAttribute)) {\n\t          renderer(this);\n\t        }\n\t\n\t        if (ready) {\n\t          ready(this);\n\t        }\n\t\n\t        if (!this.hasAttribute(definedAttribute)) {\n\t          this.setAttribute(definedAttribute, '');\n\t        }\n\t\n\t        if (readyCallbacks) {\n\t          readyCallbacks.forEach(function (cb) {\n\t            return cb(_this2);\n\t          });\n\t          delete elemData.readyCallbacks;\n\t        }\n\t\n\t        // In v0 we must ensure the attributeChangedCallback is called for attrs\n\t        // that aren't linked to props so that the callback behaves the same no\n\t        // matter if v0 or v1 is being used.\n\t        if (customElementsV0) {\n\t          observedAttributes.forEach(function (name) {\n\t            var propertyName = data(_this2, 'attributeLinks')[name];\n\t            if (!propertyName) {\n\t              _this2.attributeChangedCallback(name, null, _this2.getAttribute(name));\n\t            }\n\t          });\n\t        }\n\t      }\n\t    }, {\n\t      key: 'attachedCallback',\n\t      value: function attachedCallback() {\n\t        this.connectedCallback();\n\t      }\n\t    }, {\n\t      key: 'detachedCallback',\n\t      value: function detachedCallback() {\n\t        this.disconnectedCallback();\n\t      }\n\t    }], [{\n\t      key: 'extend',\n\t      value: function extend() {\n\t        var definition = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t        var Base = arguments.length <= 1 || arguments[1] === undefined ? this : arguments[1];\n\t\n\t        // Create class for the user.\n\t\n\t        var Ctor = function (_Base) {\n\t          inherits(Ctor, _Base);\n\t\n\t          function Ctor() {\n\t            classCallCheck(this, Ctor);\n\t            return possibleConstructorReturn(this, Object.getPrototypeOf(Ctor).apply(this, arguments));\n\t          }\n\t\n\t          return Ctor;\n\t        }(Base);\n\t\n\t        // For inheriting from the object literal.\n\t\n\t        var opts = getOwnPropertyDescriptors(definition);\n\t        var prot = getOwnPropertyDescriptors(definition.prototype);\n\t\n\t        // Prototype is non configurable (but is writable) s\n\t        delete opts.prototype;\n\t\n\t        // Pass on static and instance members from the definition.\n\t        Object.defineProperties(Ctor, opts);\n\t        Object.defineProperties(Ctor.prototype, prot);\n\t\n\t        return Ctor;\n\t      }\n\t    }, {\n\t      key: 'definedAttribute',\n\t      get: function get() {\n\t        return 'defined';\n\t      }\n\t    }, {\n\t      key: 'events',\n\t      get: function get() {\n\t        return {};\n\t      }\n\t    }, {\n\t      key: 'observedAttributes',\n\t      get: function get() {\n\t        return [];\n\t      }\n\t    }, {\n\t      key: 'props',\n\t      get: function get() {\n\t        return {};\n\t      }\n\t    }, {\n\t      key: 'renderedAttribute',\n\t      get: function get() {\n\t        return 'rendered';\n\t      }\n\t    }]);\n\t    return Component;\n\t  }(HTMLElement);\n\t\n\t  var elProto = window.HTMLElement.prototype;\n\t  var nativeMatchesSelector = elProto.matches || elProto.msMatchesSelector || elProto.webkitMatchesSelector || elProto.mozMatchesSelector || elProto.oMatchesSelector;\n\t\n\t  // Only IE9 has this msMatchesSelector bug, but best to detect it.\n\t  var hasNativeMatchesSelectorDetattachedBug = !nativeMatchesSelector.call(document.createElement('div'), 'div');\n\t\n\t  function matches(element, selector) {\n\t    if (hasNativeMatchesSelectorDetattachedBug) {\n\t      var clone = element.cloneNode();\n\t      document.createElement('div').appendChild(clone);\n\t      return nativeMatchesSelector.call(clone, selector);\n\t    }\n\t    return nativeMatchesSelector.call(element, selector);\n\t  }\n\t\n\t  function readonly(obj, prop, val) {\n\t    Object.defineProperty(obj, prop, {\n\t      configurable: true,\n\t      get: function get() {\n\t        return val;\n\t      }\n\t    });\n\t  }\n\t\n\t  function parseEvent(e) {\n\t    var indexOfSpace = e.indexOf(' ');\n\t    var hasSpace = indexOfSpace > 0;\n\t    var name = hasSpace ? e.substring(0, indexOfSpace) : e;\n\t    var selector = hasSpace ? e.substring(indexOfSpace + 1) : '';\n\t    return {\n\t      name: name,\n\t      selector: selector\n\t    };\n\t  }\n\t\n\t  function makeDelegateHandler(elem, handler, parsed) {\n\t    return function (e) {\n\t      var current = e.path ? e.path[0] : e.target;\n\t      var selector = parsed.selector;\n\t      while (current && current !== elem.parentNode) {\n\t        if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n\t          break;\n\t        }\n\t        if (matches(current, selector)) {\n\t          readonly(e, 'currentTarget', current);\n\t          readonly(e, 'delegateTarget', elem);\n\t          return handler(elem, e);\n\t        }\n\t        current = current.parentNode;\n\t      }\n\t    };\n\t  }\n\t\n\t  function makeNormalHandler(elem, handler) {\n\t    return function (e) {\n\t      readonly(e, 'delegateTarget', elem);\n\t      handler(elem, e);\n\t    };\n\t  }\n\t\n\t  function bindEvent(elem, event, handler) {\n\t    var parsed = parseEvent(event);\n\t    var name = parsed.name;\n\t    var selector = parsed.selector;\n\t\n\t    var capture = selector && (name === 'blur' || name === 'focus');\n\t    handler = selector ? makeDelegateHandler(elem, handler, parsed) : makeNormalHandler(elem, handler);\n\t    elem.addEventListener(name, handler, capture);\n\t  }\n\t\n\t  function events(opts) {\n\t    var events = opts.events || {};\n\t    return function (elem) {\n\t      for (var name in events) {\n\t        bindEvent(elem, name, events[name]);\n\t      }\n\t    };\n\t  }\n\t\n\t  function createRenderer(Ctor) {\n\t    var render = Ctor.render;\n\t\n\t    return function (elem) {\n\t      if (!render) {\n\t        return;\n\t      }\n\t\n\t      if (!elem[$shadowRoot]) {\n\t        var sr = void 0;\n\t\n\t        if (shadowDomV1) {\n\t          sr = elem.attachShadow({ mode: 'open' });\n\t        } else if (shadowDomV0) {\n\t          sr = elem.createShadowRoot();\n\t        } else {\n\t          sr = elem;\n\t        }\n\t\n\t        elem[$shadowRoot] = sr;\n\t      }\n\t\n\t      incrementalDom.patchInner(elem[$shadowRoot], render, elem);\n\t    };\n\t  }\n\t\n\t  function dashCase(str) {\n\t    return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n\t      var dash = !one || idx % 2 === 0 ? '' : '-';\n\t      return '' + one + dash + two.toLowerCase();\n\t    });\n\t  }\n\t\n\t  function debounce(fn) {\n\t    var called = false;\n\t    return function () {\n\t      var _this = this;\n\t\n\t      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t        args[_key] = arguments[_key];\n\t      }\n\t\n\t      if (!called) {\n\t        called = true;\n\t        setTimeout(function () {\n\t          called = false;\n\t          fn.apply(_this, args);\n\t        });\n\t      }\n\t    };\n\t  }\n\t\n\t  var CustomEvent = function (CustomEvent) {\n\t    if (CustomEvent) {\n\t      try {\n\t        new CustomEvent();\n\t      } catch (e) {\n\t        return undefined;\n\t      }\n\t    }\n\t    return CustomEvent;\n\t  }(window.CustomEvent);\n\t\n\t  function createCustomEvent(name) {\n\t    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t    if (CustomEvent) {\n\t      return new CustomEvent(name, opts);\n\t    }\n\t    var e = document.createEvent('CustomEvent');\n\t    e.initCustomEvent(name, opts.bubbles, opts.cancelable, opts.detail);\n\t    return e;\n\t  }\n\t\n\t  function emit(elem, name) {\n\t    var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t    /* jshint expr: true */\n\t    opts.bubbles === undefined && (opts.bubbles = true);\n\t    opts.cancelable === undefined && (opts.cancelable = true);\n\t    return elem.disabled ? true : elem.dispatchEvent(createCustomEvent(name, opts));\n\t  }\n\t\n\t  function getDefaultValue(elem, name, opts) {\n\t    return typeof opts.default === 'function' ? opts.default(elem, { name: name }) : opts.default;\n\t  }\n\t\n\t  function getInitialValue(elem, name, opts) {\n\t    return typeof opts.initial === 'function' ? opts.initial(elem, { name: name }) : opts.initial;\n\t  }\n\t\n\t  function createNativePropertyDefinition(name, opts) {\n\t    var prop = {\n\t      configurable: true,\n\t      enumerable: true\n\t    };\n\t\n\t    prop.created = function (elem) {\n\t      var propData = data(elem, 'api/property/' + name);\n\t      var attributeName = opts.attribute;\n\t      var initialValue = elem[name];\n\t      var shouldSyncAttribute = false;\n\t\n\t      // Store property to attribute link information.\n\t      data(elem, 'attributeLinks')[attributeName] = name;\n\t      data(elem, 'propertyLinks')[name] = attributeName;\n\t\n\t      // Set up initial value if it wasn't specified.\n\t      if (empty(initialValue)) {\n\t        if (attributeName && elem.hasAttribute(attributeName)) {\n\t          initialValue = opts.deserialize(elem.getAttribute(attributeName));\n\t        } else if ('initial' in opts) {\n\t          initialValue = getInitialValue(elem, name, opts);\n\t          shouldSyncAttribute = true;\n\t        } else if ('default' in opts) {\n\t          initialValue = getDefaultValue(elem, name, opts);\n\t        }\n\t      }\n\t\n\t      if (shouldSyncAttribute) {\n\t        prop.set.call(elem, initialValue);\n\t      } else {\n\t        propData.internalValue = opts.coerce ? opts.coerce(initialValue) : initialValue;\n\t      }\n\t    };\n\t\n\t    prop.get = function () {\n\t      var propData = data(this, 'api/property/' + name);\n\t      var internalValue = propData.internalValue;\n\t\n\t      if (typeof opts.get === 'function') {\n\t        return opts.get(this, { name: name, internalValue: internalValue });\n\t      }\n\t      return internalValue;\n\t    };\n\t\n\t    prop.render = function () {\n\t      var shouldUpdate = opts.render;\n\t      if (typeof shouldUpdate === 'undefined') {\n\t        return function (elem, data) {\n\t          return data.newValue !== data.oldValue;\n\t        };\n\t      }\n\t      if (typeof shouldUpdate === 'function') {\n\t        return shouldUpdate;\n\t      }\n\t      return function () {\n\t        return !!shouldUpdate;\n\t      };\n\t    }();\n\t\n\t    prop.set = function (newValue) {\n\t      var propData = data(this, 'api/property/' + name);\n\t      var oldValue = propData.oldValue;\n\t\n\t      var shouldRemoveAttribute = false;\n\t\n\t      if (empty(oldValue)) {\n\t        oldValue = null;\n\t      }\n\t\n\t      if (empty(newValue)) {\n\t        newValue = getDefaultValue(this, name, opts);\n\t        shouldRemoveAttribute = true;\n\t      }\n\t\n\t      if (typeof opts.coerce === 'function') {\n\t        newValue = opts.coerce(newValue);\n\t      }\n\t\n\t      var propertyHasChanged = newValue !== oldValue;\n\t      if (propertyHasChanged && opts.event) {\n\t        var canceled = !emit(this, String(opts.event), {\n\t          bubbles: false,\n\t          detail: { name: name, oldValue: oldValue, newValue: newValue }\n\t        });\n\t\n\t        if (canceled) {\n\t          return;\n\t        }\n\t      }\n\t\n\t      propData.internalValue = newValue;\n\t\n\t      var changeData = { name: name, newValue: newValue, oldValue: oldValue };\n\t\n\t      if (typeof opts.set === 'function') {\n\t        opts.set(this, changeData);\n\t      }\n\t\n\t      // Re-render on property updates if the should-update check passes.\n\t      if (prop.render(this, changeData)) {\n\t        var deb = this[$rendererDebounced] || (this[$rendererDebounced] = debounce(this.constructor[$renderer]));\n\t        deb(this);\n\t      }\n\t\n\t      propData.oldValue = newValue;\n\t\n\t      // Link up the attribute.\n\t      var attributeName = data(this, 'propertyLinks')[name];\n\t      if (attributeName && !propData.settingAttribute) {\n\t        var serializedValue = opts.serialize(newValue);\n\t        propData.syncingAttribute = true;\n\t        if (shouldRemoveAttribute || empty(serializedValue)) {\n\t          this.removeAttribute(attributeName);\n\t        } else {\n\t          this.setAttribute(attributeName, serializedValue);\n\t        }\n\t      }\n\t\n\t      // Allow the attribute to be linked again.\n\t      propData.settingAttribute = false;\n\t    };\n\t\n\t    return prop;\n\t  }\n\t\n\t  function initProps(opts) {\n\t    opts = opts || {};\n\t\n\t    if (typeof opts === 'function') {\n\t      opts = { coerce: opts };\n\t    }\n\t\n\t    return function (name) {\n\t      return createNativePropertyDefinition(name, assign$1({\n\t        default: null,\n\t        deserialize: function deserialize(value) {\n\t          return value;\n\t        },\n\t        serialize: function serialize(value) {\n\t          return value;\n\t        }\n\t      }, opts));\n\t    };\n\t  }\n\t\n\t  var registry = {};\n\t\n\t  // Ensures that definitions passed as part of the constructor are functions\n\t  // that return property definitions used on the element.\n\t  function ensurePropertyFunctions(Ctor) {\n\t    var props = Ctor.props;\n\t    var names = Object.keys(props || {});\n\t    return names.reduce(function (descriptors, descriptorName) {\n\t      descriptors[descriptorName] = props[descriptorName];\n\t      if (typeof descriptors[descriptorName] !== 'function') {\n\t        descriptors[descriptorName] = initProps(descriptors[descriptorName]);\n\t      }\n\t      return descriptors;\n\t    }, {});\n\t  }\n\t\n\t  // Ensures the property definitions are transformed to objects that can be used\n\t  // to create properties on the element.\n\t  function ensurePropertyDefinitions(Ctor) {\n\t    var props = ensurePropertyFunctions(Ctor);\n\t    return Object.keys(props).reduce(function (descriptors, descriptorName) {\n\t      descriptors[descriptorName] = props[descriptorName](descriptorName);\n\t      return descriptors;\n\t    }, {});\n\t  }\n\t\n\t  // Ensures linked properties that have linked attributes are pre-formatted to\n\t  // the attribute name in which they are linked.\n\t  function formatLinkedAttributes(Ctor) {\n\t    var observedAttributes = Ctor.observedAttributes;\n\t    var props = Ctor.props;\n\t\n\t    if (!props) {\n\t      return;\n\t    }\n\t\n\t    Object.keys(props).forEach(function (name) {\n\t      var prop = props[name];\n\t      var attr = prop.attribute;\n\t      if (attr) {\n\t        // Ensure the property is updated.\n\t        var linkedAttr = prop.attribute = attr === true ? dashCase(name) : attr;\n\t\n\t        // Automatically observe the attribute since they're linked from the\n\t        // attributeChangedCallback.\n\t        if (observedAttributes.indexOf(linkedAttr) === -1) {\n\t          observedAttributes.push(linkedAttr);\n\t        }\n\t      }\n\t    });\n\t\n\t    // Merge observed attributes.\n\t    Object.defineProperty(Ctor, 'observedAttributes', {\n\t      configurable: true,\n\t      enumerable: true,\n\t      get: function get() {\n\t        return observedAttributes;\n\t      }\n\t    });\n\t  }\n\t\n\t  function createInitProps(Ctor) {\n\t    var props = ensurePropertyDefinitions(Ctor);\n\t\n\t    return function (elem) {\n\t      if (!props) {\n\t        return;\n\t      }\n\t\n\t      Object.keys(props).forEach(function (name) {\n\t        var prop = props[name];\n\t        prop.created(elem);\n\t\n\t        // https://bugs.webkit.org/show_bug.cgi?id=49739\n\t        //\n\t        // When Webkit fixes that bug so that native property accessors can be\n\t        // retrieved, we can move defining the property to the prototype and away\n\t        // from having to do if for every instance as all other browsers support\n\t        // this.\n\t        Object.defineProperty(elem, name, prop);\n\t      });\n\t    };\n\t  }\n\t\n\t  function generateUniqueName(name) {\n\t    var registered = registry[name];\n\t    return registered ? name + '-' + registered : name;\n\t  }\n\t\n\t  function registerUniqueName(name) {\n\t    registry[name] = registry[name] ? registry[name] + 1 : 1;\n\t  }\n\t\n\t  function define(name, opts) {\n\t    var uniqueName = generateUniqueName(name);\n\t    var Ctor = (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) === 'object' ? Component.extend(opts) : opts;\n\t\n\t    registerUniqueName(name);\n\t    formatLinkedAttributes(Ctor);\n\t\n\t    Ctor[$events] = events(Ctor);\n\t    Ctor[$name] = uniqueName;\n\t    Ctor[$props] = createInitProps(Ctor);\n\t    Ctor[$renderer] = createRenderer(Ctor);\n\t\n\t    if (customElementsV0) {\n\t      // These properties are necessary for the Custom Element v0 polyfill so\n\t      // that we can fix it not working with extending the built-in HTMLElement.\n\t      Ctor.prototype[$ctor] = Ctor;\n\t      Ctor.prototype[$name] = uniqueName;\n\t      var NewCtor = document.registerElement(uniqueName, Ctor);\n\t      definePropertyConstructor(NewCtor.prototype, Ctor);\n\t      return customElementsV0Polyfill ? Ctor : NewCtor;\n\t    } else if (customElementsV1) {\n\t      window.customElements.define(uniqueName, Ctor, { extends: Ctor.extends });\n\t    } else {\n\t      throw new Error('Skate requires native custom element support or a polyfill.');\n\t    }\n\t\n\t    return Ctor;\n\t  }\n\t\n\t  function get$1(elem) {\n\t    var props = elem.constructor.props;\n\t    var state = {};\n\t    for (var key in props) {\n\t      var val = elem[key];\n\t      if (typeof val !== 'undefined') {\n\t        state[key] = val;\n\t      }\n\t    }\n\t    return state;\n\t  }\n\t\n\t  function set$1(elem, newState) {\n\t    assign$1(elem, newState);\n\t    if (elem.constructor.render) {\n\t      elem.constructor[$renderer](elem);\n\t    }\n\t  }\n\t\n\t  function state(elem, newState) {\n\t    return typeof newState === 'undefined' ? get$1(elem) : set$1(elem, newState);\n\t  }\n\t\n\t  function getValue(elem) {\n\t    var type = elem.type;\n\t    if (type === 'checkbox' || type === 'radio') {\n\t      return elem.checked ? elem.value || true : false;\n\t    }\n\t    return elem.value;\n\t  }\n\t\n\t  function link(elem, target) {\n\t    return function (e) {\n\t      var value = getValue(e.target);\n\t      var localTarget = target || e.target.name || 'value';\n\t\n\t      if (localTarget.indexOf('.') > -1) {\n\t        var parts = localTarget.split('.');\n\t        var firstPart = parts[0];\n\t        var propName = parts.pop();\n\t        var obj = parts.reduce(function (prev, curr) {\n\t          return prev && prev[curr];\n\t        }, elem);\n\t\n\t        obj[propName || e.target.name] = value;\n\t        state(elem, defineProperty({}, firstPart, elem[firstPart]));\n\t      } else {\n\t        state(elem, defineProperty({}, localTarget, value));\n\t      }\n\t    };\n\t  }\n\t\n\t  function ready(elem, done) {\n\t    var info = data(elem);\n\t    if (elem.hasAttribute(elem.constructor.definedAttribute)) {\n\t      done(elem);\n\t    } else if (info.readyCallbacks) {\n\t      info.readyCallbacks.push(done);\n\t    } else {\n\t      info.readyCallbacks = [done];\n\t    }\n\t  }\n\t\n\t  exports.Component = Component;\n\t  exports.define = define;\n\t  exports.emit = emit;\n\t  exports.link = link;\n\t  exports.prop = prop;\n\t  exports.ready = ready;\n\t  exports.state = state;\n\t  exports.symbols = symbols$1;\n\t  exports.vdom = vdom;\n\t\n\t  Object.defineProperty(exports, '__esModule', { value: true });\n\t});\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * @license\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t'use strict';\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * A cached reference to the hasOwnProperty function.\n\t */\n\t\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t/**\n\t * A cached reference to the create function.\n\t */\n\tvar create = Object.create;\n\t\n\t/**\n\t * Used to prevent property collisions between our \"map\" and its prototype.\n\t * @param {!Object<string, *>} map The map to check.\n\t * @param {string} property The property to check.\n\t * @return {boolean} Whether map has property.\n\t */\n\tvar has = function (map, property) {\n\t  return hasOwnProperty.call(map, property);\n\t};\n\t\n\t/**\n\t * Creates an map object without a prototype.\n\t * @return {!Object}\n\t */\n\tvar createMap = function () {\n\t  return create(null);\n\t};\n\t\n\t/**\n\t * Keeps track of information needed to perform diffs for a given DOM node.\n\t * @param {!string} nodeName\n\t * @param {?string=} key\n\t * @constructor\n\t */\n\tfunction NodeData(nodeName, key) {\n\t  /**\n\t   * The attributes and their values.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.attrs = createMap();\n\t\n\t  /**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t  this.attrsArr = [];\n\t\n\t  /**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.newAttrs = createMap();\n\t\n\t  /**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t  this.key = key;\n\t\n\t  /**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, !Element>}\n\t   */\n\t  this.keyMap = null;\n\t\n\t  /**\n\t   * Whether or not the keyMap is currently valid.\n\t   * {boolean}\n\t   */\n\t  this.keyMapValid = true;\n\t\n\t  /**\n\t   * The node name for this node.\n\t   * @const {string}\n\t   */\n\t  this.nodeName = nodeName;\n\t\n\t  /**\n\t   * @type {?string}\n\t   */\n\t  this.text = null;\n\t}\n\t\n\t/**\n\t * Initializes a NodeData object for a Node.\n\t *\n\t * @param {Node} node The node to initialize data for.\n\t * @param {string} nodeName The node name of node.\n\t * @param {?string=} key The key that identifies the node.\n\t * @return {!NodeData} The newly initialized data object\n\t */\n\tvar initData = function (node, nodeName, key) {\n\t  var data = new NodeData(nodeName, key);\n\t  node['__incrementalDOMData'] = data;\n\t  return data;\n\t};\n\t\n\t/**\n\t * Retrieves the NodeData object for a Node, creating it if necessary.\n\t *\n\t * @param {Node} node The node to retrieve the data for.\n\t * @return {!NodeData} The NodeData for this Node.\n\t */\n\tvar getData = function (node) {\n\t  var data = node['__incrementalDOMData'];\n\t\n\t  if (!data) {\n\t    var nodeName = node.nodeName.toLowerCase();\n\t    var key = null;\n\t\n\t    if (node instanceof Element) {\n\t      key = node.getAttribute('key');\n\t    }\n\t\n\t    data = initData(node, nodeName, key);\n\t  }\n\t\n\t  return data;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar symbols = {\n\t  default: '__default',\n\t\n\t  placeholder: '__placeholder'\n\t};\n\t\n\t/**\n\t * @param {string} name\n\t * @return {string|undefined} The namespace to use for the attribute.\n\t */\n\tvar getNamespace = function (name) {\n\t  if (name.lastIndexOf('xml:', 0) === 0) {\n\t    return 'http://www.w3.org/XML/1998/namespace';\n\t  }\n\t\n\t  if (name.lastIndexOf('xlink:', 0) === 0) {\n\t    return 'http://www.w3.org/1999/xlink';\n\t  }\n\t};\n\t\n\t/**\n\t * Applies an attribute or property to a given Element. If the value is null\n\t * or undefined, it is removed from the Element. Otherwise, the value is set\n\t * as an attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {?(boolean|number|string)=} value The attribute's value.\n\t */\n\tvar applyAttr = function (el, name, value) {\n\t  if (value == null) {\n\t    el.removeAttribute(name);\n\t  } else {\n\t    var attrNS = getNamespace(name);\n\t    if (attrNS) {\n\t      el.setAttributeNS(attrNS, name, value);\n\t    } else {\n\t      el.setAttribute(name, value);\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Applies a property to a given Element.\n\t * @param {!Element} el\n\t * @param {string} name The property's name.\n\t * @param {*} value The property's value.\n\t */\n\tvar applyProp = function (el, name, value) {\n\t  el[name] = value;\n\t};\n\t\n\t/**\n\t * Applies a style to an Element. No vendor prefix expansion is done for\n\t * property names/values.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} style The style to set. Either a string of css or an object\n\t *     containing property-value pairs.\n\t */\n\tvar applyStyle = function (el, name, style) {\n\t  if (typeof style === 'string') {\n\t    el.style.cssText = style;\n\t  } else {\n\t    el.style.cssText = '';\n\t    var elStyle = el.style;\n\t    var obj = /** @type {!Object<string,string>} */style;\n\t\n\t    for (var prop in obj) {\n\t      if (has(obj, prop)) {\n\t        elStyle[prop] = obj[prop];\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t/**\n\t * Updates a single attribute on an Element.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is an object or\n\t *     function it is set on the Element, otherwise, it is set as an HTML\n\t *     attribute.\n\t */\n\tvar applyAttributeTyped = function (el, name, value) {\n\t  var type = typeof value;\n\t\n\t  if (type === 'object' || type === 'function') {\n\t    applyProp(el, name, value);\n\t  } else {\n\t    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n\t  }\n\t};\n\t\n\t/**\n\t * Calls the appropriate attribute mutator for this attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value.\n\t */\n\tvar updateAttribute = function (el, name, value) {\n\t  var data = getData(el);\n\t  var attrs = data.attrs;\n\t\n\t  if (attrs[name] === value) {\n\t    return;\n\t  }\n\t\n\t  var mutator = attributes[name] || attributes[symbols.default];\n\t  mutator(el, name, value);\n\t\n\t  attrs[name] = value;\n\t};\n\t\n\t/**\n\t * A publicly mutable object to provide custom mutators for attributes.\n\t * @const {!Object<string, function(!Element, string, *)>}\n\t */\n\tvar attributes = createMap();\n\t\n\t// Special generic mutator that's called for any attribute that does not\n\t// have a specific mutator.\n\tattributes[symbols.default] = applyAttributeTyped;\n\t\n\tattributes[symbols.placeholder] = function () {};\n\t\n\tattributes['style'] = applyStyle;\n\t\n\t/**\n\t * Gets the namespace to create an element (of a given tag) in.\n\t * @param {string} tag The tag to get the namespace for.\n\t * @param {?Node} parent\n\t * @return {?string} The namespace to create the tag in.\n\t */\n\tvar getNamespaceForTag = function (tag, parent) {\n\t  if (tag === 'svg') {\n\t    return 'http://www.w3.org/2000/svg';\n\t  }\n\t\n\t  if (getData(parent).nodeName === 'foreignObject') {\n\t    return null;\n\t  }\n\t\n\t  return parent.namespaceURI;\n\t};\n\t\n\t/**\n\t * Creates an Element.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @param {?Node} parent\n\t * @param {string} tag The tag for the Element.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element.\n\t * @return {!Element}\n\t */\n\tvar createElement = function (doc, parent, tag, key, statics) {\n\t  var namespace = getNamespaceForTag(tag, parent);\n\t  var el = undefined;\n\t\n\t  if (namespace) {\n\t    el = doc.createElementNS(namespace, tag);\n\t  } else {\n\t    el = doc.createElement(tag);\n\t  }\n\t\n\t  initData(el, tag, key);\n\t\n\t  if (statics) {\n\t    for (var i = 0; i < statics.length; i += 2) {\n\t      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n\t    }\n\t  }\n\t\n\t  return el;\n\t};\n\t\n\t/**\n\t * Creates a Text Node.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @return {!Text}\n\t */\n\tvar createText = function (doc) {\n\t  var node = doc.createTextNode('');\n\t  initData(node, '#text', null);\n\t  return node;\n\t};\n\t\n\t/**\n\t * Creates a mapping that can be used to look up children using a key.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Element>} A mapping of keys to the children of the\n\t *     Element.\n\t */\n\tvar createKeyMap = function (el) {\n\t  var map = createMap();\n\t  var child = el.firstElementChild;\n\t\n\t  while (child) {\n\t    var key = getData(child).key;\n\t\n\t    if (key) {\n\t      map[key] = child;\n\t    }\n\t\n\t    child = child.nextElementSibling;\n\t  }\n\t\n\t  return map;\n\t};\n\t\n\t/**\n\t * Retrieves the mapping of key to child node for a given Element, creating it\n\t * if necessary.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Node>} A mapping of keys to child Elements\n\t */\n\tvar getKeyMap = function (el) {\n\t  var data = getData(el);\n\t\n\t  if (!data.keyMap) {\n\t    data.keyMap = createKeyMap(el);\n\t  }\n\t\n\t  return data.keyMap;\n\t};\n\t\n\t/**\n\t * Retrieves a child from the parent with the given key.\n\t * @param {?Node} parent\n\t * @param {?string=} key\n\t * @return {?Node} The child corresponding to the key.\n\t */\n\tvar getChild = function (parent, key) {\n\t  return key ? getKeyMap(parent)[key] : null;\n\t};\n\t\n\t/**\n\t * Registers an element as being a child. The parent will keep track of the\n\t * child using the key. The child can be retrieved using the same key using\n\t * getKeyMap. The provided key should be unique within the parent Element.\n\t * @param {?Node} parent The parent of child.\n\t * @param {string} key A key to identify the child with.\n\t * @param {!Node} child The child to register.\n\t */\n\tvar registerChild = function (parent, key, child) {\n\t  getKeyMap(parent)[key] = child;\n\t};\n\t\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/** @const */\n\tvar notifications = {\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been created\n\t   * and added to the DOM.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesCreated: null,\n\t\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been removed\n\t   * from the DOM.\n\t   * Note it's an applications responsibility to handle any childNodes.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesDeleted: null\n\t};\n\t\n\t/**\n\t * Keeps track of the state of a patch.\n\t * @constructor\n\t */\n\tfunction Context() {\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.created = notifications.nodesCreated && [];\n\t\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.deleted = notifications.nodesDeleted && [];\n\t}\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markCreated = function (node) {\n\t  if (this.created) {\n\t    this.created.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markDeleted = function (node) {\n\t  if (this.deleted) {\n\t    this.deleted.push(node);\n\t  }\n\t};\n\t\n\t/**\n\t * Notifies about nodes that were created during the patch opearation.\n\t */\n\tContext.prototype.notifyChanges = function () {\n\t  if (this.created && this.created.length > 0) {\n\t    notifications.nodesCreated(this.created);\n\t  }\n\t\n\t  if (this.deleted && this.deleted.length > 0) {\n\t    notifications.nodesDeleted(this.deleted);\n\t  }\n\t};\n\t\n\t/**\n\t* Makes sure that keyed Element matches the tag name provided.\n\t* @param {!string} nodeName The nodeName of the node that is being matched.\n\t* @param {string=} tag The tag name of the Element.\n\t* @param {?string=} key The key of the Element.\n\t*/\n\tvar assertKeyedTagMatches = function (nodeName, tag, key) {\n\t  if (nodeName !== tag) {\n\t    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n\t  }\n\t};\n\t\n\t/** @type {?Context} */\n\tvar context = null;\n\t\n\t/** @type {?Node} */\n\tvar currentNode = null;\n\t\n\t/** @type {?Node} */\n\tvar currentParent = null;\n\t\n\t/** @type {?Element|?DocumentFragment} */\n\tvar root = null;\n\t\n\t/** @type {?Document} */\n\tvar doc = null;\n\t\n\t/**\n\t * Returns a patcher function that sets up and restores a patch context,\n\t * running the run function with the provided data.\n\t * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n\t * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n\t * @template T\n\t */\n\tvar patchFactory = function (run) {\n\t  /**\n\t   * TODO(moz): These annotations won't be necessary once we switch to Closure\n\t   * Compiler's new type inference. Remove these once the switch is done.\n\t   *\n\t   * @param {(!Element|!DocumentFragment)} node\n\t   * @param {!function(T)} fn\n\t   * @param {T=} data\n\t   * @template T\n\t   */\n\t  var f = function (node, fn, data) {\n\t    var prevContext = context;\n\t    var prevRoot = root;\n\t    var prevDoc = doc;\n\t    var prevCurrentNode = currentNode;\n\t    var prevCurrentParent = currentParent;\n\t    var previousInAttributes = false;\n\t    var previousInSkip = false;\n\t\n\t    context = new Context();\n\t    root = node;\n\t    doc = node.ownerDocument;\n\t    currentParent = node.parentNode;\n\t\n\t    if (false) {}\n\t\n\t    run(node, fn, data);\n\t\n\t    if (false) {}\n\t\n\t    context.notifyChanges();\n\t\n\t    context = prevContext;\n\t    root = prevRoot;\n\t    doc = prevDoc;\n\t    currentNode = prevCurrentNode;\n\t    currentParent = prevCurrentParent;\n\t  };\n\t  return f;\n\t};\n\t\n\t/**\n\t * Patches the document starting at node with the provided function. This\n\t * function may be called during an existing patch operation.\n\t * @param {!Element|!DocumentFragment} node The Element or Document\n\t *     to patch.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchInner = patchFactory(function (node, fn, data) {\n\t  currentNode = node;\n\t\n\t  enterNode();\n\t  fn(data);\n\t  exitNode();\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Patches an Element with the the provided function. Exactly one top level\n\t * element call should be made corresponding to `node`.\n\t * @param {!Element} node The Element where the patch should start.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM. This should have at most one top level\n\t *     element call.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchOuter = patchFactory(function (node, fn, data) {\n\t  currentNode = /** @type {!Element} */{ nextSibling: node };\n\t\n\t  fn(data);\n\t\n\t  if (false) {}\n\t});\n\t\n\t/**\n\t * Checks whether or not the current node matches the specified nodeName and\n\t * key.\n\t *\n\t * @param {?string} nodeName The nodeName for this node.\n\t * @param {?string=} key An optional key that identifies a node.\n\t * @return {boolean} True if the node matches, false otherwise.\n\t */\n\tvar matches = function (nodeName, key) {\n\t  var data = getData(currentNode);\n\t\n\t  // Key check is done using double equals as we want to treat a null key the\n\t  // same as undefined. This should be okay as the only values allowed are\n\t  // strings, null and undefined so the == semantics are not too weird.\n\t  return nodeName === data.nodeName && key == data.key;\n\t};\n\t\n\t/**\n\t * Aligns the virtual Element definition with the actual DOM, moving the\n\t * corresponding DOM node to the correct location or creating it if necessary.\n\t * @param {string} nodeName For an Element, this should be a valid tag string.\n\t *     For a Text, this should be #text.\n\t * @param {?string=} key The key used to identify this element.\n\t * @param {?Array<*>=} statics For an Element, this should be an array of\n\t *     name-value pairs.\n\t */\n\tvar alignWithDOM = function (nodeName, key, statics) {\n\t  if (currentNode && matches(nodeName, key)) {\n\t    return;\n\t  }\n\t\n\t  var node = undefined;\n\t\n\t  // Check to see if the node has moved within the parent.\n\t  if (key) {\n\t    node = getChild(currentParent, key);\n\t    if (node && 'production' !== 'production') {\n\t      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n\t    }\n\t  }\n\t\n\t  // Create the node if it doesn't exist.\n\t  if (!node) {\n\t    if (nodeName === '#text') {\n\t      node = createText(doc);\n\t    } else {\n\t      node = createElement(doc, currentParent, nodeName, key, statics);\n\t    }\n\t\n\t    if (key) {\n\t      registerChild(currentParent, key, node);\n\t    }\n\t\n\t    context.markCreated(node);\n\t  }\n\t\n\t  // If the node has a key, remove it from the DOM to prevent a large number\n\t  // of re-orders in the case that it moved far or was completely removed.\n\t  // Since we hold on to a reference through the keyMap, we can always add it\n\t  // back.\n\t  if (currentNode && getData(currentNode).key) {\n\t    currentParent.replaceChild(node, currentNode);\n\t    getData(currentParent).keyMapValid = false;\n\t  } else {\n\t    currentParent.insertBefore(node, currentNode);\n\t  }\n\t\n\t  currentNode = node;\n\t};\n\t\n\t/**\n\t * Clears out any unvisited Nodes, as the corresponding virtual element\n\t * functions were never called for them.\n\t */\n\tvar clearUnvisitedDOM = function () {\n\t  var node = currentParent;\n\t  var data = getData(node);\n\t  var keyMap = data.keyMap;\n\t  var keyMapValid = data.keyMapValid;\n\t  var child = node.lastChild;\n\t  var key = undefined;\n\t\n\t  if (child === currentNode && keyMapValid) {\n\t    return;\n\t  }\n\t\n\t  if (data.attrs[symbols.placeholder] && node !== root) {\n\t    if (false) {}\n\t    return;\n\t  }\n\t\n\t  while (child !== currentNode) {\n\t    node.removeChild(child);\n\t    context.markDeleted( /** @type {!Node}*/child);\n\t\n\t    key = getData(child).key;\n\t    if (key) {\n\t      delete keyMap[key];\n\t    }\n\t    child = node.lastChild;\n\t  }\n\t\n\t  // Clean the keyMap, removing any unusued keys.\n\t  if (!keyMapValid) {\n\t    for (key in keyMap) {\n\t      child = keyMap[key];\n\t      if (child.parentNode !== node) {\n\t        context.markDeleted(child);\n\t        delete keyMap[key];\n\t      }\n\t    }\n\t\n\t    data.keyMapValid = true;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the first child of the current node.\n\t */\n\tvar enterNode = function () {\n\t  currentParent = currentNode;\n\t  currentNode = null;\n\t};\n\t\n\t/**\n\t * Changes to the next sibling of the current node.\n\t */\n\tvar nextNode = function () {\n\t  if (currentNode) {\n\t    currentNode = currentNode.nextSibling;\n\t  } else {\n\t    currentNode = currentParent.firstChild;\n\t  }\n\t};\n\t\n\t/**\n\t * Changes to the parent of the current node, removing any unvisited children.\n\t */\n\tvar exitNode = function () {\n\t  clearUnvisitedDOM();\n\t\n\t  currentNode = currentParent;\n\t  currentParent = currentParent.parentNode;\n\t};\n\t\n\t/**\n\t * Makes sure that the current node is an Element with a matching tagName and\n\t * key.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementOpen = function (tag, key, statics) {\n\t  nextNode();\n\t  alignWithDOM(tag, key, statics);\n\t  enterNode();\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Closes the currently open Element, removing any unvisited children if\n\t * necessary.\n\t *\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementClose = function () {\n\t  if (false) {}\n\t\n\t  exitNode();\n\t  return (/** @type {!Element} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Makes sure the current node is a Text node and creates a Text node if it is\n\t * not.\n\t *\n\t * @return {!Text} The corresponding Text Node.\n\t */\n\tvar coreText = function () {\n\t  nextNode();\n\t  alignWithDOM('#text', null, null);\n\t  return (/** @type {!Text} */currentNode\n\t  );\n\t};\n\t\n\t/**\n\t * Gets the current Element being patched.\n\t * @return {!Element}\n\t */\n\tvar currentElement = function () {\n\t  if (false) {}\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\t\n\t/**\n\t * Skips the children in a subtree, allowing an Element to be closed without\n\t * clearing out the children.\n\t */\n\tvar skip = function () {\n\t  if (false) {}\n\t  currentNode = currentParent.lastChild;\n\t};\n\t\n\t/**\n\t * The offset in the virtual element declaration where the attributes are\n\t * specified.\n\t * @const\n\t */\n\tvar ATTRIBUTES_OFFSET = 3;\n\t\n\t/**\n\t * Builds an array of arguments for use with elementOpenStart, attr and\n\t * elementOpenEnd.\n\t * @const {Array<*>}\n\t */\n\tvar argsBuilder = [];\n\t\n\t/**\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpen = function (tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreElementOpen(tag, key, statics);\n\t  var data = getData(node);\n\t\n\t  /*\n\t   * Checks to see if one or more attributes have changed for a given Element.\n\t   * When no attributes have changed, this is much faster than checking each\n\t   * individual argument. When attributes have changed, the overhead of this is\n\t   * minimal.\n\t   */\n\t  var attrsArr = data.attrsArr;\n\t  var newAttrs = data.newAttrs;\n\t  var attrsChanged = false;\n\t  var i = ATTRIBUTES_OFFSET;\n\t  var j = 0;\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    if (attrsArr[j] !== arguments[i]) {\n\t      attrsChanged = true;\n\t      break;\n\t    }\n\t  }\n\t\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    attrsArr[j] = arguments[i];\n\t  }\n\t\n\t  if (j < attrsArr.length) {\n\t    attrsChanged = true;\n\t    attrsArr.length = j;\n\t  }\n\t\n\t  /*\n\t   * Actually perform the attribute update.\n\t   */\n\t  if (attrsChanged) {\n\t    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t      newAttrs[arguments[i]] = arguments[i + 1];\n\t    }\n\t\n\t    for (var _attr in newAttrs) {\n\t      updateAttribute(node, _attr, newAttrs[_attr]);\n\t      newAttrs[_attr] = undefined;\n\t    }\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required. This is\n\t * like elementOpen, but the attributes are defined using the attr function\n\t * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t * to attr, then a call to elementOpenEnd.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t */\n\tvar elementOpenStart = function (tag, key, statics) {\n\t  if (false) {}\n\t\n\t  argsBuilder[0] = tag;\n\t  argsBuilder[1] = key;\n\t  argsBuilder[2] = statics;\n\t};\n\t\n\t/***\n\t * Defines a virtual attribute at this point of the DOM. This is only valid\n\t * when called between elementOpenStart and elementOpenEnd.\n\t *\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\tvar attr = function (name, value) {\n\t  if (false) {}\n\t\n\t  argsBuilder.push(name, value);\n\t};\n\t\n\t/**\n\t * Closes an open tag started with elementOpenStart.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpenEnd = function () {\n\t  if (false) {}\n\t\n\t  var node = elementOpen.apply(null, argsBuilder);\n\t  argsBuilder.length = 0;\n\t  return node;\n\t};\n\t\n\t/**\n\t * Closes an open virtual Element.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementClose = function (tag) {\n\t  if (false) {}\n\t\n\t  var node = coreElementClose();\n\t\n\t  if (false) {}\n\t\n\t  return node;\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that has\n\t * no children.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementVoid = function (tag, key, statics, const_args) {\n\t  elementOpen.apply(null, arguments);\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Element at the current location in the document that is a\n\t * placeholder element. Children of this Element can be manually managed and\n\t * will not be cleared by the library.\n\t *\n\t * A key must be specified to make sure that this node is correctly preserved\n\t * across all conditionals.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {string} key The key used to identify this element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementPlaceholder = function (tag, key, statics, const_args) {\n\t  if (false) {}\n\t\n\t  elementOpen.apply(null, arguments);\n\t  skip();\n\t  return elementClose(tag);\n\t};\n\t\n\t/**\n\t * Declares a virtual Text at this point in the document.\n\t *\n\t * @param {string|number|boolean} value The value of the Text.\n\t * @param {...(function((string|number|boolean)):string)} const_args\n\t *     Functions to format the value which are called only when the value has\n\t *     changed.\n\t * @return {!Text} The corresponding text node.\n\t */\n\tvar text = function (value, const_args) {\n\t  if (false) {}\n\t\n\t  var node = coreText();\n\t  var data = getData(node);\n\t\n\t  if (data.text !== value) {\n\t    data.text = /** @type {string} */value;\n\t\n\t    var formatted = value;\n\t    for (var i = 1; i < arguments.length; i += 1) {\n\t      /*\n\t       * Call the formatter function directly to prevent leaking arguments.\n\t       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n\t       */\n\t      var fn = arguments[i];\n\t      formatted = fn(formatted);\n\t    }\n\t\n\t    node.data = formatted;\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\texports.patch = patchInner;\n\texports.patchInner = patchInner;\n\texports.patchOuter = patchOuter;\n\texports.currentElement = currentElement;\n\texports.skip = skip;\n\texports.elementVoid = elementVoid;\n\texports.elementOpenStart = elementOpenStart;\n\texports.elementOpenEnd = elementOpenEnd;\n\texports.elementOpen = elementOpen;\n\texports.elementClose = elementClose;\n\texports.elementPlaceholder = elementPlaceholder;\n\texports.text = text;\n\texports.attr = attr;\n\texports.symbols = symbols;\n\texports.attributes = attributes;\n\texports.applyAttr = applyAttr;\n\texports.applyProp = applyProp;\n\texports.notifications = notifications;\n\t\n\t//# sourceMappingURL=incremental-dom-cjs.js.map\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// REGEX //\n\t\n\tvar re = '';\n\t\n\t// Use a native function as a template...\n\tre += Function.prototype.toString.call(Function);\n\t\n\t// Escape special RegExp characters...\n\tre = re.replace(/([.*+?^=!:$(){}|[\\]\\/\\\\])/g, '\\\\$1');\n\t\n\t// Replace any mentions of `Function` to make template generic.\n\t// Replace `for ...` and additional info provided in other environments, such as Rhino (see lodash).\n\tre = re.replace(/Function|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?');\n\t\n\t// Bracket the regex:\n\tre = '^' + re + '$';\n\t\n\t// EXPORTS //\n\t\n\tmodule.exports = new RegExp(re);\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar _hasOwn = Object.prototype.hasOwnProperty;\n\t\n\tvar _forOwn = function _forOwn(object, iterator) {\n\t  for (var prop in object) {\n\t    if (_hasOwn.call(object, prop)) iterator(object[prop], prop);\n\t  }\n\t};\n\t\n\tvar _renderArbitrary = function _renderArbitrary(child) {\n\t  var type = typeof child;\n\t\n\t  if (type === 'number' || type === 'string' || type === 'object' && child instanceof String) {\n\t    _skatejs.vdom.text(child);\n\t  } else if (type === 'function' && child.__jsxDOMWrapper) {\n\t    child();\n\t  } else if (Array.isArray(child)) {\n\t    child.forEach(_renderArbitrary);\n\t  } else if (type === 'object' && String(child) === '[object Object]') {\n\t    _forOwn(child, _renderArbitrary);\n\t  }\n\t};\n\t\n\tvar _skatejs = __webpack_require__(2);\n\t\n\tvar _index = __webpack_require__(6);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = function (props, chren) {\n\t  _skatejs.vdom.elementOpen('div', null, null, 'class', _index2.default.locals.body);\n\t\n\t  _skatejs.vdom.elementOpen('style');\n\t\n\t  _renderArbitrary(_index2.default.toString());\n\t\n\t  _skatejs.vdom.elementClose('style');\n\t\n\t  _renderArbitrary(chren());\n\t\n\t  return _skatejs.vdom.elementClose('div');\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(7)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".JotV9DC7cFGUX61mmETT1{background-color:#fefefe;color:#333;font-size:16px;padding:60px 20px 10px}\", \"\"]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"body\": \"JotV9DC7cFGUX61mmETT1\",\n\t\t\"body\": \"JotV9DC7cFGUX61mmETT1\"\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\n\t// css base code, injected by the css-loader\n\tmodule.exports = function () {\n\t\tvar list = [];\n\t\n\t\t// return the list of modules as css string\n\t\tlist.toString = function toString() {\n\t\t\tvar result = [];\n\t\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\t\tvar item = this[i];\n\t\t\t\tif (item[2]) {\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(item[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.join(\"\");\n\t\t};\n\t\n\t\t// import a list of modules into the list\n\t\tlist.i = function (modules, mediaQuery) {\n\t\t\tif (typeof modules === \"string\") modules = [[null, modules, \"\"]];\n\t\t\tvar alreadyImportedModules = {};\n\t\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\t\tvar id = this[i][0];\n\t\t\t\tif (typeof id === \"number\") alreadyImportedModules[id] = true;\n\t\t\t}\n\t\t\tfor (i = 0; i < modules.length; i++) {\n\t\t\t\tvar item = modules[i];\n\t\t\t\t// skip already imported module\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\t\tif (typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\t\tif (mediaQuery && !item[2]) {\n\t\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t\t} else if (mediaQuery) {\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tlist.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn list;\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _jsxWrapper = function _jsxWrapper(func, args) {\n\t  var wrapper = args ? function wrapper() {\n\t    return func.apply(this, args);\n\t  } : func;\n\t  wrapper.__jsxDOMWrapper = true;\n\t  return wrapper;\n\t};\n\t\n\tvar _hasOwn = Object.prototype.hasOwnProperty;\n\t\n\tvar _forOwn = function _forOwn(object, iterator) {\n\t  for (var prop in object) {\n\t    if (_hasOwn.call(object, prop)) iterator(object[prop], prop);\n\t  }\n\t};\n\t\n\tvar _renderArbitrary = function _renderArbitrary(child) {\n\t  var type = typeof child;\n\t\n\t  if (type === 'number' || type === 'string' || type === 'object' && child instanceof String) {\n\t    _skatejs.vdom.text(child);\n\t  } else if (type === 'function' && child.__jsxDOMWrapper) {\n\t    child();\n\t  } else if (Array.isArray(child)) {\n\t    child.forEach(_renderArbitrary);\n\t  } else if (type === 'object' && String(child) === '[object Object]') {\n\t    _forOwn(child, _renderArbitrary);\n\t  }\n\t};\n\t\n\tvar _skatejs = __webpack_require__(2);\n\t\n\tvar _index = __webpack_require__(9);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar List = function List(props) {\n\t  _skatejs.vdom.elementOpen('ul', null, null, 'class', _index2.default.locals.list);\n\t\n\t  _renderArbitrary(Object.keys(props.items).map(function (item) {\n\t    return _jsxWrapper(function (_css$locals$item, _css$locals$link, _props$items$item, _item) {\n\t      _skatejs.vdom.elementOpen('li', null, null, 'class', _css$locals$item);\n\t\n\t      _skatejs.vdom.elementOpen('a', null, null, 'class', _css$locals$link, 'href', _props$items$item);\n\t\n\t      _renderArbitrary(_item);\n\t\n\t      _skatejs.vdom.elementClose('a');\n\t\n\t      return _skatejs.vdom.elementClose('li');\n\t    }, [_index2.default.locals.item, _index2.default.locals.link, props.items[item], item]);\n\t  }));\n\t\n\t  return _skatejs.vdom.elementClose('ul');\n\t};\n\t\n\texports.default = function () {\n\t  _skatejs.vdom.elementOpen('div', null, null, 'class', _index2.default.locals.footer);\n\t\n\t  _skatejs.vdom.elementOpen('style');\n\t\n\t  _renderArbitrary(_index2.default.toString());\n\t\n\t  _skatejs.vdom.elementClose('style');\n\t\n\t  _skatejs.vdom.elementOpen(List, null, null, 'items', { Docs: 'docs/' });\n\t\n\t  _skatejs.vdom.elementClose(List);\n\t\n\t  return _skatejs.vdom.elementClose('div');\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(7)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"._2pOZ9JVRdOcst-M-V8CIG-{background-color:#333;color:#eee;font-size:12px;padding:10px 20px}.HAjb6JuBA0hiG3VMO17sO{padding:0}.ZXtuSy6oo7L79SnJvwsHt{color:#eee;text-decoration:none}._3k8ml8FyWDLKqwlHkSBmab{padding:0 0 0 20px}\", \"\"]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"footer\": \"_2pOZ9JVRdOcst-M-V8CIG-\",\n\t\t\"footer\": \"_2pOZ9JVRdOcst-M-V8CIG-\",\n\t\t\"item\": \"HAjb6JuBA0hiG3VMO17sO\",\n\t\t\"item\": \"HAjb6JuBA0hiG3VMO17sO\",\n\t\t\"link\": \"ZXtuSy6oo7L79SnJvwsHt\",\n\t\t\"link\": \"ZXtuSy6oo7L79SnJvwsHt\",\n\t\t\"list\": \"_3k8ml8FyWDLKqwlHkSBmab\",\n\t\t\"list\": \"_3k8ml8FyWDLKqwlHkSBmab\"\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tvar _hasOwn = Object.prototype.hasOwnProperty;\n\t\n\tvar _forOwn = function _forOwn(object, iterator) {\n\t  for (var prop in object) {\n\t    if (_hasOwn.call(object, prop)) iterator(object[prop], prop);\n\t  }\n\t};\n\t\n\tvar _renderArbitrary = function _renderArbitrary(child) {\n\t  var type = typeof child;\n\t\n\t  if (type === 'number' || type === 'string' || type === 'object' && child instanceof String) {\n\t    _skatejs.vdom.text(child);\n\t  } else if (type === 'function' && child.__jsxDOMWrapper) {\n\t    child();\n\t  } else if (Array.isArray(child)) {\n\t    child.forEach(_renderArbitrary);\n\t  } else if (type === 'object' && String(child) === '[object Object]') {\n\t    _forOwn(child, _renderArbitrary);\n\t  }\n\t};\n\t\n\tvar _skatejs = __webpack_require__(2);\n\t\n\tvar _index = __webpack_require__(11);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tvar _logo = __webpack_require__(12);\n\t\n\tvar _logo2 = _interopRequireDefault(_logo);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar Item = function Item(props, chren) {\n\t  _skatejs.vdom.elementOpen('li', null, null, 'class', _index2.default.locals.item);\n\t\n\t  _skatejs.vdom.elementOpen('a', null, null, 'class', _index2.default.locals.link, 'href', props.href);\n\t\n\t  _renderArbitrary(chren());\n\t\n\t  _skatejs.vdom.elementClose('a');\n\t\n\t  return _skatejs.vdom.elementClose('li');\n\t};\n\t\n\texports.default = function (props) {\n\t  _skatejs.vdom.elementOpen('div');\n\t\n\t  _skatejs.vdom.elementOpen('style');\n\t\n\t  _renderArbitrary(_index2.default.toString());\n\t\n\t  _skatejs.vdom.elementClose('style');\n\t\n\t  _skatejs.vdom.elementOpen('div', null, null, 'class', _index2.default.locals.header + ' ' + props.scrolled);\n\t\n\t  _skatejs.vdom.elementOpen('h1', null, null, 'class', _index2.default.locals.title);\n\t\n\t  _skatejs.vdom.elementVoid('img', null, null, 'alt', props.title, 'src', _logo2.default, 'width', '30');\n\t\n\t  _skatejs.vdom.elementClose('h1');\n\t\n\t  _skatejs.vdom.elementOpen('ul', null, null, 'class', _index2.default.locals.list);\n\t\n\t  _skatejs.vdom.elementOpen(Item, null, null, 'href', '');\n\t\n\t  _skatejs.vdom.text('Docs');\n\t\n\t  _skatejs.vdom.elementClose(Item);\n\t\n\t  _skatejs.vdom.elementOpen(Item, null, null, 'href', 'https://github.com/skatejs/skatejs');\n\t\n\t  _skatejs.vdom.text('Github');\n\t\n\t  _skatejs.vdom.elementClose(Item);\n\t\n\t  _skatejs.vdom.elementOpen(Item, null, null, 'href', '');\n\t\n\t  _skatejs.vdom.text('Community');\n\t\n\t  _skatejs.vdom.elementClose(Item);\n\t\n\t  _skatejs.vdom.elementClose('ul');\n\t\n\t  _skatejs.vdom.elementClose('div');\n\t\n\t  return _skatejs.vdom.elementClose('div');\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(7)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"._2Hd5KzDR5h1JLZaLAhkdnL{background-color:#fefefe;color:#333;position:fixed;transition:box-shadow .3s ease;width:100%}._10mxIH_-5Sk7Kz5KsJMq0H{box-shadow:0 0 15px 0 #333}._3EU-FaAppzWRdOf0yzUQbO{list-style:none}._3EU-FaAppzWRdOf0yzUQbO,._3h8r-c6pyf3k8OkYptB6eQ{display:inline-block;margin:0;padding:0}._1O98iTVLbgr87bKcZ1xtCv{display:inline-block;margin:0 20px 0 10px;padding:0;position:relative;left:14px;top:8px}._3gAAJyILxgLXLUDHVCLw1K{color:#333;display:inline-block;font-size:18px;margin:0;padding:20px;text-decoration:none;transition:background-color .3s ease}._3gAAJyILxgLXLUDHVCLw1K:hover{background-color:#eee}\", \"\"]);\n\t\n\t// exports\n\texports.locals = {\n\t\t\"header\": \"_2Hd5KzDR5h1JLZaLAhkdnL\",\n\t\t\"header\": \"_2Hd5KzDR5h1JLZaLAhkdnL\",\n\t\t\"header-scrolled\": \"_10mxIH_-5Sk7Kz5KsJMq0H\",\n\t\t\"headerScrolled\": \"_10mxIH_-5Sk7Kz5KsJMq0H\",\n\t\t\"list\": \"_3EU-FaAppzWRdOf0yzUQbO\",\n\t\t\"list\": \"_3EU-FaAppzWRdOf0yzUQbO\",\n\t\t\"item\": \"_3h8r-c6pyf3k8OkYptB6eQ\",\n\t\t\"item\": \"_3h8r-c6pyf3k8OkYptB6eQ\",\n\t\t\"title\": \"_1O98iTVLbgr87bKcZ1xtCv\",\n\t\t\"title\": \"_1O98iTVLbgr87bKcZ1xtCv\",\n\t\t\"link\": \"_3gAAJyILxgLXLUDHVCLw1K\",\n\t\t\"link\": \"_3gAAJyILxgLXLUDHVCLw1K\"\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__.p + \"dist/cdcf8f64994df2f0ca865f88e17aaa59.png\";\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (title) {\n\t  document.title = title;\n\t};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(7)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"html{font-family:Helvetica;font-size:14px}body{margin:0}a{color:#333}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/bundle.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 7d1133c1151b73de8d26\n **/","import App from './app/index';\nimport css from './index.css';\ndocument.head.innerHTML += `<style>${css}</style>`;\nexport { App };\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import { define, prop, vdom } from 'skatejs';\nimport Body from '../body';\nimport Footer from '../footer';\nimport Header from '../header';\nimport title from '../_/title';\n\nexport default define('sk-app', {\n  props: {\n    page: prop.string(),\n    scrolled: prop.boolean(),\n  },\n  attached(elem) {\n    window.addEventListener('scroll', elem._scrollHandler = () => (elem.scrolled = !!window.scrollY));\n    elem.page = 'testing...';\n  },\n  detached(elem) {\n    window.removeEventListener('scroll', elem._scrollHandler);\n  },\n  render(elem) {\n    title('SkateJS - functional web components');\n    return (\n      <div>\n        <Header scrolled={elem.scrolled} title=\"SkateJS\"></Header>\n        <Body>{elem.page}</Body>\n        <Footer></Footer>\n      </div>\n    );\n  },\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/index.js\n **/","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('incremental-dom'), require('regex-native-function')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'incremental-dom', 'regex-native-function'], factory) :\n  (factory((global.skate = global.skate || {}),global.IncrementalDOM,global.isNativeRegex));\n}(this, function (exports,incrementalDom,isNativeRegex) {\n\n  isNativeRegex = 'default' in isNativeRegex ? isNativeRegex['default'] : isNativeRegex;\n\n  var assign = Object.assign;\n  var assign$1 = assign ? assign.bind(Object) : function (obj) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    args.forEach(function (arg) {\n      return Object.keys(arg).forEach(function (name) {\n        return obj[name] = arg[name];\n      });\n    });\n    return obj;\n  };\n\n  function empty (val) {\n    return typeof val === 'undefined' || val === null;\n  }\n\n  var alwaysUndefinedIfNotANumberOrNumber = function alwaysUndefinedIfNotANumberOrNumber(val) {\n    return isNaN(val) ? undefined : Number(val);\n  };\n  var alwaysUndefinedIfEmptyOrString = function alwaysUndefinedIfEmptyOrString(val) {\n    return empty(val) ? undefined : String(val);\n  };\n\n  function create(def) {\n    return function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      args.unshift({}, def);\n      return assign$1.apply(null, args);\n    };\n  }\n\n  var array = create({\n    coerce: function coerce(val) {\n      return Array.isArray(val) ? val : [val];\n    },\n    default: function _default() {\n      return [];\n    },\n    deserialize: JSON.parse,\n    serialize: JSON.stringify\n  });\n\n  var boolean = create({\n    coerce: function coerce(value) {\n      return !!value;\n    },\n    default: false,\n    deserialize: function deserialize(value) {\n      return !(value === null);\n    },\n    serialize: function serialize(value) {\n      return value ? '' : undefined;\n    }\n  });\n\n  var number = create({\n    default: 0,\n    coerce: alwaysUndefinedIfNotANumberOrNumber,\n    deserialize: alwaysUndefinedIfNotANumberOrNumber,\n    serialize: alwaysUndefinedIfNotANumberOrNumber\n  });\n\n  var string = create({\n    coerce: alwaysUndefinedIfEmptyOrString,\n    deserialize: alwaysUndefinedIfEmptyOrString,\n    serialize: alwaysUndefinedIfEmptyOrString\n  });\n\nvar prop = Object.freeze({\n    create: create,\n    array: array,\n    boolean: boolean,\n    number: number,\n    string: string\n  });\n\n  var $created = '____skate_created';\n  var $ctor = '____skate_constructor';\n  var $events = '____skate_events';\n  var $name = '____skate_name';\n  var $props = '____skate_props';\n  var $renderer = '____skate_renderer';\n  var $rendererDebounced = '____skate_rendererDebounced';\n  var $shadowRoot = '____skate_shadowRoot';\n\n\n\n  var symbols$1 = Object.freeze({\n  \tname: $name,\n  \tshadowRoot: $shadowRoot\n  });\n\n  // checks if a function is native using regex\n\n  var div = document.createElement('div');\n  var isNative = function isNative(elem, prop) {\n    return isNativeRegex.test(elem[prop]);\n  };\n  var isPolyfill = function isPolyfill(elem, prop) {\n    return !!elem[prop] && !isNative(elem, prop);\n  };\n\n  // property used to check for shadowDOMv0 support\n  var v0ShadowDOMProperty = 'createShadowRoot';\n\n  // property used to check for shadowDOMv1 support\n  var v1ShadowDOMProperty = 'attachShadow';\n\n  function shouldUseShadowDomV0(elem) {\n    if (isNative(elem, v1ShadowDOMProperty)) {\n      return false;\n    } else if (isPolyfill(elem, v1ShadowDOMProperty) && isNative(elem, v0ShadowDOMProperty)) {\n      return true;\n    } else if (!isPolyfill(elem, v1ShadowDOMProperty) && isNative(elem, v0ShadowDOMProperty)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function shouldUseShadowDomV1(elem) {\n    if (isNative(elem, v1ShadowDOMProperty)) {\n      return true;\n    } else if (isPolyfill(elem, v1ShadowDOMProperty) && isNative(elem, v0ShadowDOMProperty)) {\n      return false;\n    } else if (isPolyfill(elem, v1ShadowDOMProperty)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  var customElementsV0 = !!document.registerElement;\n  var customElementsV0Polyfill = customElementsV0 && !Document.prototype.registerElement;\n  var customElementsV1 = !!window.customElements;\n\n  var shadowDomV0 = shouldUseShadowDomV0(div);\n  var shadowDomV1 = shouldUseShadowDomV1(div);\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n  };\n\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  var defineProperty = function (obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  };\n\n  var inherits = function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  };\n\n  var possibleConstructorReturn = function (self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  };\n\n  var toConsumableArray = function (arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    } else {\n      return Array.from(arr);\n    }\n  };\n\n  var applyDefault = incrementalDom.attributes[incrementalDom.symbols.default];\n  var fallbackToV0 = !shadowDomV1 && shadowDomV0;\n  var stackChren = [];\n  var stackProps = [];\n\n  // Attributes that are not handled by Incremental DOM.\n  incrementalDom.attributes.key = incrementalDom.attributes.skip = incrementalDom.attributes.statics = function () {};\n\n  // Attributes that *must* be set via a property on all elements.\n  incrementalDom.attributes.checked = incrementalDom.attributes.className = incrementalDom.attributes.disabled = incrementalDom.attributes.value = incrementalDom.applyProp;\n\n  // Default attribute applicator.\n  incrementalDom.attributes[incrementalDom.symbols.default] = function (elem, name, value) {\n    // If the skip attribute was specified, skip\n    if (name === 'skip' && value) {\n      return incrementalDom.skip();\n    }\n\n    // Custom element properties should be set as properties.\n    var props = elem.constructor.props;\n    if (props && name in props) {\n      return incrementalDom.applyProp(elem, name, value);\n    }\n\n    // Boolean false values should not set attributes at all.\n    if (value === false) {\n      return;\n    }\n\n    // Handle built-in and custom events.\n    if (name.indexOf('on') === 0) {\n      return name in elem ? incrementalDom.applyProp(elem, name, value) : applyEvent(elem, name.substring(2), name, value);\n    }\n\n    // Set the select attribute instead of name if it was a <slot> translated to\n    // a <content> for v0.\n    if (name === 'name' && elem.tagName === 'CONTENT') {\n      name = 'select';\n      value = '[slot=\"' + value + '\"]';\n    }\n\n    // Fallback to default IncrementalDOM behaviour.\n    applyDefault(elem, name, value);\n  };\n\n  // Adds or removes an event listener for an element.\n  function applyEvent(elem, ename, name, value) {\n    var events = elem.__events;\n\n    if (!events) {\n      events = elem.__events = {};\n    }\n\n    var eFunc = events[ename];\n\n    // Remove old listener so they don't double up.\n    if (eFunc) {\n      elem.removeEventListener(ename, eFunc);\n    }\n\n    // Bind new listener.\n    if (value) {\n      elem.addEventListener(ename, events[ename] = value);\n    }\n  }\n\n  function resolveTagName(tname) {\n    // If the tag name is a function, a Skate constructor or a standard function\n    // is supported.\n    //\n    // - If a Skate constructor, the tag name is extracted from that.\n    // - If a standard function, it is used as a helper.\n    if (typeof tname === 'function') {\n      return tname[$name] || tname;\n    }\n\n    // Skate allows the consumer to use <slot /> and it will translate it to\n    // <content /> if Shadow DOM V0 is preferred.\n    if (tname === 'slot' && fallbackToV0) {\n      return 'content';\n    }\n\n    // All other tag names are just passed through.\n    return tname;\n  }\n\n  function wrapIdomFunc(func) {\n    var tnameFuncHandler = arguments.length <= 1 || arguments[1] === undefined ? function () {} : arguments[1];\n\n    return function wrap() {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var tname = args[0] = resolveTagName(args[0]);\n      if (typeof tname === 'function') {\n        // If we've encountered a function, handle it according to the type of\n        // function that is being wrapped.\n        tnameFuncHandler(tname);\n      } else if (stackChren.length) {\n        // We pass the wrap() function in here so that when it's called as\n        // children, it will queue up for the next stack, if there is one.\n        stackChren[stackChren.length - 1].push([wrap, args]);\n      } else {\n        // If there is no stack left, we call Incremental DOM directly.\n        return func.apply(undefined, args);\n      }\n    };\n  }\n\n  function newAttr(key, val) {\n    if (stackProps.length) {\n      stackProps[stackProps.length - 1][key] = val;\n    } else {\n      return incrementalDom.attr(key, val);\n    }\n  }\n\n  function stackOpen() {\n    stackChren.push([]);\n    stackProps.push({});\n  }\n\n  function stackClose(tname) {\n    var chren = stackChren.pop();\n    var props = stackProps.pop();\n    tname(props, function () {\n      return chren.forEach(function (args) {\n        return args[0].apply(args, toConsumableArray(args[1]));\n      });\n    });\n  }\n\n  // Convenience function for declaring an Incremental DOM element using\n  // hyperscript-style syntax.\n  function element(tname, attrs, chren) {\n    var atype = typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs);\n\n    // If attributes are a function, then they should be treated as children.\n    if (atype === 'function' || atype === 'string') {\n      chren = attrs;\n    }\n\n    // Ensure the attributes are an object.\n    if (atype !== 'object') {\n      attrs = {};\n    }\n\n    // We open the element so we can set attrs after.\n    newElementOpenStart(tname, attrs.key, attrs.statics);\n\n    // Delete so special attrs don't actually get set.\n    delete attrs.key;\n    delete attrs.statics;\n\n    // Set attributes.\n    Object.keys(attrs).forEach(function (name) {\n      return newAttr(name, attrs[name]);\n    });\n\n    // Close before we render the descendant tree.\n    newElementOpenEnd(tname);\n\n    var ctype = typeof chren === 'undefined' ? 'undefined' : _typeof(chren);\n    if (ctype === 'function') {\n      chren();\n    } else if (ctype === 'string' || ctype === 'number') {\n      newText(chren);\n    }\n\n    return newElementClose(tname);\n  }\n\n  // Patch element factories.\n  var newElementClose = wrapIdomFunc(incrementalDom.elementClose, stackClose);\n  var newElementOpen = wrapIdomFunc(incrementalDom.elementOpen, stackOpen);\n  var newElementOpenEnd = wrapIdomFunc(incrementalDom.elementOpenEnd);\n  var newElementOpenStart = wrapIdomFunc(incrementalDom.elementOpenStart, stackOpen);\n  var newElementVoid = wrapIdomFunc(incrementalDom.elementVoid);\n  var newText = wrapIdomFunc(incrementalDom.text);\n\n\n\n  var vdom = Object.freeze({\n    element: element,\n    attr: newAttr,\n    elementClose: newElementClose,\n    elementOpen: newElementOpen,\n    elementOpenEnd: newElementOpenEnd,\n    elementOpenStart: newElementOpenStart,\n    elementVoid: newElementVoid,\n    text: newText\n  });\n\n  function data (element) {\n    var namespace = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\n    var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n    return namespace && (data[namespace] || (data[namespace] = {})) || data;\n  }\n\n  var definePropertyConstructor = (function (obj, value) {\n    return Object.defineProperty(obj, 'constructor', { enumerable: false, value: value });\n  });\n\n  function getOwnPropertyDescriptors (obj) {\n    return Object.getOwnPropertyNames(obj || {}).reduce(function (prev, curr) {\n      prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n      return prev;\n    }, {});\n  }\n\n  // In native Custom Elements v0, you can extend HTMLElement. In the polyfill\n  // you cannot, so we ensure the polyfill has a patched HTMLElement constructor.\n  if (customElementsV0Polyfill) {\n    var proto = HTMLElement.prototype;\n    window.HTMLElement = function () {\n      var ctor = this[$ctor];\n      var name = this[$name];\n      var type = ctor.extends;\n      return document.createElement(type || name, type ? name : null);\n    };\n    HTMLElement.prototype = Object.create(proto);\n    definePropertyConstructor(HTMLElement.prototype, HTMLElement);\n  }\n\n  var Component = function (_HTMLElement) {\n    inherits(Component, _HTMLElement);\n\n    function Component() {\n      classCallCheck(this, Component);\n\n      var _this = possibleConstructorReturn(this, Object.getPrototypeOf(Component).call(this));\n\n      _this.createdCallback();\n      return _this;\n    }\n\n    createClass(Component, [{\n      key: 'connectedCallback',\n      value: function connectedCallback() {\n        var cb = this.constructor.attached;\n        cb && cb(this);\n      }\n    }, {\n      key: 'disconnectedCallback',\n      value: function disconnectedCallback() {\n        var cb = this.constructor.detached;\n        cb && cb(this);\n      }\n    }, {\n      key: 'attributeChangedCallback',\n      value: function attributeChangedCallback(name, oldValue, newValue) {\n        var _constructor = this.constructor;\n        var attributeChanged = _constructor.attributeChanged;\n        var observedAttributes = _constructor.observedAttributes;\n\n        var propertyName = data(this, 'attributeLinks')[name];\n\n        // In V0 we have to ensure the attribute is being observed.\n        if (customElementsV0 && observedAttributes.indexOf(name) === -1) {\n          return;\n        }\n\n        if (propertyName) {\n          var propData = data(this, 'api/property/' + propertyName);\n\n          // This ensures a property set doesn't cause the attribute changed\n          // handler to run again once we set this flag. This only ever has a\n          // chance to run when you set an attribute, it then sets a property and\n          // then that causes the attribute to be set again.\n          if (propData.syncingAttribute) {\n            propData.syncingAttribute = false;\n            return;\n          }\n\n          // Sync up the property.\n          var propOpts = this.constructor.props[propertyName];\n          propData.settingAttribute = true;\n          this[propertyName] = newValue !== null && propOpts.deserialize ? propOpts.deserialize(newValue) : newValue;\n        }\n\n        if (attributeChanged) {\n          attributeChanged(this, { name: name, newValue: newValue, oldValue: oldValue });\n        }\n      }\n    }, {\n      key: 'createdCallback',\n      value: function createdCallback() {\n        var _this2 = this;\n\n        // In the polyfill, if you define a custom element after it has been\n        // created the polyfill will call the constructor it has on record thus\n        // ignoring the one the user has defined for the element. We ensure the\n        // constructor is actually the one that was specified in the definition\n        // rather than the one the polyfill gives it.\n        //\n        // In native v0 this behaves normally, so we only need to worry about the\n        // polyfill here.\n        if (customElementsV0Polyfill) {\n          definePropertyConstructor(this, this[$ctor]);\n        }\n\n        var elemData = data(this);\n        var readyCallbacks = elemData.readyCallbacks;\n        var Ctor = this.constructor;\n        var definedAttribute = Ctor.definedAttribute;\n        var events = Ctor.events;\n        var created = Ctor.created;\n        var observedAttributes = Ctor.observedAttributes;\n        var props = Ctor.props;\n        var ready = Ctor.ready;\n        var renderedAttribute = Ctor.renderedAttribute;\n\n        var renderer = Ctor[$renderer];\n\n        // TODO: This prevents an element from being initialised multiple times. For\n        // some reason this is happening in the event tests. It's possibly creating\n        // elements in a way that the causes the custom element v1 polyfill to call\n        // the constructor twice.\n        if (this[$created]) return;\n        this[$created] = true;\n\n        if (props) {\n          Ctor[$props](this);\n        }\n\n        if (events) {\n          Ctor[$events](this);\n        }\n\n        if (created) {\n          created(this);\n        }\n\n        if (renderer && !this.hasAttribute(renderedAttribute)) {\n          renderer(this);\n        }\n\n        if (ready) {\n          ready(this);\n        }\n\n        if (!this.hasAttribute(definedAttribute)) {\n          this.setAttribute(definedAttribute, '');\n        }\n\n        if (readyCallbacks) {\n          readyCallbacks.forEach(function (cb) {\n            return cb(_this2);\n          });\n          delete elemData.readyCallbacks;\n        }\n\n        // In v0 we must ensure the attributeChangedCallback is called for attrs\n        // that aren't linked to props so that the callback behaves the same no\n        // matter if v0 or v1 is being used.\n        if (customElementsV0) {\n          observedAttributes.forEach(function (name) {\n            var propertyName = data(_this2, 'attributeLinks')[name];\n            if (!propertyName) {\n              _this2.attributeChangedCallback(name, null, _this2.getAttribute(name));\n            }\n          });\n        }\n      }\n    }, {\n      key: 'attachedCallback',\n      value: function attachedCallback() {\n        this.connectedCallback();\n      }\n    }, {\n      key: 'detachedCallback',\n      value: function detachedCallback() {\n        this.disconnectedCallback();\n      }\n    }], [{\n      key: 'extend',\n      value: function extend() {\n        var definition = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n        var Base = arguments.length <= 1 || arguments[1] === undefined ? this : arguments[1];\n\n        // Create class for the user.\n\n        var Ctor = function (_Base) {\n          inherits(Ctor, _Base);\n\n          function Ctor() {\n            classCallCheck(this, Ctor);\n            return possibleConstructorReturn(this, Object.getPrototypeOf(Ctor).apply(this, arguments));\n          }\n\n          return Ctor;\n        }(Base);\n\n        // For inheriting from the object literal.\n\n\n        var opts = getOwnPropertyDescriptors(definition);\n        var prot = getOwnPropertyDescriptors(definition.prototype);\n\n        // Prototype is non configurable (but is writable) s\n        delete opts.prototype;\n\n        // Pass on static and instance members from the definition.\n        Object.defineProperties(Ctor, opts);\n        Object.defineProperties(Ctor.prototype, prot);\n\n        return Ctor;\n      }\n    }, {\n      key: 'definedAttribute',\n      get: function get() {\n        return 'defined';\n      }\n    }, {\n      key: 'events',\n      get: function get() {\n        return {};\n      }\n    }, {\n      key: 'observedAttributes',\n      get: function get() {\n        return [];\n      }\n    }, {\n      key: 'props',\n      get: function get() {\n        return {};\n      }\n    }, {\n      key: 'renderedAttribute',\n      get: function get() {\n        return 'rendered';\n      }\n    }]);\n    return Component;\n  }(HTMLElement);\n\n  var elProto = window.HTMLElement.prototype;\n  var nativeMatchesSelector = elProto.matches || elProto.msMatchesSelector || elProto.webkitMatchesSelector || elProto.mozMatchesSelector || elProto.oMatchesSelector;\n\n  // Only IE9 has this msMatchesSelector bug, but best to detect it.\n  var hasNativeMatchesSelectorDetattachedBug = !nativeMatchesSelector.call(document.createElement('div'), 'div');\n\n  function matches (element, selector) {\n    if (hasNativeMatchesSelectorDetattachedBug) {\n      var clone = element.cloneNode();\n      document.createElement('div').appendChild(clone);\n      return nativeMatchesSelector.call(clone, selector);\n    }\n    return nativeMatchesSelector.call(element, selector);\n  }\n\n  function readonly(obj, prop, val) {\n    Object.defineProperty(obj, prop, {\n      configurable: true,\n      get: function get() {\n        return val;\n      }\n    });\n  }\n\n  function parseEvent(e) {\n    var indexOfSpace = e.indexOf(' ');\n    var hasSpace = indexOfSpace > 0;\n    var name = hasSpace ? e.substring(0, indexOfSpace) : e;\n    var selector = hasSpace ? e.substring(indexOfSpace + 1) : '';\n    return {\n      name: name,\n      selector: selector\n    };\n  }\n\n  function makeDelegateHandler(elem, handler, parsed) {\n    return function (e) {\n      var current = e.path ? e.path[0] : e.target;\n      var selector = parsed.selector;\n      while (current && current !== elem.parentNode) {\n        if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n          break;\n        }\n        if (matches(current, selector)) {\n          readonly(e, 'currentTarget', current);\n          readonly(e, 'delegateTarget', elem);\n          return handler(elem, e);\n        }\n        current = current.parentNode;\n      }\n    };\n  }\n\n  function makeNormalHandler(elem, handler) {\n    return function (e) {\n      readonly(e, 'delegateTarget', elem);\n      handler(elem, e);\n    };\n  }\n\n  function bindEvent(elem, event, handler) {\n    var parsed = parseEvent(event);\n    var name = parsed.name;\n    var selector = parsed.selector;\n\n    var capture = selector && (name === 'blur' || name === 'focus');\n    handler = selector ? makeDelegateHandler(elem, handler, parsed) : makeNormalHandler(elem, handler);\n    elem.addEventListener(name, handler, capture);\n  }\n\n  function events(opts) {\n    var events = opts.events || {};\n    return function (elem) {\n      for (var name in events) {\n        bindEvent(elem, name, events[name]);\n      }\n    };\n  }\n\n  function createRenderer (Ctor) {\n    var render = Ctor.render;\n\n\n    return function (elem) {\n      if (!render) {\n        return;\n      }\n\n      if (!elem[$shadowRoot]) {\n        var sr = void 0;\n\n        if (shadowDomV1) {\n          sr = elem.attachShadow({ mode: 'open' });\n        } else if (shadowDomV0) {\n          sr = elem.createShadowRoot();\n        } else {\n          sr = elem;\n        }\n\n        elem[$shadowRoot] = sr;\n      }\n\n      incrementalDom.patchInner(elem[$shadowRoot], render, elem);\n    };\n  }\n\n  function dashCase (str) {\n    return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n      var dash = !one || idx % 2 === 0 ? '' : '-';\n      return '' + one + dash + two.toLowerCase();\n    });\n  }\n\n  function debounce (fn) {\n    var called = false;\n    return function () {\n      var _this = this;\n\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      if (!called) {\n        called = true;\n        setTimeout(function () {\n          called = false;\n          fn.apply(_this, args);\n        });\n      }\n    };\n  }\n\n  var CustomEvent = function (CustomEvent) {\n    if (CustomEvent) {\n      try {\n        new CustomEvent();\n      } catch (e) {\n        return undefined;\n      }\n    }\n    return CustomEvent;\n  }(window.CustomEvent);\n\n  function createCustomEvent(name) {\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    if (CustomEvent) {\n      return new CustomEvent(name, opts);\n    }\n    var e = document.createEvent('CustomEvent');\n    e.initCustomEvent(name, opts.bubbles, opts.cancelable, opts.detail);\n    return e;\n  }\n\n  function emit (elem, name) {\n    var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    /* jshint expr: true */\n    opts.bubbles === undefined && (opts.bubbles = true);\n    opts.cancelable === undefined && (opts.cancelable = true);\n    return elem.disabled ? true : elem.dispatchEvent(createCustomEvent(name, opts));\n  }\n\n  function getDefaultValue(elem, name, opts) {\n    return typeof opts.default === 'function' ? opts.default(elem, { name: name }) : opts.default;\n  }\n\n  function getInitialValue(elem, name, opts) {\n    return typeof opts.initial === 'function' ? opts.initial(elem, { name: name }) : opts.initial;\n  }\n\n  function createNativePropertyDefinition(name, opts) {\n    var prop = {\n      configurable: true,\n      enumerable: true\n    };\n\n    prop.created = function (elem) {\n      var propData = data(elem, 'api/property/' + name);\n      var attributeName = opts.attribute;\n      var initialValue = elem[name];\n      var shouldSyncAttribute = false;\n\n      // Store property to attribute link information.\n      data(elem, 'attributeLinks')[attributeName] = name;\n      data(elem, 'propertyLinks')[name] = attributeName;\n\n      // Set up initial value if it wasn't specified.\n      if (empty(initialValue)) {\n        if (attributeName && elem.hasAttribute(attributeName)) {\n          initialValue = opts.deserialize(elem.getAttribute(attributeName));\n        } else if ('initial' in opts) {\n          initialValue = getInitialValue(elem, name, opts);\n          shouldSyncAttribute = true;\n        } else if ('default' in opts) {\n          initialValue = getDefaultValue(elem, name, opts);\n        }\n      }\n\n      if (shouldSyncAttribute) {\n        prop.set.call(elem, initialValue);\n      } else {\n        propData.internalValue = opts.coerce ? opts.coerce(initialValue) : initialValue;\n      }\n    };\n\n    prop.get = function () {\n      var propData = data(this, 'api/property/' + name);\n      var internalValue = propData.internalValue;\n\n      if (typeof opts.get === 'function') {\n        return opts.get(this, { name: name, internalValue: internalValue });\n      }\n      return internalValue;\n    };\n\n    prop.render = function () {\n      var shouldUpdate = opts.render;\n      if (typeof shouldUpdate === 'undefined') {\n        return function (elem, data) {\n          return data.newValue !== data.oldValue;\n        };\n      }\n      if (typeof shouldUpdate === 'function') {\n        return shouldUpdate;\n      }\n      return function () {\n        return !!shouldUpdate;\n      };\n    }();\n\n    prop.set = function (newValue) {\n      var propData = data(this, 'api/property/' + name);\n      var oldValue = propData.oldValue;\n\n      var shouldRemoveAttribute = false;\n\n      if (empty(oldValue)) {\n        oldValue = null;\n      }\n\n      if (empty(newValue)) {\n        newValue = getDefaultValue(this, name, opts);\n        shouldRemoveAttribute = true;\n      }\n\n      if (typeof opts.coerce === 'function') {\n        newValue = opts.coerce(newValue);\n      }\n\n      var propertyHasChanged = newValue !== oldValue;\n      if (propertyHasChanged && opts.event) {\n        var canceled = !emit(this, String(opts.event), {\n          bubbles: false,\n          detail: { name: name, oldValue: oldValue, newValue: newValue }\n        });\n\n        if (canceled) {\n          return;\n        }\n      }\n\n      propData.internalValue = newValue;\n\n      var changeData = { name: name, newValue: newValue, oldValue: oldValue };\n\n      if (typeof opts.set === 'function') {\n        opts.set(this, changeData);\n      }\n\n      // Re-render on property updates if the should-update check passes.\n      if (prop.render(this, changeData)) {\n        var deb = this[$rendererDebounced] || (this[$rendererDebounced] = debounce(this.constructor[$renderer]));\n        deb(this);\n      }\n\n      propData.oldValue = newValue;\n\n      // Link up the attribute.\n      var attributeName = data(this, 'propertyLinks')[name];\n      if (attributeName && !propData.settingAttribute) {\n        var serializedValue = opts.serialize(newValue);\n        propData.syncingAttribute = true;\n        if (shouldRemoveAttribute || empty(serializedValue)) {\n          this.removeAttribute(attributeName);\n        } else {\n          this.setAttribute(attributeName, serializedValue);\n        }\n      }\n\n      // Allow the attribute to be linked again.\n      propData.settingAttribute = false;\n    };\n\n    return prop;\n  }\n\n  function initProps (opts) {\n    opts = opts || {};\n\n    if (typeof opts === 'function') {\n      opts = { coerce: opts };\n    }\n\n    return function (name) {\n      return createNativePropertyDefinition(name, assign$1({\n        default: null,\n        deserialize: function deserialize(value) {\n          return value;\n        },\n        serialize: function serialize(value) {\n          return value;\n        }\n      }, opts));\n    };\n  }\n\n  var registry = {};\n\n  // Ensures that definitions passed as part of the constructor are functions\n  // that return property definitions used on the element.\n  function ensurePropertyFunctions(Ctor) {\n    var props = Ctor.props;\n    var names = Object.keys(props || {});\n    return names.reduce(function (descriptors, descriptorName) {\n      descriptors[descriptorName] = props[descriptorName];\n      if (typeof descriptors[descriptorName] !== 'function') {\n        descriptors[descriptorName] = initProps(descriptors[descriptorName]);\n      }\n      return descriptors;\n    }, {});\n  }\n\n  // Ensures the property definitions are transformed to objects that can be used\n  // to create properties on the element.\n  function ensurePropertyDefinitions(Ctor) {\n    var props = ensurePropertyFunctions(Ctor);\n    return Object.keys(props).reduce(function (descriptors, descriptorName) {\n      descriptors[descriptorName] = props[descriptorName](descriptorName);\n      return descriptors;\n    }, {});\n  }\n\n  // Ensures linked properties that have linked attributes are pre-formatted to\n  // the attribute name in which they are linked.\n  function formatLinkedAttributes(Ctor) {\n    var observedAttributes = Ctor.observedAttributes;\n    var props = Ctor.props;\n\n\n    if (!props) {\n      return;\n    }\n\n    Object.keys(props).forEach(function (name) {\n      var prop = props[name];\n      var attr = prop.attribute;\n      if (attr) {\n        // Ensure the property is updated.\n        var linkedAttr = prop.attribute = attr === true ? dashCase(name) : attr;\n\n        // Automatically observe the attribute since they're linked from the\n        // attributeChangedCallback.\n        if (observedAttributes.indexOf(linkedAttr) === -1) {\n          observedAttributes.push(linkedAttr);\n        }\n      }\n    });\n\n    // Merge observed attributes.\n    Object.defineProperty(Ctor, 'observedAttributes', {\n      configurable: true,\n      enumerable: true,\n      get: function get() {\n        return observedAttributes;\n      }\n    });\n  }\n\n  function createInitProps(Ctor) {\n    var props = ensurePropertyDefinitions(Ctor);\n\n    return function (elem) {\n      if (!props) {\n        return;\n      }\n\n      Object.keys(props).forEach(function (name) {\n        var prop = props[name];\n        prop.created(elem);\n\n        // https://bugs.webkit.org/show_bug.cgi?id=49739\n        //\n        // When Webkit fixes that bug so that native property accessors can be\n        // retrieved, we can move defining the property to the prototype and away\n        // from having to do if for every instance as all other browsers support\n        // this.\n        Object.defineProperty(elem, name, prop);\n      });\n    };\n  }\n\n  function generateUniqueName(name) {\n    var registered = registry[name];\n    return registered ? name + '-' + registered : name;\n  }\n\n  function registerUniqueName(name) {\n    registry[name] = registry[name] ? registry[name] + 1 : 1;\n  }\n\n  function define (name, opts) {\n    var uniqueName = generateUniqueName(name);\n    var Ctor = (typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) === 'object' ? Component.extend(opts) : opts;\n\n    registerUniqueName(name);\n    formatLinkedAttributes(Ctor);\n\n    Ctor[$events] = events(Ctor);\n    Ctor[$name] = uniqueName;\n    Ctor[$props] = createInitProps(Ctor);\n    Ctor[$renderer] = createRenderer(Ctor);\n\n    if (customElementsV0) {\n      // These properties are necessary for the Custom Element v0 polyfill so\n      // that we can fix it not working with extending the built-in HTMLElement.\n      Ctor.prototype[$ctor] = Ctor;\n      Ctor.prototype[$name] = uniqueName;\n      var NewCtor = document.registerElement(uniqueName, Ctor);\n      definePropertyConstructor(NewCtor.prototype, Ctor);\n      return customElementsV0Polyfill ? Ctor : NewCtor;\n    } else if (customElementsV1) {\n      window.customElements.define(uniqueName, Ctor, { extends: Ctor.extends });\n    } else {\n      throw new Error('Skate requires native custom element support or a polyfill.');\n    }\n\n    return Ctor;\n  }\n\n  function get$1(elem) {\n    var props = elem.constructor.props;\n    var state = {};\n    for (var key in props) {\n      var val = elem[key];\n      if (typeof val !== 'undefined') {\n        state[key] = val;\n      }\n    }\n    return state;\n  }\n\n  function set$1(elem, newState) {\n    assign$1(elem, newState);\n    if (elem.constructor.render) {\n      elem.constructor[$renderer](elem);\n    }\n  }\n\n  function state (elem, newState) {\n    return typeof newState === 'undefined' ? get$1(elem) : set$1(elem, newState);\n  }\n\n  function getValue(elem) {\n    var type = elem.type;\n    if (type === 'checkbox' || type === 'radio') {\n      return elem.checked ? elem.value || true : false;\n    }\n    return elem.value;\n  }\n\n  function link (elem, target) {\n    return function (e) {\n      var value = getValue(e.target);\n      var localTarget = target || e.target.name || 'value';\n\n      if (localTarget.indexOf('.') > -1) {\n        var parts = localTarget.split('.');\n        var firstPart = parts[0];\n        var propName = parts.pop();\n        var obj = parts.reduce(function (prev, curr) {\n          return prev && prev[curr];\n        }, elem);\n\n        obj[propName || e.target.name] = value;\n        state(elem, defineProperty({}, firstPart, elem[firstPart]));\n      } else {\n        state(elem, defineProperty({}, localTarget, value));\n      }\n    };\n  }\n\n  function ready (elem, done) {\n    var info = data(elem);\n    if (elem.hasAttribute(elem.constructor.definedAttribute)) {\n      done(elem);\n    } else if (info.readyCallbacks) {\n      info.readyCallbacks.push(done);\n    } else {\n      info.readyCallbacks = [done];\n    }\n  }\n\n  exports.Component = Component;\n  exports.define = define;\n  exports.emit = emit;\n  exports.link = link;\n  exports.prop = prop;\n  exports.ready = ready;\n  exports.state = state;\n  exports.symbols = symbols$1;\n  exports.vdom = vdom;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceMappingURL=index.js.map\n\n\n/** WEBPACK FOOTER **\n ** ../skatejs/dist/index.js\n **/","\n/**\n * @license\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n'use strict';\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * A cached reference to the create function.\n */\nvar create = Object.create;\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nvar has = function (map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nvar createMap = function () {\n  return create(null);\n};\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {?Object<string, !Element>}\n   */\n  this.keyMap = null;\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nvar initData = function (node, nodeName, key) {\n  var data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {Node} node The node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nvar getData = function (node) {\n  var data = node['__incrementalDOMData'];\n\n  if (!data) {\n    var nodeName = node.nodeName.toLowerCase();\n    var key = null;\n\n    if (node instanceof Element) {\n      key = node.getAttribute('key');\n    }\n\n    data = initData(node, nodeName, key);\n  }\n\n  return data;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar symbols = {\n  default: '__default',\n\n  placeholder: '__placeholder'\n};\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nvar getNamespace = function (name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nvar applyAttr = function (el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    var attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nvar applyProp = function (el, name, value) {\n  el[name] = value;\n};\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nvar applyStyle = function (el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    var elStyle = el.style;\n    var obj = /** @type {!Object<string,string>} */style;\n\n    for (var prop in obj) {\n      if (has(obj, prop)) {\n        elStyle[prop] = obj[prop];\n      }\n    }\n  }\n};\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nvar applyAttributeTyped = function (el, name, value) {\n  var type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n  }\n};\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nvar updateAttribute = function (el, name, value) {\n  var data = getData(el);\n  var attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  var mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nvar attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes[symbols.placeholder] = function () {};\n\nattributes['style'] = applyStyle;\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nvar getNamespaceForTag = function (tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element.\n * @return {!Element}\n */\nvar createElement = function (doc, parent, tag, key, statics) {\n  var namespace = getNamespaceForTag(tag, parent);\n  var el = undefined;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  if (statics) {\n    for (var i = 0; i < statics.length; i += 2) {\n      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n    }\n  }\n\n  return el;\n};\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nvar createText = function (doc) {\n  var node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n/**\n * Creates a mapping that can be used to look up children using a key.\n * @param {?Node} el\n * @return {!Object<string, !Element>} A mapping of keys to the children of the\n *     Element.\n */\nvar createKeyMap = function (el) {\n  var map = createMap();\n  var child = el.firstElementChild;\n\n  while (child) {\n    var key = getData(child).key;\n\n    if (key) {\n      map[key] = child;\n    }\n\n    child = child.nextElementSibling;\n  }\n\n  return map;\n};\n\n/**\n * Retrieves the mapping of key to child node for a given Element, creating it\n * if necessary.\n * @param {?Node} el\n * @return {!Object<string, !Node>} A mapping of keys to child Elements\n */\nvar getKeyMap = function (el) {\n  var data = getData(el);\n\n  if (!data.keyMap) {\n    data.keyMap = createKeyMap(el);\n  }\n\n  return data.keyMap;\n};\n\n/**\n * Retrieves a child from the parent with the given key.\n * @param {?Node} parent\n * @param {?string=} key\n * @return {?Node} The child corresponding to the key.\n */\nvar getChild = function (parent, key) {\n  return key ? getKeyMap(parent)[key] : null;\n};\n\n/**\n * Registers an element as being a child. The parent will keep track of the\n * child using the key. The child can be retrieved using the same key using\n * getKeyMap. The provided key should be unique within the parent Element.\n * @param {?Node} parent The parent of child.\n * @param {string} key A key to identify the child with.\n * @param {!Node} child The child to register.\n */\nvar registerChild = function (parent, key, child) {\n  getKeyMap(parent)[key] = child;\n};\n\n/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nvar notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function (node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function (node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function () {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n/**\n* Makes sure that keyed Element matches the tag name provided.\n* @param {!string} nodeName The nodeName of the node that is being matched.\n* @param {string=} tag The tag name of the Element.\n* @param {?string=} key The key of the Element.\n*/\nvar assertKeyedTagMatches = function (nodeName, tag, key) {\n  if (nodeName !== tag) {\n    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n  }\n};\n\n/** @type {?Context} */\nvar context = null;\n\n/** @type {?Node} */\nvar currentNode = null;\n\n/** @type {?Node} */\nvar currentParent = null;\n\n/** @type {?Element|?DocumentFragment} */\nvar root = null;\n\n/** @type {?Document} */\nvar doc = null;\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=)} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=)}\n * @template T\n */\nvar patchFactory = function (run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @template T\n   */\n  var f = function (node, fn, data) {\n    var prevContext = context;\n    var prevRoot = root;\n    var prevDoc = doc;\n    var prevCurrentNode = currentNode;\n    var prevCurrentParent = currentParent;\n    var previousInAttributes = false;\n    var previousInSkip = false;\n\n    context = new Context();\n    root = node;\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if ('production' !== 'production') {}\n\n    run(node, fn, data);\n\n    if ('production' !== 'production') {}\n\n    context.notifyChanges();\n\n    context = prevContext;\n    root = prevRoot;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n  };\n  return f;\n};\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchInner = patchFactory(function (node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @template T\n */\nvar patchOuter = patchFactory(function (node, fn, data) {\n  currentNode = /** @type {!Element} */{ nextSibling: node };\n\n  fn(data);\n\n  if ('production' !== 'production') {}\n});\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nvar matches = function (nodeName, key) {\n  var data = getData(currentNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n * @param {?Array<*>=} statics For an Element, this should be an array of\n *     name-value pairs.\n */\nvar alignWithDOM = function (nodeName, key, statics) {\n  if (currentNode && matches(nodeName, key)) {\n    return;\n  }\n\n  var node = undefined;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    node = getChild(currentParent, key);\n    if (node && 'production' !== 'production') {\n      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key, statics);\n    }\n\n    if (key) {\n      registerChild(currentParent, key, node);\n    }\n\n    context.markCreated(node);\n  }\n\n  // If the node has a key, remove it from the DOM to prevent a large number\n  // of re-orders in the case that it moved far or was completely removed.\n  // Since we hold on to a reference through the keyMap, we can always add it\n  // back.\n  if (currentNode && getData(currentNode).key) {\n    currentParent.replaceChild(node, currentNode);\n    getData(currentParent).keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nvar clearUnvisitedDOM = function () {\n  var node = currentParent;\n  var data = getData(node);\n  var keyMap = data.keyMap;\n  var keyMapValid = data.keyMapValid;\n  var child = node.lastChild;\n  var key = undefined;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  if (data.attrs[symbols.placeholder] && node !== root) {\n    if ('production' !== 'production') {}\n    return;\n  }\n\n  while (child !== currentNode) {\n    node.removeChild(child);\n    context.markDeleted( /** @type {!Node}*/child);\n\n    key = getData(child).key;\n    if (key) {\n      delete keyMap[key];\n    }\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n/**\n * Changes to the first child of the current node.\n */\nvar enterNode = function () {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n/**\n * Changes to the next sibling of the current node.\n */\nvar nextNode = function () {\n  if (currentNode) {\n    currentNode = currentNode.nextSibling;\n  } else {\n    currentNode = currentParent.firstChild;\n  }\n};\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nvar exitNode = function () {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @return {!Element} The corresponding Element.\n */\nvar coreElementOpen = function (tag, key, statics) {\n  nextNode();\n  alignWithDOM(tag, key, statics);\n  enterNode();\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nvar coreElementClose = function () {\n  if ('production' !== 'production') {}\n\n  exitNode();\n  return (/** @type {!Element} */currentNode\n  );\n};\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nvar coreText = function () {\n  nextNode();\n  alignWithDOM('#text', null, null);\n  return (/** @type {!Text} */currentNode\n  );\n};\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nvar currentElement = function () {\n  if ('production' !== 'production') {}\n  return (/** @type {!Element} */currentParent\n  );\n};\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nvar skip = function () {\n  if ('production' !== 'production') {}\n  currentNode = currentParent.lastChild;\n};\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nvar ATTRIBUTES_OFFSET = 3;\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nvar argsBuilder = [];\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpen = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementOpen(tag, key, statics);\n  var data = getData(node);\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  var attrsArr = data.attrsArr;\n  var newAttrs = data.newAttrs;\n  var attrsChanged = false;\n  var i = ATTRIBUTES_OFFSET;\n  var j = 0;\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    if (attrsArr[j] !== arguments[i]) {\n      attrsChanged = true;\n      break;\n    }\n  }\n\n  for (; i < arguments.length; i += 1, j += 1) {\n    attrsArr[j] = arguments[i];\n  }\n\n  if (j < attrsArr.length) {\n    attrsChanged = true;\n    attrsArr.length = j;\n  }\n\n  /*\n   * Actually perform the attribute update.\n   */\n  if (attrsChanged) {\n    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n      newAttrs[arguments[i]] = arguments[i + 1];\n    }\n\n    for (var _attr in newAttrs) {\n      updateAttribute(node, _attr, newAttrs[_attr]);\n      newAttrs[_attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nvar elementOpenStart = function (tag, key, statics) {\n  if ('production' !== 'production') {}\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nvar attr = function (name, value) {\n  if ('production' !== 'production') {}\n\n  argsBuilder.push(name, value);\n};\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nvar elementOpenEnd = function () {\n  if ('production' !== 'production') {}\n\n  var node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nvar elementClose = function (tag) {\n  if ('production' !== 'production') {}\n\n  var node = coreElementClose();\n\n  if ('production' !== 'production') {}\n\n  return node;\n};\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementVoid = function (tag, key, statics, const_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Element at the current location in the document that is a\n * placeholder element. Children of this Element can be manually managed and\n * will not be cleared by the library.\n *\n * A key must be specified to make sure that this node is correctly preserved\n * across all conditionals.\n *\n * @param {string} tag The element's tag.\n * @param {string} key The key used to identify this element.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nvar elementPlaceholder = function (tag, key, statics, const_args) {\n  if ('production' !== 'production') {}\n\n  elementOpen.apply(null, arguments);\n  skip();\n  return elementClose(tag);\n};\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} const_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nvar text = function (value, const_args) {\n  if ('production' !== 'production') {}\n\n  var node = coreText();\n  var data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */value;\n\n    var formatted = value;\n    for (var i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      var fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\nexports.patch = patchInner;\nexports.patchInner = patchInner;\nexports.patchOuter = patchOuter;\nexports.currentElement = currentElement;\nexports.skip = skip;\nexports.elementVoid = elementVoid;\nexports.elementOpenStart = elementOpenStart;\nexports.elementOpenEnd = elementOpenEnd;\nexports.elementOpen = elementOpen;\nexports.elementClose = elementClose;\nexports.elementPlaceholder = elementPlaceholder;\nexports.text = text;\nexports.attr = attr;\nexports.symbols = symbols;\nexports.attributes = attributes;\nexports.applyAttr = applyAttr;\nexports.applyProp = applyProp;\nexports.notifications = notifications;\n\n//# sourceMappingURL=incremental-dom-cjs.js.map\n\n\n/** WEBPACK FOOTER **\n ** ../skatejs/~/incremental-dom/dist/incremental-dom-cjs.js\n **/","'use strict';\n\n// REGEX //\n\nvar re = '';\n\n// Use a native function as a template...\nre += Function.prototype.toString.call( Function );\n\n// Escape special RegExp characters...\nre = re.replace( /([.*+?^=!:$(){}|[\\]\\/\\\\])/g, '\\\\$1' );\n\n// Replace any mentions of `Function` to make template generic.\n// Replace `for ...` and additional info provided in other environments, such as Rhino (see lodash).\nre = re.replace( /Function|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?' );\n\n// Bracket the regex:\nre = '^' + re + '$';\n\n\n// EXPORTS //\n\nmodule.exports = new RegExp( re );\n\n\n\n/** WEBPACK FOOTER **\n ** ../skatejs/~/regex-native-function/lib/index.js\n **/","import { vdom } from 'skatejs';\nimport css from './index.css';\n\nexport default (props, chren) => (\n  <div class={css.locals.body}>\n    <style>{css.toString()}</style>\n    {chren()}\n  </div>\n);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/body/index.js\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".JotV9DC7cFGUX61mmETT1{background-color:#fefefe;color:#333;font-size:16px;padding:60px 20px 10px}\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"body\": \"JotV9DC7cFGUX61mmETT1\",\n\t\"body\": \"JotV9DC7cFGUX61mmETT1\"\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/body/index.css\n ** module id = 6\n ** module chunks = 0 1 2\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/css-loader/lib/css-base.js\n **/","import { vdom } from 'skatejs';\nimport css from './index.css';\n\nconst List = props => (\n  <ul class={css.locals.list}>\n    {Object.keys(props.items).map(item =>\n      <li class={css.locals.item}>\n        <a class={css.locals.link} href={props.items[item]}>{item}</a>\n      </li>\n    )}\n  </ul>\n);\n\nexport default () => (\n  <div class={css.locals.footer}>\n    <style>{css.toString()}</style>\n    <List items={{ Docs: 'docs/' }}></List>\n  </div>\n);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/footer/index.js\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"._2pOZ9JVRdOcst-M-V8CIG-{background-color:#333;color:#eee;font-size:12px;padding:10px 20px}.HAjb6JuBA0hiG3VMO17sO{padding:0}.ZXtuSy6oo7L79SnJvwsHt{color:#eee;text-decoration:none}._3k8ml8FyWDLKqwlHkSBmab{padding:0 0 0 20px}\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"footer\": \"_2pOZ9JVRdOcst-M-V8CIG-\",\n\t\"footer\": \"_2pOZ9JVRdOcst-M-V8CIG-\",\n\t\"item\": \"HAjb6JuBA0hiG3VMO17sO\",\n\t\"item\": \"HAjb6JuBA0hiG3VMO17sO\",\n\t\"link\": \"ZXtuSy6oo7L79SnJvwsHt\",\n\t\"link\": \"ZXtuSy6oo7L79SnJvwsHt\",\n\t\"list\": \"_3k8ml8FyWDLKqwlHkSBmab\",\n\t\"list\": \"_3k8ml8FyWDLKqwlHkSBmab\"\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/footer/index.css\n ** module id = 9\n ** module chunks = 0 1 2\n **/","import { vdom } from 'skatejs';\nimport css from './index.css';\nimport logo from './logo.png';\n\nconst Item = (props, chren) => (\n  <li class={css.locals.item}>\n    <a class={css.locals.link} href={props.href}>{chren()}</a>\n  </li>\n);\n\nexport default props => (\n  <div>\n    <style>{css.toString()}</style>\n    <div class={`${css.locals.header} ${props.scrolled}`}>\n      <h1 class={css.locals.title}>\n        <img alt={props.title} src={logo} width=\"30\" />\n      </h1>\n      <ul class={css.locals.list}>\n        <Item href=\"\">Docs</Item>\n        <Item href=\"https://github.com/skatejs/skatejs\">Github</Item>\n        <Item href=\"\">Community</Item>\n      </ul>\n    </div>\n  </div>\n);\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/header/index.js\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"._2Hd5KzDR5h1JLZaLAhkdnL{background-color:#fefefe;color:#333;position:fixed;transition:box-shadow .3s ease;width:100%}._10mxIH_-5Sk7Kz5KsJMq0H{box-shadow:0 0 15px 0 #333}._3EU-FaAppzWRdOf0yzUQbO{list-style:none}._3EU-FaAppzWRdOf0yzUQbO,._3h8r-c6pyf3k8OkYptB6eQ{display:inline-block;margin:0;padding:0}._1O98iTVLbgr87bKcZ1xtCv{display:inline-block;margin:0 20px 0 10px;padding:0;position:relative;left:14px;top:8px}._3gAAJyILxgLXLUDHVCLw1K{color:#333;display:inline-block;font-size:18px;margin:0;padding:20px;text-decoration:none;transition:background-color .3s ease}._3gAAJyILxgLXLUDHVCLw1K:hover{background-color:#eee}\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"header\": \"_2Hd5KzDR5h1JLZaLAhkdnL\",\n\t\"header\": \"_2Hd5KzDR5h1JLZaLAhkdnL\",\n\t\"header-scrolled\": \"_10mxIH_-5Sk7Kz5KsJMq0H\",\n\t\"headerScrolled\": \"_10mxIH_-5Sk7Kz5KsJMq0H\",\n\t\"list\": \"_3EU-FaAppzWRdOf0yzUQbO\",\n\t\"list\": \"_3EU-FaAppzWRdOf0yzUQbO\",\n\t\"item\": \"_3h8r-c6pyf3k8OkYptB6eQ\",\n\t\"item\": \"_3h8r-c6pyf3k8OkYptB6eQ\",\n\t\"title\": \"_1O98iTVLbgr87bKcZ1xtCv\",\n\t\"title\": \"_1O98iTVLbgr87bKcZ1xtCv\",\n\t\"link\": \"_3gAAJyILxgLXLUDHVCLw1K\",\n\t\"link\": \"_3gAAJyILxgLXLUDHVCLw1K\"\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/header/index.css\n ** module id = 11\n ** module chunks = 0 1 2\n **/","module.exports = __webpack_public_path__ + \"dist/cdcf8f64994df2f0ca865f88e17aaa59.png\";\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/header/logo.png\n ** module id = 12\n ** module chunks = 0 1 2\n **/","export default function (title) {\n  document.title = title;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_/title.js\n **/","exports = module.exports = require(\"./../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"html{font-family:Helvetica;font-size:14px}body{margin:0}a{color:#333}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.css\n ** module id = 14\n ** module chunks = 0 1 2\n **/"],"sourceRoot":""}