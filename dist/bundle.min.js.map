{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///dist/bundle.min.js","webpack:///webpack/bootstrap 0c72adc41a45b4a66a8b?b827","webpack:///./src/index.js?9552","webpack:///./src/app/index.js?7afc","webpack:///./~/skatejs/dist/index.js?6821","webpack:///./~/process/browser.js?82e4","webpack:///./src/header/index.js?1c6b","webpack:///./src/header/index.css?4191","webpack:///./~/css-loader/lib/css-base.js?da04","webpack:///./src/_/elements.js?ba38","webpack:///./src/_/title.js?071c","webpack:///./src/index.css?aff6"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","App","undefined","_index","_index2","_index3","_index4","document","head","innerHTML","_skatejs","_header","_header2","_title","_title2","render","vdom","element","title","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","process","_typeof","Symbol","iterator","constructor","global","apply","__commonjs","fn","empty","val","create","def","_len","arguments","length","args","Array","_key","unshift","assign","NodeData","nodeName","key","attrs","createMap","attrsArr","newAttrs","keyMap","keyMapValid","text","Context","created","notifications","nodesCreated","deleted","nodesDeleted","applyEvent","elem","ename","name","events","__events","eFunc","removeEventListener","addEventListener","tname","chren","shouldBeContentTag","shadowDomV1","shadowDomV0","babelHelpers","select","slot","elementOpenStart","statics","a","attr","elementOpenEnd","elementOpen","skip","chrenType","elementClose","data","namespace","__SKATE_DATA","getOwnPropertyDescriptors","getOwnPropertyNames","reduce","prev","curr","getOwnPropertyDescriptor","matches$1","selector","hasNativeMatchesSelectorDetattachedBug","clone","cloneNode","createElement","appendChild","nativeMatchesSelector","readonly","prop","configurable","get","parseEvent","e","indexOfSpace","indexOf","hasSpace","substring","makeDelegateHandler","handler","parsed","current","path","target","parentNode","makeNormalHandler","bindEvent","event","capture","events$1","opts","createRenderer","Ctor","shadowRoot","sr","attachShadow","mode","createShadowRoot","patch$1","dashCase","str","split","one","two","idx","dash","toLowerCase","debounce","called","_this","raf","createCustomEvent","CustomEvent","createEvent","initCustomEvent","bubbles","cancelable","detail","emit","disabled","dispatchEvent","getDefaultValue","getInitialValue","initial","createNativePropertyDefinition","enumerable","propData","attributeName","attribute","initialValue","shouldSyncAttribute","hasAttribute","deserialize","getAttribute","set","internalValue","coerce","shouldUpdate","newValue","oldValue","shouldRemoveAttribute","propertyHasChanged","canceled","String","changeData","deb","rendererDebounced","renderer","settingAttribute","serializedValue","serialize","syncingAttribute","removeAttribute","setAttribute","initProps","ensurePropertyFunctions","props","names","keys","descriptors","descriptorName","ensurePropertyDefinitions","createConstructor","name$$","Component","extend","formatLinkedAttributes","observedAttributes","forEach","linkedAttr","push","createInitProps","customElementsV0","registerElement","customElementsV1","window","customElements","extends","Error","state","newState","getValue","type","checked","link","localTarget","parts","firstPart","propName","pop","ready","done","info","definedAttribute","readyCallbacks","classCallCheck","instance","Constructor","TypeError","createClass","defineProperties","i","descriptor","writable","protoProps","staticProps","prototype","inherits","subClass","superClass","setPrototypeOf","__proto__","possibleConstructorReturn","self","ReferenceError","index","toObject","shouldUseNative","test1","test2","fromCharCode","order2","map","n","join","test3","letter","hasOwnProperty","propIsEnumerable","propertyIsEnumerable","source","from","symbols","to","s","getOwnPropertySymbols","alwaysUndefinedIfEmptyOrNumber","Number","alwaysUndefinedIfEmptyOrString","array","isArray","JSON","parse","stringify","boolean","number","string","freeze","create$1","has","property","initData","node","getData","Element","symbols$2","placeholder","getNamespace","lastIndexOf","applyAttr","el","attrNS","setAttributeNS","applyProp$1","applyStyle","style","cssText","elStyle","applyAttributeTyped","updateAttribute","mutator","attributes$1","getNamespaceForTag","tag","parent","namespaceURI","doc","createElementNS","createText","createTextNode","createKeyMap","child","firstElementChild","nextElementSibling","getKeyMap","getChild","registerChild","markCreated","markDeleted","notifyChanges","inAttributes","inSkip","assertInPatch","context","assertKeyedTagMatches","assertNoUnclosedTags","openElement","currentElement","openTags","assertNotInAttributes","functionName","assertNotInSkip","assertInAttributes","assertVirtualAttributesClosed","assertPlaceholderKeySpecified","assertCloseMatchesOpenTag","assertNoChildrenDeclaredYet","previousNode","assertPatchElementNotEmpty","currentNode","assertPatchElementNoExtras","setInAttributes","previous","setInSkip","currentParent","runPatch","prevContext","prevRoot","prevDoc","prevCurrentNode","prevCurrentParent","previousInAttributes","previousInSkip","ownerDocument","env","NODE_ENV","patch","enterNode","exitNode","patchOuter","nextSibling","matches","alignWithDOM","replaceChild","insertBefore","clearUnvisitedDOM","lastChild","console","warn","removeChild","nextNode","firstChild","coreElementOpen","coreElementClose","coreText","skip$1","ATTRIBUTES_OFFSET","argsBuilder","elementOpen$1","const_args","attrsChanged","j","_attr","elementOpenStart$1","attr$1","elementOpenEnd$1","elementClose$1","elementVoid","elementPlaceholder","text$1","formatted","IncrementalDOM","patchInner","attributes","applyProp","div","symbols$1","applyDefault","className","_HTMLElement","getPrototypeOf","createdCallback","cb","attached","detached","_constructor","attributeChanged","propertyName","propOpts","_this2","elemData","events$$","created$$","props$$","renderedAttribute","renderer$$","attributeChangedCallback","connectedCallback","disconnectedCallback","definition","Base","_Base","prot","HTMLElement","elProto","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","requestAnimationFrame","setTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","cachedSetTimeout","len","run","cachedClearTimeout","Item","fun","noop","clearTimeout","nextTick","browser","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","binding","cwd","chdir","dir","umask","item","href","li","class","_elements","_elements2","h1","ul","toString","list","result","mediaQuery","alreadyImportedModules","specials","filter","replace","bind"],"mappings":"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","file":"dist/bundle.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"skatejsGithubIo\"] = factory();\n\telse\n\t\troot[\"skatejsGithubIo\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"skatejsGithubIo\"] = factory();\n\telse\n\t\troot[\"skatejsGithubIo\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.App = undefined;\n\t\n\tvar _index = __webpack_require__(1);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tvar _index3 = __webpack_require__(9);\n\t\n\tvar _index4 = _interopRequireDefault(_index3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tdocument.head.innerHTML += '<style>' + _index4.default + '</style>';\n\texports.App = _index2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _skatejs = __webpack_require__(2);\n\t\n\tvar _header = __webpack_require__(4);\n\t\n\tvar _header2 = _interopRequireDefault(_header);\n\t\n\tvar _title = __webpack_require__(8);\n\t\n\tvar _title2 = _interopRequireDefault(_title);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = (0, _skatejs.define)('sk-app', {\n\t  render: function render() {\n\t    (0, _title2.default)('SkateJS - functional web components');\n\t    _skatejs.vdom.element(_header2.default, { title: 'SkateJS' });\n\t  }\n\t});\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\t\n\t(function (global, factory) {\n\t\t( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : factory(global.skate = global.skate || {});\n\t})(undefined, function (exports) {\n\t\n\t\tvar babelHelpers = {};\n\t\tbabelHelpers.typeof = typeof Symbol === \"function\" && _typeof(Symbol.iterator) === \"symbol\" ? function (obj) {\n\t\t\treturn typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n\t\t} : function (obj) {\n\t\t\treturn obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj === 'undefined' ? 'undefined' : _typeof(obj);\n\t\t};\n\t\n\t\tbabelHelpers.classCallCheck = function (instance, Constructor) {\n\t\t\tif (!(instance instanceof Constructor)) {\n\t\t\t\tthrow new TypeError(\"Cannot call a class as a function\");\n\t\t\t}\n\t\t};\n\t\n\t\tbabelHelpers.createClass = function () {\n\t\t\tfunction defineProperties(target, props) {\n\t\t\t\tfor (var i = 0; i < props.length; i++) {\n\t\t\t\t\tvar descriptor = props[i];\n\t\t\t\t\tdescriptor.enumerable = descriptor.enumerable || false;\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t\tif (\"value\" in descriptor) descriptor.writable = true;\n\t\t\t\t\tObject.defineProperty(target, descriptor.key, descriptor);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn function (Constructor, protoProps, staticProps) {\n\t\t\t\tif (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t\t\t\tif (staticProps) defineProperties(Constructor, staticProps);\n\t\t\t\treturn Constructor;\n\t\t\t};\n\t\t}();\n\t\n\t\tbabelHelpers.defineProperty = function (obj, key, value) {\n\t\t\tif (key in obj) {\n\t\t\t\tObject.defineProperty(obj, key, {\n\t\t\t\t\tvalue: value,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tobj[key] = value;\n\t\t\t}\n\t\n\t\t\treturn obj;\n\t\t};\n\t\n\t\tbabelHelpers.inherits = function (subClass, superClass) {\n\t\t\tif (typeof superClass !== \"function\" && superClass !== null) {\n\t\t\t\tthrow new TypeError(\"Super expression must either be null or a function, not \" + (typeof superClass === 'undefined' ? 'undefined' : _typeof(superClass)));\n\t\t\t}\n\t\n\t\t\tsubClass.prototype = Object.create(superClass && superClass.prototype, {\n\t\t\t\tconstructor: {\n\t\t\t\t\tvalue: subClass,\n\t\t\t\t\tenumerable: false,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t\t};\n\t\n\t\tbabelHelpers.possibleConstructorReturn = function (self, call) {\n\t\t\tif (!self) {\n\t\t\t\tthrow new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t\t\t}\n\t\n\t\t\treturn call && ((typeof call === 'undefined' ? 'undefined' : _typeof(call)) === \"object\" || typeof call === \"function\") ? call : self;\n\t\t};\n\t\n\t\tbabelHelpers;\n\t\n\t\tfunction __commonjs(fn, module) {\n\t\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t\t}\n\t\n\t\tvar index = __commonjs(function (module) {\n\t\t\t'use strict';\n\t\t\t/* eslint-disable no-unused-vars */\n\t\n\t\t\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\t\tvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\t\n\t\t\tfunction toObject(val) {\n\t\t\t\tif (val === null || val === undefined) {\n\t\t\t\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t\t\t\t}\n\t\n\t\t\t\treturn Object(val);\n\t\t\t}\n\t\n\t\t\tfunction shouldUseNative() {\n\t\t\t\ttry {\n\t\t\t\t\tif (!Object.assign) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Detect buggy property enumeration order in older V8 versions.\n\t\n\t\t\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\t\t\t\tvar test1 = new String('abc'); // eslint-disable-line\n\t\t\t\t\ttest1[5] = 'de';\n\t\t\t\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\t\t\t\tvar test2 = {};\n\t\t\t\t\tfor (var i = 0; i < 10; i++) {\n\t\t\t\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t\t\t\t}\n\t\t\t\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\t\t\t\treturn test2[n];\n\t\t\t\t\t});\n\t\t\t\t\tif (order2.join('') !== '0123456789') {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\t\t\t\tvar test3 = {};\n\t\t\t\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\t\t\t\ttest3[letter] = letter;\n\t\t\t\t\t});\n\t\t\t\t\tif (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn true;\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\t\t\t\tvar from;\n\t\t\t\tvar to = toObject(target);\n\t\t\t\tvar symbols;\n\t\n\t\t\t\tfor (var s = 1; s < arguments.length; s++) {\n\t\t\t\t\tfrom = Object(arguments[s]);\n\t\n\t\t\t\t\tfor (var key in from) {\n\t\t\t\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\t\t\t\tto[key] = from[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (Object.getOwnPropertySymbols) {\n\t\t\t\t\t\tsymbols = Object.getOwnPropertySymbols(from);\n\t\t\t\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\treturn to;\n\t\t\t};\n\t\t});\n\t\n\t\tvar assign = index && (typeof index === 'undefined' ? 'undefined' : _typeof(index)) === 'object' && 'default' in index ? index['default'] : index;\n\t\n\t\tfunction empty(val) {\n\t\t\treturn typeof val === 'undefined' || val === null;\n\t\t}\n\t\n\t\tvar alwaysUndefinedIfEmptyOrNumber = function alwaysUndefinedIfEmptyOrNumber(val) {\n\t\t\treturn empty(val) ? undefined : Number(val);\n\t\t};\n\t\tvar alwaysUndefinedIfEmptyOrString = function alwaysUndefinedIfEmptyOrString(val) {\n\t\t\treturn empty(val) ? undefined : String(val);\n\t\t};\n\t\n\t\tfunction create(def) {\n\t\t\treturn function () {\n\t\t\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\targs[_key] = arguments[_key];\n\t\t\t\t}\n\t\n\t\t\t\targs.unshift({}, def);\n\t\t\t\treturn assign.apply(null, args);\n\t\t\t};\n\t\t}\n\t\n\t\tvar array = create({\n\t\t\tcoerce: function coerce(val) {\n\t\t\t\treturn Array.isArray(val) ? val : [val];\n\t\t\t},\n\t\t\tdefault: function _default() {\n\t\t\t\treturn [];\n\t\t\t},\n\t\t\tdeserialize: JSON.parse,\n\t\t\tserialize: JSON.stringify\n\t\t});\n\t\n\t\tvar boolean = create({\n\t\t\tcoerce: function coerce(value) {\n\t\t\t\treturn !!value;\n\t\t\t},\n\t\t\tdefault: false,\n\t\t\tdeserialize: function deserialize(value) {\n\t\t\t\treturn !(value === null);\n\t\t\t},\n\t\t\tserialize: function serialize(value) {\n\t\t\t\treturn value ? '' : undefined;\n\t\t\t}\n\t\t});\n\t\n\t\tvar number = create({\n\t\t\tcoerce: alwaysUndefinedIfEmptyOrNumber,\n\t\t\tdeserialize: alwaysUndefinedIfEmptyOrNumber,\n\t\t\tserialize: alwaysUndefinedIfEmptyOrNumber\n\t\t});\n\t\n\t\tvar string = create({\n\t\t\tcoerce: alwaysUndefinedIfEmptyOrString,\n\t\t\tdeserialize: alwaysUndefinedIfEmptyOrString,\n\t\t\tserialize: alwaysUndefinedIfEmptyOrString\n\t\t});\n\t\n\t\tvar prop = Object.freeze({\n\t\t\tcreate: create,\n\t\t\tarray: array,\n\t\t\tboolean: boolean,\n\t\t\tnumber: number,\n\t\t\tstring: string\n\t\t});\n\t\n\t\tvar created = '____created';\n\t\tvar events = '____events';\n\t\tvar name = '____name';\n\t\tvar props = '____props';\n\t\tvar renderer = '____renderer';\n\t\tvar rendererDebounced = '____rendererDebounced';\n\t\tvar shadowRoot = '____shadowRoot';\n\t\n\t\tvar symbols = Object.freeze({\n\t\t\tcreated: created,\n\t\t\tevents: events,\n\t\t\tname: name,\n\t\t\tprops: props,\n\t\t\trenderer: renderer,\n\t\t\trendererDebounced: rendererDebounced,\n\t\t\tshadowRoot: shadowRoot\n\t\t});\n\t\n\t\t/**\n\t  * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t  *\n\t  * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t  * you may not use this file except in compliance with the License.\n\t  * You may obtain a copy of the License at\n\t  *\n\t  *      http://www.apache.org/licenses/LICENSE-2.0\n\t  *\n\t  * Unless required by applicable law or agreed to in writing, software\n\t  * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t  * See the License for the specific language governing permissions and\n\t  * limitations under the License.\n\t  */\n\t\n\t\t/**\n\t  * A cached reference to the hasOwnProperty function.\n\t  */\n\t\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t\t/**\n\t  * A cached reference to the create function.\n\t  */\n\t\tvar create$1 = Object.create;\n\t\n\t\t/**\n\t  * Used to prevent property collisions between our \"map\" and its prototype.\n\t  * @param {!Object<string, *>} map The map to check.\n\t  * @param {string} property The property to check.\n\t  * @return {boolean} Whether map has property.\n\t  */\n\t\tvar has = function has(map, property) {\n\t\t\treturn hasOwnProperty.call(map, property);\n\t\t};\n\t\n\t\t/**\n\t  * Creates an map object without a prototype.\n\t  * @return {!Object}\n\t  */\n\t\tvar createMap = function createMap() {\n\t\t\treturn create$1(null);\n\t\t};\n\t\n\t\t/**\n\t  * Keeps track of information needed to perform diffs for a given DOM node.\n\t  * @param {!string} nodeName\n\t  * @param {?string=} key\n\t  * @constructor\n\t  */\n\t\tfunction NodeData(nodeName, key) {\n\t\t\t/**\n\t   * The attributes and their values.\n\t   * @const {!Object<string, *>}\n\t   */\n\t\t\tthis.attrs = createMap();\n\t\n\t\t\t/**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t\t\tthis.attrsArr = [];\n\t\n\t\t\t/**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t\t\tthis.newAttrs = createMap();\n\t\n\t\t\t/**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t\t\tthis.key = key;\n\t\n\t\t\t/**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, !Element>}\n\t   */\n\t\t\tthis.keyMap = null;\n\t\n\t\t\t/**\n\t   * Whether or not the keyMap is currently valid.\n\t   * {boolean}\n\t   */\n\t\t\tthis.keyMapValid = true;\n\t\n\t\t\t/**\n\t   * The node name for this node.\n\t   * @const {string}\n\t   */\n\t\t\tthis.nodeName = nodeName;\n\t\n\t\t\t/**\n\t   * @type {?string}\n\t   */\n\t\t\tthis.text = null;\n\t\t}\n\t\n\t\t/**\n\t  * Initializes a NodeData object for a Node.\n\t  *\n\t  * @param {Node} node The node to initialize data for.\n\t  * @param {string} nodeName The node name of node.\n\t  * @param {?string=} key The key that identifies the node.\n\t  * @return {!NodeData} The newly initialized data object\n\t  */\n\t\tvar initData = function initData(node, nodeName, key) {\n\t\t\tvar data = new NodeData(nodeName, key);\n\t\t\tnode['__incrementalDOMData'] = data;\n\t\t\treturn data;\n\t\t};\n\t\n\t\t/**\n\t  * Retrieves the NodeData object for a Node, creating it if necessary.\n\t  *\n\t  * @param {Node} node The node to retrieve the data for.\n\t  * @return {!NodeData} The NodeData for this Node.\n\t  */\n\t\tvar getData = function getData(node) {\n\t\t\tvar data = node['__incrementalDOMData'];\n\t\n\t\t\tif (!data) {\n\t\t\t\tvar nodeName = node.nodeName.toLowerCase();\n\t\t\t\tvar key = null;\n\t\n\t\t\t\tif (node instanceof Element) {\n\t\t\t\t\tkey = node.getAttribute('key');\n\t\t\t\t}\n\t\n\t\t\t\tdata = initData(node, nodeName, key);\n\t\t\t}\n\t\n\t\t\treturn data;\n\t\t};\n\t\n\t\t/**\n\t  * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t  *\n\t  * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t  * you may not use this file except in compliance with the License.\n\t  * You may obtain a copy of the License at\n\t  *\n\t  *      http://www.apache.org/licenses/LICENSE-2.0\n\t  *\n\t  * Unless required by applicable law or agreed to in writing, software\n\t  * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t  * See the License for the specific language governing permissions and\n\t  * limitations under the License.\n\t  */\n\t\n\t\t/** @const */\n\t\tvar symbols$2 = {\n\t\t\tdefault: '__default',\n\t\n\t\t\tplaceholder: '__placeholder'\n\t\t};\n\t\n\t\t/**\n\t  * @param {string} name\n\t  * @return {string|undefined} The namespace to use for the attribute.\n\t  */\n\t\tvar getNamespace = function getNamespace(name) {\n\t\t\tif (name.lastIndexOf('xml:', 0) === 0) {\n\t\t\t\treturn 'http://www.w3.org/XML/1998/namespace';\n\t\t\t}\n\t\n\t\t\tif (name.lastIndexOf('xlink:', 0) === 0) {\n\t\t\t\treturn 'http://www.w3.org/1999/xlink';\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Applies an attribute or property to a given Element. If the value is null\n\t  * or undefined, it is removed from the Element. Otherwise, the value is set\n\t  * as an attribute.\n\t  * @param {!Element} el\n\t  * @param {string} name The attribute's name.\n\t  * @param {?(boolean|number|string)=} value The attribute's value.\n\t  */\n\t\tvar applyAttr = function applyAttr(el, name, value) {\n\t\t\tif (value == null) {\n\t\t\t\tel.removeAttribute(name);\n\t\t\t} else {\n\t\t\t\tvar attrNS = getNamespace(name);\n\t\t\t\tif (attrNS) {\n\t\t\t\t\tel.setAttributeNS(attrNS, name, value);\n\t\t\t\t} else {\n\t\t\t\t\tel.setAttribute(name, value);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Applies a property to a given Element.\n\t  * @param {!Element} el\n\t  * @param {string} name The property's name.\n\t  * @param {*} value The property's value.\n\t  */\n\t\tvar applyProp$1 = function applyProp(el, name, value) {\n\t\t\tel[name] = value;\n\t\t};\n\t\n\t\t/**\n\t  * Applies a style to an Element. No vendor prefix expansion is done for\n\t  * property names/values.\n\t  * @param {!Element} el\n\t  * @param {string} name The attribute's name.\n\t  * @param {*} style The style to set. Either a string of css or an object\n\t  *     containing property-value pairs.\n\t  */\n\t\tvar applyStyle = function applyStyle(el, name, style) {\n\t\t\tif (typeof style === 'string') {\n\t\t\t\tel.style.cssText = style;\n\t\t\t} else {\n\t\t\t\tel.style.cssText = '';\n\t\t\t\tvar elStyle = el.style;\n\t\t\t\tvar obj = /** @type {!Object<string,string>} */style;\n\t\n\t\t\t\tfor (var prop in obj) {\n\t\t\t\t\tif (has(obj, prop)) {\n\t\t\t\t\t\telStyle[prop] = obj[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Updates a single attribute on an Element.\n\t  * @param {!Element} el\n\t  * @param {string} name The attribute's name.\n\t  * @param {*} value The attribute's value. If the value is an object or\n\t  *     function it is set on the Element, otherwise, it is set as an HTML\n\t  *     attribute.\n\t  */\n\t\tvar applyAttributeTyped = function applyAttributeTyped(el, name, value) {\n\t\t\tvar type = typeof value === 'undefined' ? 'undefined' : babelHelpers.typeof(value);\n\t\n\t\t\tif (type === 'object' || type === 'function') {\n\t\t\t\tapplyProp$1(el, name, value);\n\t\t\t} else {\n\t\t\t\tapplyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Calls the appropriate attribute mutator for this attribute.\n\t  * @param {!Element} el\n\t  * @param {string} name The attribute's name.\n\t  * @param {*} value The attribute's value.\n\t  */\n\t\tvar updateAttribute = function updateAttribute(el, name, value) {\n\t\t\tvar data = getData(el);\n\t\t\tvar attrs = data.attrs;\n\t\n\t\t\tif (attrs[name] === value) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar mutator = attributes$1[name] || attributes$1[symbols$2.default];\n\t\t\tmutator(el, name, value);\n\t\n\t\t\tattrs[name] = value;\n\t\t};\n\t\n\t\t/**\n\t  * A publicly mutable object to provide custom mutators for attributes.\n\t  * @const {!Object<string, function(!Element, string, *)>}\n\t  */\n\t\tvar attributes$1 = createMap();\n\t\n\t\t// Special generic mutator that's called for any attribute that does not\n\t\t// have a specific mutator.\n\t\tattributes$1[symbols$2.default] = applyAttributeTyped;\n\t\n\t\tattributes$1[symbols$2.placeholder] = function () {};\n\t\n\t\tattributes$1['style'] = applyStyle;\n\t\n\t\t/**\n\t  * Gets the namespace to create an element (of a given tag) in.\n\t  * @param {string} tag The tag to get the namespace for.\n\t  * @param {?Node} parent\n\t  * @return {?string} The namespace to create the tag in.\n\t  */\n\t\tvar getNamespaceForTag = function getNamespaceForTag(tag, parent) {\n\t\t\tif (tag === 'svg') {\n\t\t\t\treturn 'http://www.w3.org/2000/svg';\n\t\t\t}\n\t\n\t\t\tif (getData(parent).nodeName === 'foreignObject') {\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\treturn parent.namespaceURI;\n\t\t};\n\t\n\t\t/**\n\t  * Creates an Element.\n\t  * @param {Document} doc The document with which to create the Element.\n\t  * @param {?Node} parent\n\t  * @param {string} tag The tag for the Element.\n\t  * @param {?string=} key A key to identify the Element.\n\t  * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t  *     static attributes for the Element.\n\t  * @return {!Element}\n\t  */\n\t\tvar createElement = function createElement(doc, parent, tag, key, statics) {\n\t\t\tvar namespace = getNamespaceForTag(tag, parent);\n\t\t\tvar el = void 0;\n\t\n\t\t\tif (namespace) {\n\t\t\t\tel = doc.createElementNS(namespace, tag);\n\t\t\t} else {\n\t\t\t\tel = doc.createElement(tag);\n\t\t\t}\n\t\n\t\t\tinitData(el, tag, key);\n\t\n\t\t\tif (statics) {\n\t\t\t\tfor (var i = 0; i < statics.length; i += 2) {\n\t\t\t\t\tupdateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn el;\n\t\t};\n\t\n\t\t/**\n\t  * Creates a Text Node.\n\t  * @param {Document} doc The document with which to create the Element.\n\t  * @return {!Text}\n\t  */\n\t\tvar createText = function createText(doc) {\n\t\t\tvar node = doc.createTextNode('');\n\t\t\tinitData(node, '#text', null);\n\t\t\treturn node;\n\t\t};\n\t\n\t\t/**\n\t  * Creates a mapping that can be used to look up children using a key.\n\t  * @param {?Node} el\n\t  * @return {!Object<string, !Element>} A mapping of keys to the children of the\n\t  *     Element.\n\t  */\n\t\tvar createKeyMap = function createKeyMap(el) {\n\t\t\tvar map = createMap();\n\t\t\tvar child = el.firstElementChild;\n\t\n\t\t\twhile (child) {\n\t\t\t\tvar key = getData(child).key;\n\t\n\t\t\t\tif (key) {\n\t\t\t\t\tmap[key] = child;\n\t\t\t\t}\n\t\n\t\t\t\tchild = child.nextElementSibling;\n\t\t\t}\n\t\n\t\t\treturn map;\n\t\t};\n\t\n\t\t/**\n\t  * Retrieves the mapping of key to child node for a given Element, creating it\n\t  * if necessary.\n\t  * @param {?Node} el\n\t  * @return {!Object<string, !Node>} A mapping of keys to child Elements\n\t  */\n\t\tvar getKeyMap = function getKeyMap(el) {\n\t\t\tvar data = getData(el);\n\t\n\t\t\tif (!data.keyMap) {\n\t\t\t\tdata.keyMap = createKeyMap(el);\n\t\t\t}\n\t\n\t\t\treturn data.keyMap;\n\t\t};\n\t\n\t\t/**\n\t  * Retrieves a child from the parent with the given key.\n\t  * @param {?Node} parent\n\t  * @param {?string=} key\n\t  * @return {?Node} The child corresponding to the key.\n\t  */\n\t\tvar getChild = function getChild(parent, key) {\n\t\t\treturn key ? getKeyMap(parent)[key] : null;\n\t\t};\n\t\n\t\t/**\n\t  * Registers an element as being a child. The parent will keep track of the\n\t  * child using the key. The child can be retrieved using the same key using\n\t  * getKeyMap. The provided key should be unique within the parent Element.\n\t  * @param {?Node} parent The parent of child.\n\t  * @param {string} key A key to identify the child with.\n\t  * @param {!Node} child The child to register.\n\t  */\n\t\tvar registerChild = function registerChild(parent, key, child) {\n\t\t\tgetKeyMap(parent)[key] = child;\n\t\t};\n\t\n\t\t/**\n\t  * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t  *\n\t  * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t  * you may not use this file except in compliance with the License.\n\t  * You may obtain a copy of the License at\n\t  *\n\t  *      http://www.apache.org/licenses/LICENSE-2.0\n\t  *\n\t  * Unless required by applicable law or agreed to in writing, software\n\t  * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t  * See the License for the specific language governing permissions and\n\t  * limitations under the License.\n\t  */\n\t\n\t\t/** @const */\n\t\tvar notifications = {\n\t\t\t/**\n\t   * Called after patch has compleated with any Nodes that have been created\n\t   * and added to the DOM.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t\t\tnodesCreated: null,\n\t\n\t\t\t/**\n\t   * Called after patch has compleated with any Nodes that have been removed\n\t   * from the DOM.\n\t   * Note it's an applications responsibility to handle any childNodes.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t\t\tnodesDeleted: null\n\t\t};\n\t\n\t\t/**\n\t  * Keeps track of the state of a patch.\n\t  * @constructor\n\t  */\n\t\tfunction Context() {\n\t\t\t/**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t\t\tthis.created = notifications.nodesCreated && [];\n\t\n\t\t\t/**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t\t\tthis.deleted = notifications.nodesDeleted && [];\n\t\t}\n\t\n\t\t/**\n\t  * @param {!Node} node\n\t  */\n\t\tContext.prototype.markCreated = function (node) {\n\t\t\tif (this.created) {\n\t\t\t\tthis.created.push(node);\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * @param {!Node} node\n\t  */\n\t\tContext.prototype.markDeleted = function (node) {\n\t\t\tif (this.deleted) {\n\t\t\t\tthis.deleted.push(node);\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Notifies about nodes that were created during the patch opearation.\n\t  */\n\t\tContext.prototype.notifyChanges = function () {\n\t\t\tif (this.created && this.created.length > 0) {\n\t\t\t\tnotifications.nodesCreated(this.created);\n\t\t\t}\n\t\n\t\t\tif (this.deleted && this.deleted.length > 0) {\n\t\t\t\tnotifications.nodesDeleted(this.deleted);\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t  *\n\t  * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t  * you may not use this file except in compliance with the License.\n\t  * You may obtain a copy of the License at\n\t  *\n\t  *      http://www.apache.org/licenses/LICENSE-2.0\n\t  *\n\t  * Unless required by applicable law or agreed to in writing, software\n\t  * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t  * See the License for the specific language governing permissions and\n\t  * limitations under the License.\n\t  */\n\t\n\t\t/**\n\t   * Keeps track whether or not we are in an attributes declaration (after\n\t   * elementOpenStart, but before elementOpenEnd).\n\t   * @type {boolean}\n\t   */\n\t\tvar inAttributes = false;\n\t\n\t\t/**\n\t   * Keeps track whether or not we are in an element that should not have its\n\t   * children cleared.\n\t   * @type {boolean}\n\t   */\n\t\tvar inSkip = false;\n\t\n\t\t/**\n\t  * Makes sure that there is a current patch context.\n\t  * @param {*} context\n\t  */\n\t\tvar assertInPatch = function assertInPatch(context) {\n\t\t\tif (!context) {\n\t\t\t\tthrow new Error('Cannot call currentElement() unless in patch.');\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t * Makes sure that keyed Element matches the tag name provided.\n\t * @param {!string} nodeName The nodeName of the node that is being matched.\n\t * @param {string=} tag The tag name of the Element.\n\t * @param {?string=} key The key of the Element.\n\t */\n\t\tvar assertKeyedTagMatches = function assertKeyedTagMatches(nodeName, tag, key) {\n\t\t\tif (nodeName !== tag) {\n\t\t\t\tthrow new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Makes sure that a patch closes every node that it opened.\n\t  * @param {?Node} openElement\n\t  * @param {!Node|!DocumentFragment} root\n\t  */\n\t\tvar assertNoUnclosedTags = function assertNoUnclosedTags(openElement, root) {\n\t\t\tif (openElement === root) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar currentElement = openElement;\n\t\t\tvar openTags = [];\n\t\t\twhile (currentElement && currentElement !== root) {\n\t\t\t\topenTags.push(currentElement.nodeName.toLowerCase());\n\t\t\t\tcurrentElement = currentElement.parentNode;\n\t\t\t}\n\t\n\t\t\tthrow new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n\t\t};\n\t\n\t\t/**\n\t  * Makes sure that the caller is not where attributes are expected.\n\t  * @param {string} functionName\n\t  */\n\t\tvar assertNotInAttributes = function assertNotInAttributes(functionName) {\n\t\t\tif (inAttributes) {\n\t\t\t\tthrow new Error(functionName + '() can not be called between ' + 'elementOpenStart() and elementOpenEnd().');\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Makes sure that the caller is not inside an element that has declared skip.\n\t  * @param {string} functionName\n\t  */\n\t\tvar assertNotInSkip = function assertNotInSkip(functionName) {\n\t\t\tif (inSkip) {\n\t\t\t\tthrow new Error(functionName + '() may not be called inside an element ' + 'that has called skip().');\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Makes sure that the caller is where attributes are expected.\n\t  * @param {string} functionName\n\t  */\n\t\tvar assertInAttributes = function assertInAttributes(functionName) {\n\t\t\tif (!inAttributes) {\n\t\t\t\tthrow new Error(functionName + '() can only be called after calling ' + 'elementOpenStart().');\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Makes sure the patch closes virtual attributes call\n\t  */\n\t\tvar assertVirtualAttributesClosed = function assertVirtualAttributesClosed() {\n\t\t\tif (inAttributes) {\n\t\t\t\tthrow new Error('elementOpenEnd() must be called after calling ' + 'elementOpenStart().');\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t   * Makes sure that placeholders have a key specified. Otherwise, conditional\n\t   * placeholders and conditional elements next to placeholders will cause\n\t   * placeholder elements to be re-used as non-placeholders and vice versa.\n\t   * @param {string} key\n\t   */\n\t\tvar assertPlaceholderKeySpecified = function assertPlaceholderKeySpecified(key) {\n\t\t\tif (!key) {\n\t\t\t\tthrow new Error('elementPlaceholder() requires a key.');\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t   * Makes sure that tags are correctly nested.\n\t   * @param {string} nodeName\n\t   * @param {string} tag\n\t   */\n\t\tvar assertCloseMatchesOpenTag = function assertCloseMatchesOpenTag(nodeName, tag) {\n\t\t\tif (nodeName !== tag) {\n\t\t\t\tthrow new Error('Received a call to close \"' + tag + '\" but \"' + nodeName + '\" was open.');\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Makes sure that no children elements have been declared yet in the current\n\t  * element.\n\t  * @param {string} functionName\n\t  * @param {?Node} previousNode\n\t  */\n\t\tvar assertNoChildrenDeclaredYet = function assertNoChildrenDeclaredYet(functionName, previousNode) {\n\t\t\tif (previousNode !== null) {\n\t\t\t\tthrow new Error(functionName + '() must come before any child ' + 'declarations inside the current element.');\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Checks that a call to patchOuter actually patched the element.\n\t  * @param {?Node} node The node requested to be patched.\n\t  * @param {?Node} currentNode The currentNode after the patch.\n\t  */\n\t\tvar assertPatchElementNotEmpty = function assertPatchElementNotEmpty(node, currentNode) {\n\t\t\tif (node === currentNode) {\n\t\t\t\tthrow new Error('There must be exactly one top level call corresponding ' + 'to the patched element.');\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Checks that a call to patchOuter actually patched the element.\n\t  * @param {?Node} node The node requested to be patched.\n\t  * @param {?Node} previousNode The previousNode after the patch.\n\t  */\n\t\tvar assertPatchElementNoExtras = function assertPatchElementNoExtras(node, previousNode) {\n\t\t\tif (node !== previousNode) {\n\t\t\t\tthrow new Error('There must be exactly one top level call corresponding ' + 'to the patched element.');\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Updates the state of being in an attribute declaration.\n\t  * @param {boolean} value\n\t  * @return {boolean} the previous value.\n\t  */\n\t\tvar setInAttributes = function setInAttributes(value) {\n\t\t\tvar previous = inAttributes;\n\t\t\tinAttributes = value;\n\t\t\treturn previous;\n\t\t};\n\t\n\t\t/**\n\t  * Updates the state of being in a skip element.\n\t  * @param {boolean} value\n\t  * @return {boolean} the previous value.\n\t  */\n\t\tvar setInSkip = function setInSkip(value) {\n\t\t\tvar previous = inSkip;\n\t\t\tinSkip = value;\n\t\t\treturn previous;\n\t\t};\n\t\n\t\t/** @type {?Context} */\n\t\tvar context = null;\n\t\n\t\t/** @type {?Node} */\n\t\tvar currentNode = void 0;\n\t\n\t\t/** @type {?Node} */\n\t\tvar currentParent = void 0;\n\t\n\t\t/** @type {?Element|?DocumentFragment} */\n\t\tvar root = void 0;\n\t\n\t\t/** @type {?Document} */\n\t\tvar doc = void 0;\n\t\n\t\t/**\n\t  * Sets up and restores a patch context, running the patch function with the\n\t  * provided data.\n\t  * @param {!Element|!DocumentFragment} node The Element or Document\n\t  *     where the patch should start.\n\t  * @param {!function(T)} fn The patching function.\n\t  * @param {T=} data An argument passed to fn.\n\t  * @template T\n\t  */\n\t\tvar runPatch = function runPatch(node, fn, data) {\n\t\t\tvar prevContext = context;\n\t\t\tvar prevRoot = root;\n\t\t\tvar prevDoc = doc;\n\t\t\tvar prevCurrentNode = currentNode;\n\t\t\tvar prevCurrentParent = currentParent;\n\t\t\tvar previousInAttributes = false;\n\t\t\tvar previousInSkip = false;\n\t\n\t\t\tcontext = new Context();\n\t\t\troot = node;\n\t\t\tdoc = node.ownerDocument;\n\t\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tpreviousInAttributes = setInAttributes(false);\n\t\t\t\tpreviousInSkip = setInSkip(false);\n\t\t\t}\n\t\n\t\t\tfn(data);\n\t\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tassertVirtualAttributesClosed();\n\t\t\t\tsetInAttributes(previousInAttributes);\n\t\t\t\tsetInSkip(previousInSkip);\n\t\t\t}\n\t\n\t\t\tcontext.notifyChanges();\n\t\n\t\t\tcontext = prevContext;\n\t\t\troot = prevRoot;\n\t\t\tdoc = prevDoc;\n\t\t\tcurrentNode = prevCurrentNode;\n\t\t\tcurrentParent = prevCurrentParent;\n\t\t};\n\t\n\t\t/**\n\t  * Patches the document starting at node with the provided function. This\n\t  * function may be called during an existing patch operation.\n\t  * @param {!Element|!DocumentFragment} node The Element or Document\n\t  *     to patch.\n\t  * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t  *     calls that describe the DOM.\n\t  * @param {T=} data An argument passed to fn to represent DOM state.\n\t  * @template T\n\t  */\n\t\tvar patch = function patchInner(node, fn, data) {\n\t\t\trunPatch(node, function (data) {\n\t\t\t\tcurrentNode = node;\n\t\t\t\tcurrentParent = node.parentNode;\n\t\n\t\t\t\tenterNode();\n\t\t\t\tfn(data);\n\t\t\t\texitNode();\n\t\n\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tassertNoUnclosedTags(currentNode, node);\n\t\t\t\t}\n\t\t\t}, data);\n\t\t};\n\t\n\t\t/**\n\t  * Patches an Element with the the provided function. Exactly one top level\n\t  * element call should be made corresponding to `node`.\n\t  * @param {!Element} node The Element where the patch should start.\n\t  * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t  *     calls that describe the DOM. This should have at most one top level\n\t  *     element call.\n\t  * @param {T=} data An argument passed to fn to represent DOM state.\n\t  * @template T\n\t  */\n\t\tvar patchOuter = function patchOuter(node, fn, data) {\n\t\t\trunPatch(node, function (data) {\n\t\t\t\tcurrentNode = /** @type {!Element} */{ nextSibling: node };\n\t\t\t\tcurrentParent = node.parentNode;\n\t\n\t\t\t\tfn(data);\n\t\n\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tassertPatchElementNotEmpty(node, currentNode.nextSibling);\n\t\t\t\t\tassertPatchElementNoExtras(node, currentNode);\n\t\t\t\t}\n\t\t\t}, data);\n\t\t};\n\t\n\t\t/**\n\t  * Checks whether or not the current node matches the specified nodeName and\n\t  * key.\n\t  *\n\t  * @param {?string} nodeName The nodeName for this node.\n\t  * @param {?string=} key An optional key that identifies a node.\n\t  * @return {boolean} True if the node matches, false otherwise.\n\t  */\n\t\tvar matches = function matches(nodeName, key) {\n\t\t\tvar data = getData(currentNode);\n\t\n\t\t\t// Key check is done using double equals as we want to treat a null key the\n\t\t\t// same as undefined. This should be okay as the only values allowed are\n\t\t\t// strings, null and undefined so the == semantics are not too weird.\n\t\t\treturn nodeName === data.nodeName && key == data.key;\n\t\t};\n\t\n\t\t/**\n\t  * Aligns the virtual Element definition with the actual DOM, moving the\n\t  * corresponding DOM node to the correct location or creating it if necessary.\n\t  * @param {string} nodeName For an Element, this should be a valid tag string.\n\t  *     For a Text, this should be #text.\n\t  * @param {?string=} key The key used to identify this element.\n\t  * @param {?Array<*>=} statics For an Element, this should be an array of\n\t  *     name-value pairs.\n\t  */\n\t\tvar alignWithDOM = function alignWithDOM(nodeName, key, statics) {\n\t\t\tif (currentNode && matches(nodeName, key)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar node = void 0;\n\t\n\t\t\t// Check to see if the node has moved within the parent.\n\t\t\tif (key) {\n\t\t\t\tnode = getChild(currentParent, key);\n\t\t\t\tif (node && process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tassertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Create the node if it doesn't exist.\n\t\t\tif (!node) {\n\t\t\t\tif (nodeName === '#text') {\n\t\t\t\t\tnode = createText(doc);\n\t\t\t\t} else {\n\t\t\t\t\tnode = createElement(doc, currentParent, nodeName, key, statics);\n\t\t\t\t}\n\t\n\t\t\t\tif (key) {\n\t\t\t\t\tregisterChild(currentParent, key, node);\n\t\t\t\t}\n\t\n\t\t\t\tcontext.markCreated(node);\n\t\t\t}\n\t\n\t\t\t// If the node has a key, remove it from the DOM to prevent a large number\n\t\t\t// of re-orders in the case that it moved far or was completely removed.\n\t\t\t// Since we hold on to a reference through the keyMap, we can always add it\n\t\t\t// back.\n\t\t\tif (currentNode && getData(currentNode).key) {\n\t\t\t\tcurrentParent.replaceChild(node, currentNode);\n\t\t\t\tgetData(currentParent).keyMapValid = false;\n\t\t\t} else {\n\t\t\t\tcurrentParent.insertBefore(node, currentNode);\n\t\t\t}\n\t\n\t\t\tcurrentNode = node;\n\t\t};\n\t\n\t\t/**\n\t  * Clears out any unvisited Nodes, as the corresponding virtual element\n\t  * functions were never called for them.\n\t  */\n\t\tvar clearUnvisitedDOM = function clearUnvisitedDOM() {\n\t\t\tvar node = currentParent;\n\t\t\tvar data = getData(node);\n\t\t\tvar keyMap = data.keyMap;\n\t\t\tvar keyMapValid = data.keyMapValid;\n\t\t\tvar child = node.lastChild;\n\t\t\tvar key = void 0;\n\t\n\t\t\tif (child === currentNode && keyMapValid) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif (data.attrs[symbols$2.placeholder] && node !== root) {\n\t\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\t\tconsole.warn('symbols.placeholder will be removed in Incremental DOM' + ' 0.5 use skip() instead');\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\twhile (child !== currentNode) {\n\t\t\t\tnode.removeChild(child);\n\t\t\t\tcontext.markDeleted( /** @type {!Node}*/child);\n\t\n\t\t\t\tkey = getData(child).key;\n\t\t\t\tif (key) {\n\t\t\t\t\tdelete keyMap[key];\n\t\t\t\t}\n\t\t\t\tchild = node.lastChild;\n\t\t\t}\n\t\n\t\t\t// Clean the keyMap, removing any unusued keys.\n\t\t\tif (!keyMapValid) {\n\t\t\t\tfor (key in keyMap) {\n\t\t\t\t\tchild = keyMap[key];\n\t\t\t\t\tif (child.parentNode !== node) {\n\t\t\t\t\t\tcontext.markDeleted(child);\n\t\t\t\t\t\tdelete keyMap[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tdata.keyMapValid = true;\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Changes to the first child of the current node.\n\t  */\n\t\tvar enterNode = function enterNode() {\n\t\t\tcurrentParent = currentNode;\n\t\t\tcurrentNode = null;\n\t\t};\n\t\n\t\t/**\n\t  * Changes to the next sibling of the current node.\n\t  */\n\t\tvar nextNode = function nextNode() {\n\t\t\tif (currentNode) {\n\t\t\t\tcurrentNode = currentNode.nextSibling;\n\t\t\t} else {\n\t\t\t\tcurrentNode = currentParent.firstChild;\n\t\t\t}\n\t\t};\n\t\n\t\t/**\n\t  * Changes to the parent of the current node, removing any unvisited children.\n\t  */\n\t\tvar exitNode = function exitNode() {\n\t\t\tclearUnvisitedDOM();\n\t\n\t\t\tcurrentNode = currentParent;\n\t\t\tcurrentParent = currentParent.parentNode;\n\t\t};\n\t\n\t\t/**\n\t  * Makes sure that the current node is an Element with a matching tagName and\n\t  * key.\n\t  *\n\t  * @param {string} tag The element's tag.\n\t  * @param {?string=} key The key used to identify this element. This can be an\n\t  *     empty string, but performance may be better if a unique value is used\n\t  *     when iterating over an array of items.\n\t  * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t  *     static attributes for the Element. These will only be set once when the\n\t  *     Element is created.\n\t  * @return {!Element} The corresponding Element.\n\t  */\n\t\tvar coreElementOpen = function elementOpen(tag, key, statics) {\n\t\t\tnextNode();\n\t\t\talignWithDOM(tag, key, statics);\n\t\t\tenterNode();\n\t\t\treturn (/** @type {!Element} */currentParent\n\t\t\t);\n\t\t};\n\t\n\t\t/**\n\t  * Closes the currently open Element, removing any unvisited children if\n\t  * necessary.\n\t  *\n\t  * @return {!Element} The corresponding Element.\n\t  */\n\t\tvar coreElementClose = function elementClose() {\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tsetInSkip(false);\n\t\t\t}\n\t\n\t\t\texitNode();\n\t\t\treturn (/** @type {!Element} */currentNode\n\t\t\t);\n\t\t};\n\t\n\t\t/**\n\t  * Makes sure the current node is a Text node and creates a Text node if it is\n\t  * not.\n\t  *\n\t  * @return {!Text} The corresponding Text Node.\n\t  */\n\t\tvar coreText = function text() {\n\t\t\tnextNode();\n\t\t\talignWithDOM('#text', null, null);\n\t\t\treturn (/** @type {!Text} */currentNode\n\t\t\t);\n\t\t};\n\t\n\t\t/**\n\t  * Gets the current Element being patched.\n\t  * @return {!Element}\n\t  */\n\t\tvar currentElement = function currentElement() {\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tassertInPatch(context);\n\t\t\t\tassertNotInAttributes('currentElement');\n\t\t\t}\n\t\t\treturn (/** @type {!Element} */currentParent\n\t\t\t);\n\t\t};\n\t\n\t\t/**\n\t  * Skips the children in a subtree, allowing an Element to be closed without\n\t  * clearing out the children.\n\t  */\n\t\tvar skip$1 = function skip() {\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tassertNoChildrenDeclaredYet('skip', currentNode);\n\t\t\t\tsetInSkip(true);\n\t\t\t}\n\t\t\tcurrentNode = currentParent.lastChild;\n\t\t};\n\t\n\t\t/**\n\t  * The offset in the virtual element declaration where the attributes are\n\t  * specified.\n\t  * @const\n\t  */\n\t\tvar ATTRIBUTES_OFFSET = 3;\n\t\n\t\t/**\n\t  * Builds an array of arguments for use with elementOpenStart, attr and\n\t  * elementOpenEnd.\n\t  * @const {Array<*>}\n\t  */\n\t\tvar argsBuilder = [];\n\t\n\t\t/**\n\t  * @param {string} tag The element's tag.\n\t  * @param {?string=} key The key used to identify this element. This can be an\n\t  *     empty string, but performance may be better if a unique value is used\n\t  *     when iterating over an array of items.\n\t  * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t  *     static attributes for the Element. These will only be set once when the\n\t  *     Element is created.\n\t  * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t  *     for the Element.\n\t  * @return {!Element} The corresponding Element.\n\t  */\n\t\tvar elementOpen$1 = function elementOpen(tag, key, statics, const_args) {\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tassertNotInAttributes('elementOpen');\n\t\t\t\tassertNotInSkip('elementOpen');\n\t\t\t}\n\t\n\t\t\tvar node = coreElementOpen(tag, key, statics);\n\t\t\tvar data = getData(node);\n\t\n\t\t\t/*\n\t   * Checks to see if one or more attributes have changed for a given Element.\n\t   * When no attributes have changed, this is much faster than checking each\n\t   * individual argument. When attributes have changed, the overhead of this is\n\t   * minimal.\n\t   */\n\t\t\tvar attrsArr = data.attrsArr;\n\t\t\tvar newAttrs = data.newAttrs;\n\t\t\tvar attrsChanged = false;\n\t\t\tvar i = ATTRIBUTES_OFFSET;\n\t\t\tvar j = 0;\n\t\n\t\t\tfor (; i < arguments.length; i += 1, j += 1) {\n\t\t\t\tif (attrsArr[j] !== arguments[i]) {\n\t\t\t\t\tattrsChanged = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor (; i < arguments.length; i += 1, j += 1) {\n\t\t\t\tattrsArr[j] = arguments[i];\n\t\t\t}\n\t\n\t\t\tif (j < attrsArr.length) {\n\t\t\t\tattrsChanged = true;\n\t\t\t\tattrsArr.length = j;\n\t\t\t}\n\t\n\t\t\t/*\n\t   * Actually perform the attribute update.\n\t   */\n\t\t\tif (attrsChanged) {\n\t\t\t\tfor (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t\t\t\t\tnewAttrs[arguments[i]] = arguments[i + 1];\n\t\t\t\t}\n\t\n\t\t\t\tfor (var _attr in newAttrs) {\n\t\t\t\t\tupdateAttribute(node, _attr, newAttrs[_attr]);\n\t\t\t\t\tnewAttrs[_attr] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn node;\n\t\t};\n\t\n\t\t/**\n\t  * Declares a virtual Element at the current location in the document. This\n\t  * corresponds to an opening tag and a elementClose tag is required. This is\n\t  * like elementOpen, but the attributes are defined using the attr function\n\t  * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t  * to attr, then a call to elementOpenEnd.\n\t  * @param {string} tag The element's tag.\n\t  * @param {?string=} key The key used to identify this element. This can be an\n\t  *     empty string, but performance may be better if a unique value is used\n\t  *     when iterating over an array of items.\n\t  * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t  *     static attributes for the Element. These will only be set once when the\n\t  *     Element is created.\n\t  */\n\t\tvar elementOpenStart$1 = function elementOpenStart(tag, key, statics) {\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tassertNotInAttributes('elementOpenStart');\n\t\t\t\tsetInAttributes(true);\n\t\t\t}\n\t\n\t\t\targsBuilder[0] = tag;\n\t\t\targsBuilder[1] = key;\n\t\t\targsBuilder[2] = statics;\n\t\t};\n\t\n\t\t/***\n\t  * Defines a virtual attribute at this point of the DOM. This is only valid\n\t  * when called between elementOpenStart and elementOpenEnd.\n\t  *\n\t  * @param {string} name\n\t  * @param {*} value\n\t  */\n\t\tvar attr$1 = function attr(name, value) {\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tassertInAttributes('attr');\n\t\t\t}\n\t\n\t\t\targsBuilder.push(name, value);\n\t\t};\n\t\n\t\t/**\n\t  * Closes an open tag started with elementOpenStart.\n\t  * @return {!Element} The corresponding Element.\n\t  */\n\t\tvar elementOpenEnd$1 = function elementOpenEnd() {\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tassertInAttributes('elementOpenEnd');\n\t\t\t\tsetInAttributes(false);\n\t\t\t}\n\t\n\t\t\tvar node = elementOpen$1.apply(null, argsBuilder);\n\t\t\targsBuilder.length = 0;\n\t\t\treturn node;\n\t\t};\n\t\n\t\t/**\n\t  * Closes an open virtual Element.\n\t  *\n\t  * @param {string} tag The element's tag.\n\t  * @return {!Element} The corresponding Element.\n\t  */\n\t\tvar elementClose$1 = function elementClose(tag) {\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tassertNotInAttributes('elementClose');\n\t\t\t}\n\t\n\t\t\tvar node = coreElementClose();\n\t\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tassertCloseMatchesOpenTag(getData(node).nodeName, tag);\n\t\t\t}\n\t\n\t\t\treturn node;\n\t\t};\n\t\n\t\t/**\n\t  * Declares a virtual Element at the current location in the document that has\n\t  * no children.\n\t  * @param {string} tag The element's tag.\n\t  * @param {?string=} key The key used to identify this element. This can be an\n\t  *     empty string, but performance may be better if a unique value is used\n\t  *     when iterating over an array of items.\n\t  * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t  *     static attributes for the Element. These will only be set once when the\n\t  *     Element is created.\n\t  * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t  *     for the Element.\n\t  * @return {!Element} The corresponding Element.\n\t  */\n\t\tvar elementVoid = function elementVoid(tag, key, statics, const_args) {\n\t\t\tvar node = elementOpen$1.apply(null, arguments);\n\t\t\telementClose$1.apply(null, arguments);\n\t\t\treturn node;\n\t\t};\n\t\n\t\t/**\n\t  * Declares a virtual Element at the current location in the document that is a\n\t  * placeholder element. Children of this Element can be manually managed and\n\t  * will not be cleared by the library.\n\t  *\n\t  * A key must be specified to make sure that this node is correctly preserved\n\t  * across all conditionals.\n\t  *\n\t  * @param {string} tag The element's tag.\n\t  * @param {string} key The key used to identify this element.\n\t  * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t  *     static attributes for the Element. These will only be set once when the\n\t  *     Element is created.\n\t  * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t  *     for the Element.\n\t  * @return {!Element} The corresponding Element.\n\t  */\n\t\tvar elementPlaceholder = function elementPlaceholder(tag, key, statics, const_args) {\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tassertPlaceholderKeySpecified(key);\n\t\t\t\tconsole.warn('elementPlaceholder will be removed in Incremental DOM 0.5' + ' use skip() instead');\n\t\t\t}\n\t\n\t\t\telementOpen$1.apply(null, arguments);\n\t\t\tskip$1();\n\t\t\treturn elementClose$1.apply(null, arguments);\n\t\t};\n\t\n\t\t/**\n\t  * Declares a virtual Text at this point in the document.\n\t  *\n\t  * @param {string|number|boolean} value The value of the Text.\n\t  * @param {...(function((string|number|boolean)):string)} const_args\n\t  *     Functions to format the value which are called only when the value has\n\t  *     changed.\n\t  * @return {!Text} The corresponding text node.\n\t  */\n\t\tvar text$1 = function text(value, const_args) {\n\t\t\tif (process.env.NODE_ENV !== 'production') {\n\t\t\t\tassertNotInAttributes('text');\n\t\t\t\tassertNotInSkip('text');\n\t\t\t}\n\t\n\t\t\tvar node = coreText();\n\t\t\tvar data = getData(node);\n\t\n\t\t\tif (data.text !== value) {\n\t\t\t\tdata.text = /** @type {string} */value;\n\t\n\t\t\t\tvar formatted = value;\n\t\t\t\tfor (var i = 1; i < arguments.length; i += 1) {\n\t\t\t\t\t/*\n\t     * Call the formatter function directly to prevent leaking arguments.\n\t     * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n\t     */\n\t\t\t\t\tvar fn = arguments[i];\n\t\t\t\t\tformatted = fn(formatted);\n\t\t\t\t}\n\t\n\t\t\t\tnode.data = formatted;\n\t\t\t}\n\t\n\t\t\treturn node;\n\t\t};\n\t\n\t\tvar IncrementalDOM = Object.freeze({\n\t\t\tpatch: patch,\n\t\t\tpatchInner: patch,\n\t\t\tpatchOuter: patchOuter,\n\t\t\tcurrentElement: currentElement,\n\t\t\tskip: skip$1,\n\t\t\telementVoid: elementVoid,\n\t\t\telementOpenStart: elementOpenStart$1,\n\t\t\telementOpenEnd: elementOpenEnd$1,\n\t\t\telementOpen: elementOpen$1,\n\t\t\telementClose: elementClose$1,\n\t\t\telementPlaceholder: elementPlaceholder,\n\t\t\ttext: text$1,\n\t\t\tattr: attr$1,\n\t\t\tsymbols: symbols$2,\n\t\t\tattributes: attributes$1,\n\t\t\tapplyAttr: applyAttr,\n\t\t\tapplyProp: applyProp$1,\n\t\t\tnotifications: notifications\n\t\t});\n\t\n\t\tvar div = document.createElement('div');\n\t\tvar customElementsV0 = !!document.registerElement;\n\t\tvar customElementsV1 = !!window.customElements;\n\t\tvar shadowDomV0 = !!div.createShadowRoot;\n\t\tvar shadowDomV1 = !!div.attachShadow;\n\t\n\t\t// Could import these, but we have to import all of IncrementalDOM anyways so\n\t\t// that we can export our configured IncrementalDOM.\n\t\tvar applyProp = applyProp$1;\n\t\tvar attr = attr$1;\n\t\tvar attributes = attributes$1;\n\t\tvar elementClose = elementClose$1;\n\t\tvar elementOpen = elementOpen$1;\n\t\tvar elementOpenEnd = elementOpenEnd$1;\n\t\tvar elementOpenStart = elementOpenStart$1;\n\t\tvar skip = skip$1;\n\t\tvar symbols$1 = symbols$2;\n\t\tvar text = text$1;\n\t\n\t\tvar applyDefault = attributes[symbols$1.default];\n\t\n\t\t// Attributes that are not handled by Incremental DOM.\n\t\tattributes.key = attributes.skip = attributes.statics = function () {};\n\t\n\t\t// Attributes that *must* be set via a property on all elements.\n\t\tattributes.checked = attributes.className = attributes.disabled = attributes.value = applyProp;\n\t\n\t\t// Default attribute applicator.\n\t\tattributes[symbols$1.default] = function (elem, name, value) {\n\t\t\t// Boolean false values should not set attributes at all.\n\t\t\tif (value === false) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// Custom element properties should be set as properties.\n\t\t\tvar props = elem.constructor.props;\n\t\t\tif (props && name in props) {\n\t\t\t\treturn applyProp(elem, name, value);\n\t\t\t}\n\t\n\t\t\t// Handle built-in and custom events.\n\t\t\tif (name.indexOf('on') === 0) {\n\t\t\t\treturn name in elem ? applyProp(elem, name, value) : applyEvent(elem, name.substring(2), name, value);\n\t\t\t}\n\t\n\t\t\t// Fallback to default IncrementalDOM behaviour.\n\t\t\tapplyDefault(elem, name, value);\n\t\t};\n\t\n\t\t// Adds or removes an event listener for an element.\n\t\tfunction applyEvent(elem, ename, name, value) {\n\t\t\tvar events = elem.__events;\n\t\n\t\t\tif (!events) {\n\t\t\t\tevents = elem.__events = {};\n\t\t\t}\n\t\n\t\t\tvar eFunc = events[ename];\n\t\n\t\t\t// Remove old listener so they don't double up.\n\t\t\tif (eFunc) {\n\t\t\t\telem.removeEventListener(ename, eFunc);\n\t\t\t}\n\t\n\t\t\t// Bind new listener.\n\t\t\tif (value) {\n\t\t\t\telem.addEventListener(ename, events[ename] = value);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction element(tname, attrs, chren) {\n\t\t\t// Allow a component constructor to be passed in.\n\t\t\tif (typeof tname === 'function') {\n\t\t\t\ttname = tname[name];\n\t\t\t}\n\t\n\t\t\tvar shouldBeContentTag = tname === 'slot' && !shadowDomV1 && shadowDomV0;\n\t\n\t\t\t// Abstract Shadow DOM V0 <content> behind Shadow DOM V1 <slot>.\n\t\t\tif (shouldBeContentTag) {\n\t\t\t\ttname = 'content';\n\t\t\t}\n\t\n\t\t\tif (attrs && (typeof attrs === 'undefined' ? 'undefined' : babelHelpers.typeof(attrs)) === 'object') {\n\t\t\t\t// Abstract Shadow DOM V0 <content> behind Shadow DOM V1 <slot>.\n\t\t\t\tif (shouldBeContentTag && attrs.name) {\n\t\t\t\t\tattrs.select = '[slot=\"' + attrs.name + '\"]';\n\t\t\t\t\tdelete attrs.slot;\n\t\t\t\t}\n\t\n\t\t\t\telementOpenStart(tname, attrs.key, attrs.statics);\n\t\t\t\tfor (var a in attrs) {\n\t\t\t\t\tattr(a, attrs[a]);\n\t\t\t\t}\n\t\t\t\telementOpenEnd();\n\t\t\t} else {\n\t\t\t\telementOpen(tname);\n\t\t\t\tchren = attrs;\n\t\t\t\tattrs = {};\n\t\t\t}\n\t\n\t\t\tif (attrs.skip) {\n\t\t\t\tskip();\n\t\t\t} else {\n\t\t\t\tvar chrenType = typeof chren === 'undefined' ? 'undefined' : babelHelpers.typeof(chren);\n\t\t\t\tif (chrenType === 'function') {\n\t\t\t\t\tchren();\n\t\t\t\t} else if (chrenType === 'string' || chrenType === 'number') {\n\t\t\t\t\ttext(chren);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn elementClose(tname);\n\t\t}\n\t\n\t\tvar vdom = Object.freeze({\n\t\t\telement: element,\n\t\t\ttext: text,\n\t\t\tIncrementalDOM: IncrementalDOM\n\t\t});\n\t\n\t\tfunction data(element) {\n\t\t\tvar namespace = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\t\n\t\t\tvar data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n\t\t\treturn namespace && (data[namespace] || (data[namespace] = {})) || data;\n\t\t}\n\t\n\t\tfunction getOwnPropertyDescriptors(obj) {\n\t\t\treturn Object.getOwnPropertyNames(obj || {}).reduce(function (prev, curr) {\n\t\t\t\tprev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n\t\t\t\treturn prev;\n\t\t\t}, {});\n\t\t}\n\t\n\t\tvar Component = function (_HTMLElement) {\n\t\t\tbabelHelpers.inherits(Component, _HTMLElement);\n\t\n\t\t\tfunction Component() {\n\t\t\t\tbabelHelpers.classCallCheck(this, Component);\n\t\n\t\t\t\tvar _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(Component).call(this));\n\t\n\t\t\t\t_this.createdCallback();\n\t\t\t\treturn _this;\n\t\t\t}\n\t\n\t\t\tbabelHelpers.createClass(Component, [{\n\t\t\t\tkey: 'connectedCallback',\n\t\t\t\tvalue: function connectedCallback() {\n\t\t\t\t\tvar cb = this.constructor.attached;\n\t\t\t\t\tcb && cb(this);\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'disconnectedCallback',\n\t\t\t\tvalue: function disconnectedCallback() {\n\t\t\t\t\tvar cb = this.constructor.detached;\n\t\t\t\t\tcb && cb(this);\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'attributeChangedCallback',\n\t\t\t\tvalue: function attributeChangedCallback(name, oldValue, newValue) {\n\t\t\t\t\tvar _constructor = this.constructor;\n\t\t\t\t\tvar attributeChanged = _constructor.attributeChanged;\n\t\t\t\t\tvar observedAttributes = _constructor.observedAttributes;\n\t\n\t\t\t\t\tvar propertyName = data(this, 'attributeLinks')[name];\n\t\n\t\t\t\t\t// In V0 we have to ensure the attribute is being observed.\n\t\t\t\t\tif (customElementsV0 && observedAttributes.indexOf(name) === -1) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (propertyName) {\n\t\t\t\t\t\tvar propData = data(this, 'api/property/' + propertyName);\n\t\n\t\t\t\t\t\t// This ensures a property set doesn't cause the attribute changed\n\t\t\t\t\t\t// handler to run again once we set this flag. This only ever has a\n\t\t\t\t\t\t// chance to run when you set an attribute, it then sets a property and\n\t\t\t\t\t\t// then that causes the attribute to be set again.\n\t\t\t\t\t\tif (propData.syncingAttribute) {\n\t\t\t\t\t\t\tpropData.syncingAttribute = false;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// Sync up the property.\n\t\t\t\t\t\tvar propOpts = this.constructor.props[propertyName];\n\t\t\t\t\t\tpropData.settingAttribute = true;\n\t\t\t\t\t\tthis[propertyName] = newValue !== null && propOpts.deserialize ? propOpts.deserialize(newValue) : newValue;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (attributeChanged) {\n\t\t\t\t\t\tattributeChanged(this, { name: name, newValue: newValue, oldValue: oldValue });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'createdCallback',\n\t\t\t\tvalue: function createdCallback() {\n\t\t\t\t\tvar _this2 = this;\n\t\n\t\t\t\t\tvar elemData = data(this);\n\t\t\t\t\tvar readyCallbacks = elemData.readyCallbacks;\n\t\t\t\t\tvar Ctor = this.constructor;\n\t\t\t\t\tvar definedAttribute = Ctor.definedAttribute;\n\t\t\t\t\tvar events$$ = Ctor.events;\n\t\t\t\t\tvar created$$ = Ctor.created;\n\t\t\t\t\tvar observedAttributes = Ctor.observedAttributes;\n\t\t\t\t\tvar props$$ = Ctor.props;\n\t\t\t\t\tvar ready = Ctor.ready;\n\t\t\t\t\tvar renderedAttribute = Ctor.renderedAttribute;\n\t\n\t\t\t\t\tvar renderer$$ = Ctor[renderer];\n\t\n\t\t\t\t\t// TODO: This prevents an element from being initialised multiple times. For\n\t\t\t\t\t// some reason this is happening in the event tests. It's possibly creating\n\t\t\t\t\t// elements in a way that the causes the custom element v1 polyfill to call\n\t\t\t\t\t// the constructor twice.\n\t\t\t\t\tif (this[created]) return;\n\t\t\t\t\tthis[created] = true;\n\t\n\t\t\t\t\tif (props$$) {\n\t\t\t\t\t\tCtor[props](this);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (events$$) {\n\t\t\t\t\t\tCtor[events](this);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (created$$) {\n\t\t\t\t\t\tcreated$$(this);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (renderer$$ && !this.hasAttribute(renderedAttribute)) {\n\t\t\t\t\t\trenderer$$(this);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (ready) {\n\t\t\t\t\t\tready(this);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (!this.hasAttribute(definedAttribute)) {\n\t\t\t\t\t\tthis.setAttribute(definedAttribute, '');\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (readyCallbacks) {\n\t\t\t\t\t\treadyCallbacks.forEach(function (cb) {\n\t\t\t\t\t\t\treturn cb(_this2);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tdelete elemData.readyCallbacks;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// In v0 we must ensure the attributeChangedCallback is called for attrs\n\t\t\t\t\t// that aren't linked to props so that the callback behaves the same no\n\t\t\t\t\t// matter if v0 or v1 is being used.\n\t\t\t\t\tif (customElementsV0) {\n\t\t\t\t\t\tobservedAttributes.forEach(function (name) {\n\t\t\t\t\t\t\tvar propertyName = data(_this2, 'attributeLinks')[name];\n\t\t\t\t\t\t\tif (!propertyName) {\n\t\t\t\t\t\t\t\t_this2.attributeChangedCallback(name, null, _this2.getAttribute(name));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'attachedCallback',\n\t\t\t\tvalue: function attachedCallback() {\n\t\t\t\t\tthis.connectedCallback();\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'detachedCallback',\n\t\t\t\tvalue: function detachedCallback() {\n\t\t\t\t\tthis.disconnectedCallback();\n\t\t\t\t}\n\t\t\t}], [{\n\t\t\t\tkey: 'extend',\n\t\t\t\tvalue: function extend() {\n\t\t\t\t\tvar definition = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t\t\t\t\tvar Base = arguments.length <= 1 || arguments[1] === undefined ? this : arguments[1];\n\t\n\t\t\t\t\t// Create class for the user.\n\t\n\t\t\t\t\tvar Ctor = function (_Base) {\n\t\t\t\t\t\tbabelHelpers.inherits(Ctor, _Base);\n\t\n\t\t\t\t\t\tfunction Ctor() {\n\t\t\t\t\t\t\tbabelHelpers.classCallCheck(this, Ctor);\n\t\t\t\t\t\t\treturn babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(Ctor).apply(this, arguments));\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn Ctor;\n\t\t\t\t\t}(Base);\n\t\n\t\t\t\t\t// For inheriting from the object literal.\n\t\n\t\t\t\t\tvar opts = getOwnPropertyDescriptors(definition);\n\t\t\t\t\tvar prot = getOwnPropertyDescriptors(definition.prototype);\n\t\n\t\t\t\t\t// Prototype is non configurable (but is writable) s\n\t\t\t\t\tdelete opts.prototype;\n\t\n\t\t\t\t\t// Pass on static and instance members from the definition.\n\t\t\t\t\tObject.defineProperties(Ctor, opts);\n\t\t\t\t\tObject.defineProperties(Ctor.prototype, prot);\n\t\n\t\t\t\t\treturn Ctor;\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'definedAttribute',\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn 'defined';\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'events',\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn {};\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'observedAttributes',\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'props',\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn {};\n\t\t\t\t}\n\t\t\t}, {\n\t\t\t\tkey: 'renderedAttribute',\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn 'rendered';\n\t\t\t\t}\n\t\t\t}]);\n\t\t\treturn Component;\n\t\t}(HTMLElement);\n\t\n\t\tvar elProto = window.HTMLElement.prototype;\n\t\tvar nativeMatchesSelector = elProto.matches || elProto.msMatchesSelector || elProto.webkitMatchesSelector || elProto.mozMatchesSelector || elProto.oMatchesSelector;\n\t\n\t\t// Only IE9 has this msMatchesSelector bug, but best to detect it.\n\t\tvar hasNativeMatchesSelectorDetattachedBug = !nativeMatchesSelector.call(document.createElement('div'), 'div');\n\t\n\t\tfunction matches$1(element, selector) {\n\t\t\tif (hasNativeMatchesSelectorDetattachedBug) {\n\t\t\t\tvar clone = element.cloneNode();\n\t\t\t\tdocument.createElement('div').appendChild(clone);\n\t\t\t\treturn nativeMatchesSelector.call(clone, selector);\n\t\t\t}\n\t\t\treturn nativeMatchesSelector.call(element, selector);\n\t\t}\n\t\n\t\tfunction readonly(obj, prop, val) {\n\t\t\tObject.defineProperty(obj, prop, {\n\t\t\t\tconfigurable: true,\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn val;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\tfunction parseEvent(e) {\n\t\t\tvar indexOfSpace = e.indexOf(' ');\n\t\t\tvar hasSpace = indexOfSpace > 0;\n\t\t\tvar name = hasSpace ? e.substring(0, indexOfSpace) : e;\n\t\t\tvar selector = hasSpace ? e.substring(indexOfSpace + 1) : '';\n\t\t\treturn {\n\t\t\t\tname: name,\n\t\t\t\tselector: selector\n\t\t\t};\n\t\t}\n\t\n\t\tfunction makeDelegateHandler(elem, handler, parsed) {\n\t\t\treturn function (e) {\n\t\t\t\tvar current = e.path ? e.path[0] : e.target;\n\t\t\t\tvar selector = parsed.selector;\n\t\t\t\twhile (current && current !== elem.parentNode) {\n\t\t\t\t\tif (matches$1(current, selector)) {\n\t\t\t\t\t\treadonly(e, 'currentTarget', current);\n\t\t\t\t\t\treadonly(e, 'delegateTarget', elem);\n\t\t\t\t\t\treturn handler(elem, e);\n\t\t\t\t\t}\n\t\t\t\t\tcurrent = current.parentNode;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\tfunction makeNormalHandler(elem, handler) {\n\t\t\treturn function (e) {\n\t\t\t\treadonly(e, 'delegateTarget', elem);\n\t\t\t\thandler(elem, e);\n\t\t\t};\n\t\t}\n\t\n\t\tfunction bindEvent(elem, event, handler) {\n\t\t\tvar parsed = parseEvent(event);\n\t\t\tvar name = parsed.name;\n\t\t\tvar selector = parsed.selector;\n\t\n\t\t\tvar capture = selector && (name === 'blur' || name === 'focus');\n\t\t\thandler = selector ? makeDelegateHandler(elem, handler, parsed) : makeNormalHandler(elem, handler);\n\t\t\telem.addEventListener(name, handler, capture);\n\t\t}\n\t\n\t\tfunction events$1(opts) {\n\t\t\tvar events = opts.events || {};\n\t\t\treturn function (elem) {\n\t\t\t\tfor (var name in events) {\n\t\t\t\t\tbindEvent(elem, name, events[name]);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\tvar patch$1 = patch;\n\t\n\t\tfunction createRenderer(Ctor) {\n\t\t\tvar render = Ctor.render;\n\t\n\t\t\treturn function (elem) {\n\t\t\t\tif (!render) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tif (!elem[shadowRoot]) {\n\t\t\t\t\tvar sr = void 0;\n\t\n\t\t\t\t\tif (shadowDomV1) {\n\t\t\t\t\t\tsr = elem.attachShadow({ mode: 'open' });\n\t\t\t\t\t} else if (shadowDomV0) {\n\t\t\t\t\t\tsr = elem.createShadowRoot();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsr = elem;\n\t\t\t\t\t}\n\t\n\t\t\t\t\telem[shadowRoot] = sr;\n\t\t\t\t}\n\t\n\t\t\t\tpatch$1(elem[shadowRoot], render, elem);\n\t\t\t};\n\t\t}\n\t\n\t\tfunction dashCase(str) {\n\t\t\treturn str.split(/([A-Z])/).reduce(function (one, two, idx) {\n\t\t\t\tvar dash = !one || idx % 2 === 0 ? '' : '-';\n\t\t\t\treturn '' + one + dash + two.toLowerCase();\n\t\t\t});\n\t\t}\n\t\n\t\tvar raf = window.requestAnimationFrame || setTimeout;\n\t\tfunction debounce(fn) {\n\t\t\tvar called = false;\n\t\n\t\t\treturn function () {\n\t\t\t\tvar _this = this;\n\t\n\t\t\t\tfor (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\t\targs[_key] = arguments[_key];\n\t\t\t\t}\n\t\n\t\t\t\tif (!called) {\n\t\t\t\t\tcalled = true;\n\t\t\t\t\traf(function () {\n\t\t\t\t\t\tcalled = false;\n\t\t\t\t\t\tfn.apply(_this, args);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\tvar CustomEvent = function (CustomEvent) {\n\t\t\tif (CustomEvent) {\n\t\t\t\ttry {\n\t\t\t\t\tnew CustomEvent();\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn CustomEvent;\n\t\t}(window.CustomEvent);\n\t\n\t\tfunction createCustomEvent(name) {\n\t\t\tvar opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\t\n\t\t\tif (CustomEvent) {\n\t\t\t\treturn new CustomEvent(name, opts);\n\t\t\t}\n\t\t\tvar e = document.createEvent('CustomEvent');\n\t\t\te.initCustomEvent(name, opts.bubbles, opts.cancelable, opts.detail);\n\t\t\treturn e;\n\t\t}\n\t\n\t\tfunction emit(elem, name) {\n\t\t\tvar opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\t\n\t\t\t/* jshint expr: true */\n\t\t\topts.bubbles === undefined && (opts.bubbles = true);\n\t\t\topts.cancelable === undefined && (opts.cancelable = true);\n\t\t\treturn elem.disabled ? true : elem.dispatchEvent(createCustomEvent(name, opts));\n\t\t}\n\t\n\t\tfunction getDefaultValue(elem, name, opts) {\n\t\t\treturn typeof opts.default === 'function' ? opts.default(elem, { name: name }) : opts.default;\n\t\t}\n\t\n\t\tfunction getInitialValue(elem, name, opts) {\n\t\t\treturn typeof opts.initial === 'function' ? opts.initial(elem, { name: name }) : opts.initial;\n\t\t}\n\t\n\t\tfunction createNativePropertyDefinition(name, opts) {\n\t\t\tvar prop = {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true\n\t\t\t};\n\t\n\t\t\tprop.created = function (elem) {\n\t\t\t\tvar propData = data(elem, 'api/property/' + name);\n\t\t\t\tvar attributeName = opts.attribute;\n\t\t\t\tvar initialValue = elem[name];\n\t\t\t\tvar shouldSyncAttribute = false;\n\t\n\t\t\t\t// Store property to attribute link information.\n\t\t\t\tdata(elem, 'attributeLinks')[attributeName] = name;\n\t\t\t\tdata(elem, 'propertyLinks')[name] = attributeName;\n\t\n\t\t\t\t// Set up initial value if it wasn't specified.\n\t\t\t\tif (empty(initialValue)) {\n\t\t\t\t\tif (attributeName && elem.hasAttribute(attributeName)) {\n\t\t\t\t\t\tinitialValue = opts.deserialize(elem.getAttribute(attributeName));\n\t\t\t\t\t} else if ('initial' in opts) {\n\t\t\t\t\t\tinitialValue = getInitialValue(elem, name, opts);\n\t\t\t\t\t\tshouldSyncAttribute = true;\n\t\t\t\t\t} else if ('default' in opts) {\n\t\t\t\t\t\tinitialValue = getDefaultValue(elem, name, opts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (shouldSyncAttribute) {\n\t\t\t\t\tprop.set.call(elem, initialValue);\n\t\t\t\t} else {\n\t\t\t\t\tpropData.internalValue = opts.coerce ? opts.coerce(initialValue) : initialValue;\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\tprop.get = function () {\n\t\t\t\tvar propData = data(this, 'api/property/' + name);\n\t\t\t\tvar internalValue = propData.internalValue;\n\t\n\t\t\t\tif (typeof opts.get === 'function') {\n\t\t\t\t\treturn opts.get(this, { name: name, internalValue: internalValue });\n\t\t\t\t}\n\t\t\t\treturn internalValue;\n\t\t\t};\n\t\n\t\t\tprop.render = function () {\n\t\t\t\tvar shouldUpdate = opts.render;\n\t\t\t\tif (typeof shouldUpdate === 'undefined') {\n\t\t\t\t\treturn function (elem, data) {\n\t\t\t\t\t\treturn data.newValue !== data.oldValue;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (typeof shouldUpdate === 'function') {\n\t\t\t\t\treturn shouldUpdate;\n\t\t\t\t}\n\t\t\t\treturn function () {\n\t\t\t\t\treturn !!shouldUpdate;\n\t\t\t\t};\n\t\t\t}();\n\t\n\t\t\tprop.set = function (newValue) {\n\t\t\t\tvar propData = data(this, 'api/property/' + name);\n\t\t\t\tvar oldValue = propData.oldValue;\n\t\n\t\t\t\tvar shouldRemoveAttribute = false;\n\t\n\t\t\t\tif (empty(oldValue)) {\n\t\t\t\t\toldValue = null;\n\t\t\t\t}\n\t\n\t\t\t\tif (empty(newValue)) {\n\t\t\t\t\tnewValue = getDefaultValue(this, name, opts);\n\t\t\t\t\tshouldRemoveAttribute = true;\n\t\t\t\t}\n\t\n\t\t\t\tif (typeof opts.coerce === 'function') {\n\t\t\t\t\tnewValue = opts.coerce(newValue);\n\t\t\t\t}\n\t\n\t\t\t\tvar propertyHasChanged = newValue !== oldValue;\n\t\t\t\tif (propertyHasChanged && opts.event) {\n\t\t\t\t\tvar canceled = !emit(this, String(opts.event), {\n\t\t\t\t\t\tbubbles: false,\n\t\t\t\t\t\tdetail: { name: name, oldValue: oldValue, newValue: newValue }\n\t\t\t\t\t});\n\t\n\t\t\t\t\tif (canceled) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tpropData.internalValue = newValue;\n\t\n\t\t\t\tvar changeData = { name: name, newValue: newValue, oldValue: oldValue };\n\t\n\t\t\t\tif (typeof opts.set === 'function') {\n\t\t\t\t\topts.set(this, changeData);\n\t\t\t\t}\n\t\n\t\t\t\t// Re-render on property updates if the should-update check passes.\n\t\t\t\tif (prop.render(this, changeData)) {\n\t\t\t\t\tvar deb = this[rendererDebounced] || (this[rendererDebounced] = debounce(this.constructor[renderer]));\n\t\t\t\t\tdeb(this);\n\t\t\t\t}\n\t\n\t\t\t\tpropData.oldValue = newValue;\n\t\n\t\t\t\t// Link up the attribute.\n\t\t\t\tvar attributeName = data(this, 'propertyLinks')[name];\n\t\t\t\tif (attributeName && !propData.settingAttribute) {\n\t\t\t\t\tvar serializedValue = opts.serialize(newValue);\n\t\t\t\t\tpropData.syncingAttribute = true;\n\t\t\t\t\tif (shouldRemoveAttribute || empty(serializedValue)) {\n\t\t\t\t\t\tthis.removeAttribute(attributeName);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.setAttribute(attributeName, serializedValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Allow the attribute to be linked again.\n\t\t\t\tpropData.settingAttribute = false;\n\t\t\t};\n\t\n\t\t\treturn prop;\n\t\t}\n\t\n\t\tfunction initProps(opts) {\n\t\t\topts = opts || {};\n\t\n\t\t\tif (typeof opts === 'function') {\n\t\t\t\topts = { coerce: opts };\n\t\t\t}\n\t\n\t\t\treturn function (name) {\n\t\t\t\treturn createNativePropertyDefinition(name, assign({\n\t\t\t\t\tdefault: null,\n\t\t\t\t\tdeserialize: function deserialize(value) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t},\n\t\t\t\t\tserialize: function serialize(value) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}, opts));\n\t\t\t};\n\t\t}\n\t\n\t\t// Ensures that definitions passed as part of the constructor are functions\n\t\t// that return property definitions used on the element.\n\t\tfunction ensurePropertyFunctions(Ctor) {\n\t\t\tvar props = Ctor.props;\n\t\t\tvar names = Object.keys(props || {});\n\t\t\treturn names.reduce(function (descriptors, descriptorName) {\n\t\t\t\tdescriptors[descriptorName] = props[descriptorName];\n\t\t\t\tif (typeof descriptors[descriptorName] !== 'function') {\n\t\t\t\t\tdescriptors[descriptorName] = initProps(descriptors[descriptorName]);\n\t\t\t\t}\n\t\t\t\treturn descriptors;\n\t\t\t}, {});\n\t\t}\n\t\n\t\t// Ensures the property definitions are transformed to objects that can be used\n\t\t// to create properties on the element.\n\t\tfunction ensurePropertyDefinitions(Ctor) {\n\t\t\tvar props = ensurePropertyFunctions(Ctor);\n\t\t\treturn Object.keys(props).reduce(function (descriptors, descriptorName) {\n\t\t\t\tdescriptors[descriptorName] = props[descriptorName](descriptorName);\n\t\t\t\treturn descriptors;\n\t\t\t}, {});\n\t\t}\n\t\n\t\t// Makes a function / constructor for the custom element that automates the\n\t\t// boilerplate of ensuring the parent constructor is called first and ensures\n\t\t// that the element is returned at the end.\n\t\tfunction createConstructor(name$$, Ctor) {\n\t\t\tif ((typeof Ctor === 'undefined' ? 'undefined' : babelHelpers.typeof(Ctor)) === 'object') {\n\t\t\t\tCtor = Component.extend(Ctor);\n\t\t\t}\n\t\n\t\t\t// Internal data.\n\t\t\tCtor[name] = name$$;\n\t\n\t\t\treturn Ctor;\n\t\t}\n\t\n\t\t// Ensures linked properties that have linked attributes are pre-formatted to\n\t\t// the attribute name in which they are linked.\n\t\tfunction formatLinkedAttributes(Ctor) {\n\t\t\tvar observedAttributes = Ctor.observedAttributes;\n\t\t\tvar props = Ctor.props;\n\t\n\t\t\tif (!props) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tObject.keys(props).forEach(function (name) {\n\t\t\t\tvar prop = props[name];\n\t\t\t\tvar attr = prop.attribute;\n\t\t\t\tif (attr) {\n\t\t\t\t\t// Ensure the property is updated.\n\t\t\t\t\tvar linkedAttr = prop.attribute = attr === true ? dashCase(name) : attr;\n\t\n\t\t\t\t\t// Automatically observe the attribute since they're linked from the\n\t\t\t\t\t// attributeChangedCallback.\n\t\t\t\t\tif (observedAttributes.indexOf(linkedAttr) === -1) {\n\t\t\t\t\t\tobservedAttributes.push(linkedAttr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\t// Merge observed attributes.\n\t\t\tObject.defineProperty(Ctor, 'observedAttributes', {\n\t\t\t\tget: function get() {\n\t\t\t\t\treturn observedAttributes;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\tfunction createInitProps(Ctor) {\n\t\t\tvar props = ensurePropertyDefinitions(Ctor);\n\t\n\t\t\treturn function (elem) {\n\t\t\t\tif (!props) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tObject.keys(props).forEach(function (name) {\n\t\t\t\t\tvar prop = props[name];\n\t\t\t\t\tprop.created(elem);\n\t\n\t\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=49739\n\t\t\t\t\t//\n\t\t\t\t\t// When Webkit fixes that bug so that native property accessors can be\n\t\t\t\t\t// retrieved, we can move defining the property to the prototype and away\n\t\t\t\t\t// from having to do if for every instance as all other browsers support\n\t\t\t\t\t// this.\n\t\t\t\t\tObject.defineProperty(elem, name, prop);\n\t\t\t\t});\n\t\t\t};\n\t\t}\n\t\n\t\tfunction define(name, Ctor) {\n\t\t\tCtor = createConstructor(name, Ctor);\n\t\t\tformatLinkedAttributes(Ctor);\n\t\n\t\t\tCtor[events] = events$1(Ctor);\n\t\t\tCtor[props] = createInitProps(Ctor);\n\t\t\tCtor[renderer] = createRenderer(Ctor);\n\t\n\t\t\tif (customElementsV0) {\n\t\t\t\treturn document.registerElement(name, Ctor);\n\t\t\t} else if (customElementsV1) {\n\t\t\t\twindow.customElements.define(name, Ctor, { extends: Ctor.extends });\n\t\t\t\treturn Ctor;\n\t\t\t} else {\n\t\t\t\tthrow new Error('Skate requires native custom element support or a polyfill.');\n\t\t\t}\n\t\t}\n\t\n\t\tfunction get(elem) {\n\t\t\tvar props = elem.constructor.props;\n\t\t\tvar state = {};\n\t\t\tfor (var key in props) {\n\t\t\t\tvar val = elem[key];\n\t\t\t\tif (typeof val !== 'undefined') {\n\t\t\t\t\tstate[key] = val;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn state;\n\t\t}\n\t\n\t\tfunction set(elem, newState) {\n\t\t\tassign(elem, newState);\n\t\t\tif (elem.constructor.render) {\n\t\t\t\telem.constructor[renderer](elem);\n\t\t\t}\n\t\t}\n\t\n\t\tfunction state(elem, newState) {\n\t\t\treturn typeof newState === 'undefined' ? get(elem) : set(elem, newState);\n\t\t}\n\t\n\t\tfunction getValue(elem) {\n\t\t\tvar type = elem.type;\n\t\t\tif (type === 'checkbox' || type === 'radio') {\n\t\t\t\treturn elem.checked ? elem.value || true : false;\n\t\t\t}\n\t\t\treturn elem.value;\n\t\t}\n\t\n\t\tfunction link(elem, target) {\n\t\t\treturn function (e) {\n\t\t\t\tvar value = getValue(e.target);\n\t\t\t\tvar localTarget = target || e.target.name || 'value';\n\t\n\t\t\t\tif (localTarget.indexOf('.') > -1) {\n\t\t\t\t\tvar parts = localTarget.split('.');\n\t\t\t\t\tvar firstPart = parts[0];\n\t\t\t\t\tvar propName = parts.pop();\n\t\t\t\t\tvar obj = parts.reduce(function (prev, curr) {\n\t\t\t\t\t\treturn prev && prev[curr];\n\t\t\t\t\t}, elem);\n\t\n\t\t\t\t\tobj[propName || e.target.name] = value;\n\t\t\t\t\tstate(elem, babelHelpers.defineProperty({}, firstPart, elem[firstPart]));\n\t\t\t\t} else {\n\t\t\t\t\tstate(elem, babelHelpers.defineProperty({}, localTarget, value));\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\tfunction ready(elem, done) {\n\t\t\tvar info = data(elem);\n\t\t\tif (elem.hasAttribute(elem.constructor.definedAttribute)) {\n\t\t\t\tdone(elem);\n\t\t\t} else if (info.readyCallbacks) {\n\t\t\t\tinfo.readyCallbacks.push(done);\n\t\t\t} else {\n\t\t\t\tinfo.readyCallbacks = [done];\n\t\t\t}\n\t\t}\n\t\n\t\texports.Component = Component;\n\t\texports.define = define;\n\t\texports.emit = emit;\n\t\texports.link = link;\n\t\texports.prop = prop;\n\t\texports.ready = ready;\n\t\texports.state = state;\n\t\texports.symbols = symbols;\n\t\texports.vdom = vdom;\n\t});\n\t//# sourceMappingURL=index.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\t(function () {\n\t    try {\n\t        cachedSetTimeout = setTimeout;\n\t    } catch (e) {\n\t        cachedSetTimeout = function cachedSetTimeout() {\n\t            throw new Error('setTimeout is not defined');\n\t        };\n\t    }\n\t    try {\n\t        cachedClearTimeout = clearTimeout;\n\t    } catch (e) {\n\t        cachedClearTimeout = function cachedClearTimeout() {\n\t            throw new Error('clearTimeout is not defined');\n\t        };\n\t    }\n\t})();\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = cachedSetTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while (len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    cachedClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        cachedSetTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () {\n\t    return '/';\n\t};\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function () {\n\t    return 0;\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _skatejs = __webpack_require__(2);\n\t\n\tvar _index = __webpack_require__(5);\n\t\n\tvar _index2 = _interopRequireDefault(_index);\n\t\n\tvar _elements = __webpack_require__(7);\n\t\n\tvar _elements2 = _interopRequireDefault(_elements);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar a = _elements2.default.a;\n\tvar div = _elements2.default.div;\n\tvar h1 = _elements2.default.h1;\n\tvar li = _elements2.default.li;\n\tvar style = _elements2.default.style;\n\tvar ul = _elements2.default.ul;\n\t\n\t\n\tfunction item(text) {\n\t  var href = arguments.length <= 1 || arguments[1] === undefined ? '#' : arguments[1];\n\t\n\t  li({ class: 'header-list-item' }, function () {\n\t    return a({ class: 'header-link', href: href }, text);\n\t  });\n\t}\n\t\n\texports.default = (0, _skatejs.define)('sk-header', {\n\t  props: {\n\t    title: _skatejs.prop.string()\n\t  },\n\t  render: function render(elem) {\n\t    style(_index2.default.toString());\n\t    div({ class: 'header' }, function () {\n\t      h1({ class: 'header-title' }, elem.title);\n\t      ul({ class: 'header-list-item' }, function () {\n\t        item('Docs');\n\t        item('Github');\n\t        item('Community');\n\t      });\n\t    });\n\t  }\n\t});\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(6)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".header{background-color:#333;color:#eee;height:60px}.header-list{list-style:none}.header-list,.header-list-item{display:inline-block;margin:0;padding:0}.header-title{display:inline-block;font-size:24px;line-height:24px;margin:-2px 0 0;padding:18px}.header-link{color:#eee;font-size:18px;margin:0;padding:20px;text-decoration:none}.header-link:hover{background-color:#444}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\n\t// css base code, injected by the css-loader\n\tmodule.exports = function () {\n\t\tvar list = [];\n\t\n\t\t// return the list of modules as css string\n\t\tlist.toString = function toString() {\n\t\t\tvar result = [];\n\t\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\t\tvar item = this[i];\n\t\t\t\tif (item[2]) {\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\n\t\t\t\t} else {\n\t\t\t\t\tresult.push(item[1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result.join(\"\");\n\t\t};\n\t\n\t\t// import a list of modules into the list\n\t\tlist.i = function (modules, mediaQuery) {\n\t\t\tif (typeof modules === \"string\") modules = [[null, modules, \"\"]];\n\t\t\tvar alreadyImportedModules = {};\n\t\t\tfor (var i = 0; i < this.length; i++) {\n\t\t\t\tvar id = this[i][0];\n\t\t\t\tif (typeof id === \"number\") alreadyImportedModules[id] = true;\n\t\t\t}\n\t\t\tfor (i = 0; i < modules.length; i++) {\n\t\t\t\tvar item = modules[i];\n\t\t\t\t// skip already imported module\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\t\tif (typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\t\tif (mediaQuery && !item[2]) {\n\t\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t\t} else if (mediaQuery) {\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t\t}\n\t\t\t\t\tlist.push(item);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\treturn list;\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _skatejs = __webpack_require__(2);\n\t\n\tvar specials = ['a', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ol', 'p', 'ul'];\n\t\n\texports.default = Object.getOwnPropertyNames(window).filter(function (name) {\n\t  return name.indexOf('HTML') === 0 && name.indexOf('Element') > 0;\n\t}).map(function (name) {\n\t  return name.replace(/^HTML/, '').replace(/Element$/, '');\n\t}).map(function (name) {\n\t  return name.toLowerCase();\n\t}).concat(specials).filter(function (name) {\n\t  return !!name;\n\t}).reduce(function (prev, curr) {\n\t  return (prev[curr] = _skatejs.vdom.element.bind(null, curr)) && prev;\n\t}, {});\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\texports.default = function (title) {\n\t  document.title = title;\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(6)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"html{font-family:Helvetica;font-size:14px}body{margin:0}a{color:#333}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/bundle.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0c72adc41a45b4a66a8b\n **/","import App from './app/index';\nimport css from './index.css';\ndocument.head.innerHTML += `<style>${css}</style>`;\nexport { App };\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","import { define, vdom } from 'skatejs';\nimport Header from '../header';\nimport title from '../_/title';\n\nexport default define('sk-app', {\n  render() {\n    title('SkateJS - functional web components');\n    vdom.element(Header, { title: 'SkateJS' });\n  },\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/index.js\n **/","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.skate = global.skate || {})));\n}(this, function (exports) {\n\n\tvar babelHelpers = {};\n\tbabelHelpers.typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t  return typeof obj;\n\t} : function (obj) {\n\t  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n\t};\n\n\tbabelHelpers.classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\n\tbabelHelpers.createClass = function () {\n\t  function defineProperties(target, props) {\n\t    for (var i = 0; i < props.length; i++) {\n\t      var descriptor = props[i];\n\t      descriptor.enumerable = descriptor.enumerable || false;\n\t      descriptor.configurable = true;\n\t      if (\"value\" in descriptor) descriptor.writable = true;\n\t      Object.defineProperty(target, descriptor.key, descriptor);\n\t    }\n\t  }\n\n\t  return function (Constructor, protoProps, staticProps) {\n\t    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n\t    if (staticProps) defineProperties(Constructor, staticProps);\n\t    return Constructor;\n\t  };\n\t}();\n\n\tbabelHelpers.defineProperty = function (obj, key, value) {\n\t  if (key in obj) {\n\t    Object.defineProperty(obj, key, {\n\t      value: value,\n\t      enumerable: true,\n\t      configurable: true,\n\t      writable: true\n\t    });\n\t  } else {\n\t    obj[key] = value;\n\t  }\n\n\t  return obj;\n\t};\n\n\tbabelHelpers.inherits = function (subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t  }\n\n\t  subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      enumerable: false,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t};\n\n\tbabelHelpers.possibleConstructorReturn = function (self, call) {\n\t  if (!self) {\n\t    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n\t  }\n\n\t  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n\t};\n\n\tbabelHelpers;\n\n\n\tfunction __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports), module.exports; }\n\n\tvar index = __commonjs(function (module) {\n\t'use strict';\n\t/* eslint-disable no-unused-vars */\n\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\n\tfunction toObject(val) {\n\t\tif (val === null || val === undefined) {\n\t\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t\t}\n\n\t\treturn Object(val);\n\t}\n\n\tfunction shouldUseNative() {\n\t\ttry {\n\t\t\tif (!Object.assign) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\t\tvar test1 = new String('abc'); // eslint-disable-line\n\t\t\ttest1[5] = 'de';\n\t\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\t\tvar test2 = {};\n\t\t\tfor (var i = 0; i < 10; i++) {\n\t\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t\t}\n\t\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\t\treturn test2[n];\n\t\t\t});\n\t\t\tif (order2.join('') !== '0123456789') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\t\tvar test3 = {};\n\t\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\t\ttest3[letter] = letter;\n\t\t\t});\n\t\t\tif (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch (e) {\n\t\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\t\tvar from;\n\t\tvar to = toObject(target);\n\t\tvar symbols;\n\n\t\tfor (var s = 1; s < arguments.length; s++) {\n\t\t\tfrom = Object(arguments[s]);\n\n\t\t\tfor (var key in from) {\n\t\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\t\tto[key] = from[key];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Object.getOwnPropertySymbols) {\n\t\t\t\tsymbols = Object.getOwnPropertySymbols(from);\n\t\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn to;\n\t};\n\t});\n\n\tvar assign = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);\n\n\tfunction empty (val) {\n\t  return typeof val === 'undefined' || val === null;\n\t}\n\n\tvar alwaysUndefinedIfEmptyOrNumber = function alwaysUndefinedIfEmptyOrNumber(val) {\n\t  return empty(val) ? undefined : Number(val);\n\t};\n\tvar alwaysUndefinedIfEmptyOrString = function alwaysUndefinedIfEmptyOrString(val) {\n\t  return empty(val) ? undefined : String(val);\n\t};\n\n\tfunction create(def) {\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\n\t    args.unshift({}, def);\n\t    return assign.apply(null, args);\n\t  };\n\t}\n\n\tvar array = create({\n\t  coerce: function coerce(val) {\n\t    return Array.isArray(val) ? val : [val];\n\t  },\n\t  default: function _default() {\n\t    return [];\n\t  },\n\t  deserialize: JSON.parse,\n\t  serialize: JSON.stringify\n\t});\n\n\tvar boolean = create({\n\t  coerce: function coerce(value) {\n\t    return !!value;\n\t  },\n\t  default: false,\n\t  deserialize: function deserialize(value) {\n\t    return !(value === null);\n\t  },\n\t  serialize: function serialize(value) {\n\t    return value ? '' : undefined;\n\t  }\n\t});\n\n\tvar number = create({\n\t  coerce: alwaysUndefinedIfEmptyOrNumber,\n\t  deserialize: alwaysUndefinedIfEmptyOrNumber,\n\t  serialize: alwaysUndefinedIfEmptyOrNumber\n\t});\n\n\tvar string = create({\n\t  coerce: alwaysUndefinedIfEmptyOrString,\n\t  deserialize: alwaysUndefinedIfEmptyOrString,\n\t  serialize: alwaysUndefinedIfEmptyOrString\n\t});\n\nvar prop = Object.freeze({\n\t  create: create,\n\t  array: array,\n\t  boolean: boolean,\n\t  number: number,\n\t  string: string\n\t});\n\n\tvar created = '____created';\n\tvar events = '____events';\n\tvar name = '____name';\n\tvar props = '____props';\n\tvar renderer = '____renderer';\n\tvar rendererDebounced = '____rendererDebounced';\n\tvar shadowRoot = '____shadowRoot';\n\nvar symbols = Object.freeze({\n\t\tcreated: created,\n\t\tevents: events,\n\t\tname: name,\n\t\tprops: props,\n\t\trenderer: renderer,\n\t\trendererDebounced: rendererDebounced,\n\t\tshadowRoot: shadowRoot\n\t});\n\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\n\t/**\n\t * A cached reference to the hasOwnProperty function.\n\t */\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\t/**\n\t * A cached reference to the create function.\n\t */\n\tvar create$1 = Object.create;\n\n\t/**\n\t * Used to prevent property collisions between our \"map\" and its prototype.\n\t * @param {!Object<string, *>} map The map to check.\n\t * @param {string} property The property to check.\n\t * @return {boolean} Whether map has property.\n\t */\n\tvar has = function has(map, property) {\n\t  return hasOwnProperty.call(map, property);\n\t};\n\n\t/**\n\t * Creates an map object without a prototype.\n\t * @return {!Object}\n\t */\n\tvar createMap = function createMap() {\n\t  return create$1(null);\n\t};\n\n\t/**\n\t * Keeps track of information needed to perform diffs for a given DOM node.\n\t * @param {!string} nodeName\n\t * @param {?string=} key\n\t * @constructor\n\t */\n\tfunction NodeData(nodeName, key) {\n\t  /**\n\t   * The attributes and their values.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.attrs = createMap();\n\n\t  /**\n\t   * An array of attribute name/value pairs, used for quickly diffing the\n\t   * incomming attributes to see if the DOM node's attributes need to be\n\t   * updated.\n\t   * @const {Array<*>}\n\t   */\n\t  this.attrsArr = [];\n\n\t  /**\n\t   * The incoming attributes for this Node, before they are updated.\n\t   * @const {!Object<string, *>}\n\t   */\n\t  this.newAttrs = createMap();\n\n\t  /**\n\t   * The key used to identify this node, used to preserve DOM nodes when they\n\t   * move within their parent.\n\t   * @const\n\t   */\n\t  this.key = key;\n\n\t  /**\n\t   * Keeps track of children within this node by their key.\n\t   * {?Object<string, !Element>}\n\t   */\n\t  this.keyMap = null;\n\n\t  /**\n\t   * Whether or not the keyMap is currently valid.\n\t   * {boolean}\n\t   */\n\t  this.keyMapValid = true;\n\n\t  /**\n\t   * The node name for this node.\n\t   * @const {string}\n\t   */\n\t  this.nodeName = nodeName;\n\n\t  /**\n\t   * @type {?string}\n\t   */\n\t  this.text = null;\n\t}\n\n\t/**\n\t * Initializes a NodeData object for a Node.\n\t *\n\t * @param {Node} node The node to initialize data for.\n\t * @param {string} nodeName The node name of node.\n\t * @param {?string=} key The key that identifies the node.\n\t * @return {!NodeData} The newly initialized data object\n\t */\n\tvar initData = function initData(node, nodeName, key) {\n\t  var data = new NodeData(nodeName, key);\n\t  node['__incrementalDOMData'] = data;\n\t  return data;\n\t};\n\n\t/**\n\t * Retrieves the NodeData object for a Node, creating it if necessary.\n\t *\n\t * @param {Node} node The node to retrieve the data for.\n\t * @return {!NodeData} The NodeData for this Node.\n\t */\n\tvar getData = function getData(node) {\n\t  var data = node['__incrementalDOMData'];\n\n\t  if (!data) {\n\t    var nodeName = node.nodeName.toLowerCase();\n\t    var key = null;\n\n\t    if (node instanceof Element) {\n\t      key = node.getAttribute('key');\n\t    }\n\n\t    data = initData(node, nodeName, key);\n\t  }\n\n\t  return data;\n\t};\n\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\n\t/** @const */\n\tvar symbols$2 = {\n\t  default: '__default',\n\n\t  placeholder: '__placeholder'\n\t};\n\n\t/**\n\t * @param {string} name\n\t * @return {string|undefined} The namespace to use for the attribute.\n\t */\n\tvar getNamespace = function getNamespace(name) {\n\t  if (name.lastIndexOf('xml:', 0) === 0) {\n\t    return 'http://www.w3.org/XML/1998/namespace';\n\t  }\n\n\t  if (name.lastIndexOf('xlink:', 0) === 0) {\n\t    return 'http://www.w3.org/1999/xlink';\n\t  }\n\t};\n\n\t/**\n\t * Applies an attribute or property to a given Element. If the value is null\n\t * or undefined, it is removed from the Element. Otherwise, the value is set\n\t * as an attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {?(boolean|number|string)=} value The attribute's value.\n\t */\n\tvar applyAttr = function applyAttr(el, name, value) {\n\t  if (value == null) {\n\t    el.removeAttribute(name);\n\t  } else {\n\t    var attrNS = getNamespace(name);\n\t    if (attrNS) {\n\t      el.setAttributeNS(attrNS, name, value);\n\t    } else {\n\t      el.setAttribute(name, value);\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Applies a property to a given Element.\n\t * @param {!Element} el\n\t * @param {string} name The property's name.\n\t * @param {*} value The property's value.\n\t */\n\tvar applyProp$1 = function applyProp(el, name, value) {\n\t  el[name] = value;\n\t};\n\n\t/**\n\t * Applies a style to an Element. No vendor prefix expansion is done for\n\t * property names/values.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} style The style to set. Either a string of css or an object\n\t *     containing property-value pairs.\n\t */\n\tvar applyStyle = function applyStyle(el, name, style) {\n\t  if (typeof style === 'string') {\n\t    el.style.cssText = style;\n\t  } else {\n\t    el.style.cssText = '';\n\t    var elStyle = el.style;\n\t    var obj = /** @type {!Object<string,string>} */style;\n\n\t    for (var prop in obj) {\n\t      if (has(obj, prop)) {\n\t        elStyle[prop] = obj[prop];\n\t      }\n\t    }\n\t  }\n\t};\n\n\t/**\n\t * Updates a single attribute on an Element.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value. If the value is an object or\n\t *     function it is set on the Element, otherwise, it is set as an HTML\n\t *     attribute.\n\t */\n\tvar applyAttributeTyped = function applyAttributeTyped(el, name, value) {\n\t  var type = typeof value === 'undefined' ? 'undefined' : babelHelpers.typeof(value);\n\n\t  if (type === 'object' || type === 'function') {\n\t    applyProp$1(el, name, value);\n\t  } else {\n\t    applyAttr(el, name, /** @type {?(boolean|number|string)} */value);\n\t  }\n\t};\n\n\t/**\n\t * Calls the appropriate attribute mutator for this attribute.\n\t * @param {!Element} el\n\t * @param {string} name The attribute's name.\n\t * @param {*} value The attribute's value.\n\t */\n\tvar updateAttribute = function updateAttribute(el, name, value) {\n\t  var data = getData(el);\n\t  var attrs = data.attrs;\n\n\t  if (attrs[name] === value) {\n\t    return;\n\t  }\n\n\t  var mutator = attributes$1[name] || attributes$1[symbols$2.default];\n\t  mutator(el, name, value);\n\n\t  attrs[name] = value;\n\t};\n\n\t/**\n\t * A publicly mutable object to provide custom mutators for attributes.\n\t * @const {!Object<string, function(!Element, string, *)>}\n\t */\n\tvar attributes$1 = createMap();\n\n\t// Special generic mutator that's called for any attribute that does not\n\t// have a specific mutator.\n\tattributes$1[symbols$2.default] = applyAttributeTyped;\n\n\tattributes$1[symbols$2.placeholder] = function () {};\n\n\tattributes$1['style'] = applyStyle;\n\n\t/**\n\t * Gets the namespace to create an element (of a given tag) in.\n\t * @param {string} tag The tag to get the namespace for.\n\t * @param {?Node} parent\n\t * @return {?string} The namespace to create the tag in.\n\t */\n\tvar getNamespaceForTag = function getNamespaceForTag(tag, parent) {\n\t  if (tag === 'svg') {\n\t    return 'http://www.w3.org/2000/svg';\n\t  }\n\n\t  if (getData(parent).nodeName === 'foreignObject') {\n\t    return null;\n\t  }\n\n\t  return parent.namespaceURI;\n\t};\n\n\t/**\n\t * Creates an Element.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @param {?Node} parent\n\t * @param {string} tag The tag for the Element.\n\t * @param {?string=} key A key to identify the Element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element.\n\t * @return {!Element}\n\t */\n\tvar createElement = function createElement(doc, parent, tag, key, statics) {\n\t  var namespace = getNamespaceForTag(tag, parent);\n\t  var el = void 0;\n\n\t  if (namespace) {\n\t    el = doc.createElementNS(namespace, tag);\n\t  } else {\n\t    el = doc.createElement(tag);\n\t  }\n\n\t  initData(el, tag, key);\n\n\t  if (statics) {\n\t    for (var i = 0; i < statics.length; i += 2) {\n\t      updateAttribute(el, /** @type {!string}*/statics[i], statics[i + 1]);\n\t    }\n\t  }\n\n\t  return el;\n\t};\n\n\t/**\n\t * Creates a Text Node.\n\t * @param {Document} doc The document with which to create the Element.\n\t * @return {!Text}\n\t */\n\tvar createText = function createText(doc) {\n\t  var node = doc.createTextNode('');\n\t  initData(node, '#text', null);\n\t  return node;\n\t};\n\n\t/**\n\t * Creates a mapping that can be used to look up children using a key.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Element>} A mapping of keys to the children of the\n\t *     Element.\n\t */\n\tvar createKeyMap = function createKeyMap(el) {\n\t  var map = createMap();\n\t  var child = el.firstElementChild;\n\n\t  while (child) {\n\t    var key = getData(child).key;\n\n\t    if (key) {\n\t      map[key] = child;\n\t    }\n\n\t    child = child.nextElementSibling;\n\t  }\n\n\t  return map;\n\t};\n\n\t/**\n\t * Retrieves the mapping of key to child node for a given Element, creating it\n\t * if necessary.\n\t * @param {?Node} el\n\t * @return {!Object<string, !Node>} A mapping of keys to child Elements\n\t */\n\tvar getKeyMap = function getKeyMap(el) {\n\t  var data = getData(el);\n\n\t  if (!data.keyMap) {\n\t    data.keyMap = createKeyMap(el);\n\t  }\n\n\t  return data.keyMap;\n\t};\n\n\t/**\n\t * Retrieves a child from the parent with the given key.\n\t * @param {?Node} parent\n\t * @param {?string=} key\n\t * @return {?Node} The child corresponding to the key.\n\t */\n\tvar getChild = function getChild(parent, key) {\n\t  return key ? getKeyMap(parent)[key] : null;\n\t};\n\n\t/**\n\t * Registers an element as being a child. The parent will keep track of the\n\t * child using the key. The child can be retrieved using the same key using\n\t * getKeyMap. The provided key should be unique within the parent Element.\n\t * @param {?Node} parent The parent of child.\n\t * @param {string} key A key to identify the child with.\n\t * @param {!Node} child The child to register.\n\t */\n\tvar registerChild = function registerChild(parent, key, child) {\n\t  getKeyMap(parent)[key] = child;\n\t};\n\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\n\t/** @const */\n\tvar notifications = {\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been created\n\t   * and added to the DOM.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesCreated: null,\n\n\t  /**\n\t   * Called after patch has compleated with any Nodes that have been removed\n\t   * from the DOM.\n\t   * Note it's an applications responsibility to handle any childNodes.\n\t   * @type {?function(Array<!Node>)}\n\t   */\n\t  nodesDeleted: null\n\t};\n\n\t/**\n\t * Keeps track of the state of a patch.\n\t * @constructor\n\t */\n\tfunction Context() {\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.created = notifications.nodesCreated && [];\n\n\t  /**\n\t   * @type {(Array<!Node>|undefined)}\n\t   */\n\t  this.deleted = notifications.nodesDeleted && [];\n\t}\n\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markCreated = function (node) {\n\t  if (this.created) {\n\t    this.created.push(node);\n\t  }\n\t};\n\n\t/**\n\t * @param {!Node} node\n\t */\n\tContext.prototype.markDeleted = function (node) {\n\t  if (this.deleted) {\n\t    this.deleted.push(node);\n\t  }\n\t};\n\n\t/**\n\t * Notifies about nodes that were created during the patch opearation.\n\t */\n\tContext.prototype.notifyChanges = function () {\n\t  if (this.created && this.created.length > 0) {\n\t    notifications.nodesCreated(this.created);\n\t  }\n\n\t  if (this.deleted && this.deleted.length > 0) {\n\t    notifications.nodesDeleted(this.deleted);\n\t  }\n\t};\n\n\t/**\n\t * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS-IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\n\t/**\n\t  * Keeps track whether or not we are in an attributes declaration (after\n\t  * elementOpenStart, but before elementOpenEnd).\n\t  * @type {boolean}\n\t  */\n\tvar inAttributes = false;\n\n\t/**\n\t  * Keeps track whether or not we are in an element that should not have its\n\t  * children cleared.\n\t  * @type {boolean}\n\t  */\n\tvar inSkip = false;\n\n\t/**\n\t * Makes sure that there is a current patch context.\n\t * @param {*} context\n\t */\n\tvar assertInPatch = function assertInPatch(context) {\n\t  if (!context) {\n\t    throw new Error('Cannot call currentElement() unless in patch.');\n\t  }\n\t};\n\n\t/**\n\t* Makes sure that keyed Element matches the tag name provided.\n\t* @param {!string} nodeName The nodeName of the node that is being matched.\n\t* @param {string=} tag The tag name of the Element.\n\t* @param {?string=} key The key of the Element.\n\t*/\n\tvar assertKeyedTagMatches = function assertKeyedTagMatches(nodeName, tag, key) {\n\t  if (nodeName !== tag) {\n\t    throw new Error('Was expecting node with key \"' + key + '\" to be a ' + tag + ', not a ' + nodeName + '.');\n\t  }\n\t};\n\n\t/**\n\t * Makes sure that a patch closes every node that it opened.\n\t * @param {?Node} openElement\n\t * @param {!Node|!DocumentFragment} root\n\t */\n\tvar assertNoUnclosedTags = function assertNoUnclosedTags(openElement, root) {\n\t  if (openElement === root) {\n\t    return;\n\t  }\n\n\t  var currentElement = openElement;\n\t  var openTags = [];\n\t  while (currentElement && currentElement !== root) {\n\t    openTags.push(currentElement.nodeName.toLowerCase());\n\t    currentElement = currentElement.parentNode;\n\t  }\n\n\t  throw new Error('One or more tags were not closed:\\n' + openTags.join('\\n'));\n\t};\n\n\t/**\n\t * Makes sure that the caller is not where attributes are expected.\n\t * @param {string} functionName\n\t */\n\tvar assertNotInAttributes = function assertNotInAttributes(functionName) {\n\t  if (inAttributes) {\n\t    throw new Error(functionName + '() can not be called between ' + 'elementOpenStart() and elementOpenEnd().');\n\t  }\n\t};\n\n\t/**\n\t * Makes sure that the caller is not inside an element that has declared skip.\n\t * @param {string} functionName\n\t */\n\tvar assertNotInSkip = function assertNotInSkip(functionName) {\n\t  if (inSkip) {\n\t    throw new Error(functionName + '() may not be called inside an element ' + 'that has called skip().');\n\t  }\n\t};\n\n\t/**\n\t * Makes sure that the caller is where attributes are expected.\n\t * @param {string} functionName\n\t */\n\tvar assertInAttributes = function assertInAttributes(functionName) {\n\t  if (!inAttributes) {\n\t    throw new Error(functionName + '() can only be called after calling ' + 'elementOpenStart().');\n\t  }\n\t};\n\n\t/**\n\t * Makes sure the patch closes virtual attributes call\n\t */\n\tvar assertVirtualAttributesClosed = function assertVirtualAttributesClosed() {\n\t  if (inAttributes) {\n\t    throw new Error('elementOpenEnd() must be called after calling ' + 'elementOpenStart().');\n\t  }\n\t};\n\n\t/**\n\t  * Makes sure that placeholders have a key specified. Otherwise, conditional\n\t  * placeholders and conditional elements next to placeholders will cause\n\t  * placeholder elements to be re-used as non-placeholders and vice versa.\n\t  * @param {string} key\n\t  */\n\tvar assertPlaceholderKeySpecified = function assertPlaceholderKeySpecified(key) {\n\t  if (!key) {\n\t    throw new Error('elementPlaceholder() requires a key.');\n\t  }\n\t};\n\n\t/**\n\t  * Makes sure that tags are correctly nested.\n\t  * @param {string} nodeName\n\t  * @param {string} tag\n\t  */\n\tvar assertCloseMatchesOpenTag = function assertCloseMatchesOpenTag(nodeName, tag) {\n\t  if (nodeName !== tag) {\n\t    throw new Error('Received a call to close \"' + tag + '\" but \"' + nodeName + '\" was open.');\n\t  }\n\t};\n\n\t/**\n\t * Makes sure that no children elements have been declared yet in the current\n\t * element.\n\t * @param {string} functionName\n\t * @param {?Node} previousNode\n\t */\n\tvar assertNoChildrenDeclaredYet = function assertNoChildrenDeclaredYet(functionName, previousNode) {\n\t  if (previousNode !== null) {\n\t    throw new Error(functionName + '() must come before any child ' + 'declarations inside the current element.');\n\t  }\n\t};\n\n\t/**\n\t * Checks that a call to patchOuter actually patched the element.\n\t * @param {?Node} node The node requested to be patched.\n\t * @param {?Node} currentNode The currentNode after the patch.\n\t */\n\tvar assertPatchElementNotEmpty = function assertPatchElementNotEmpty(node, currentNode) {\n\t  if (node === currentNode) {\n\t    throw new Error('There must be exactly one top level call corresponding ' + 'to the patched element.');\n\t  }\n\t};\n\n\t/**\n\t * Checks that a call to patchOuter actually patched the element.\n\t * @param {?Node} node The node requested to be patched.\n\t * @param {?Node} previousNode The previousNode after the patch.\n\t */\n\tvar assertPatchElementNoExtras = function assertPatchElementNoExtras(node, previousNode) {\n\t  if (node !== previousNode) {\n\t    throw new Error('There must be exactly one top level call corresponding ' + 'to the patched element.');\n\t  }\n\t};\n\n\t/**\n\t * Updates the state of being in an attribute declaration.\n\t * @param {boolean} value\n\t * @return {boolean} the previous value.\n\t */\n\tvar setInAttributes = function setInAttributes(value) {\n\t  var previous = inAttributes;\n\t  inAttributes = value;\n\t  return previous;\n\t};\n\n\t/**\n\t * Updates the state of being in a skip element.\n\t * @param {boolean} value\n\t * @return {boolean} the previous value.\n\t */\n\tvar setInSkip = function setInSkip(value) {\n\t  var previous = inSkip;\n\t  inSkip = value;\n\t  return previous;\n\t};\n\n\t/** @type {?Context} */\n\tvar context = null;\n\n\t/** @type {?Node} */\n\tvar currentNode = void 0;\n\n\t/** @type {?Node} */\n\tvar currentParent = void 0;\n\n\t/** @type {?Element|?DocumentFragment} */\n\tvar root = void 0;\n\n\t/** @type {?Document} */\n\tvar doc = void 0;\n\n\t/**\n\t * Sets up and restores a patch context, running the patch function with the\n\t * provided data.\n\t * @param {!Element|!DocumentFragment} node The Element or Document\n\t *     where the patch should start.\n\t * @param {!function(T)} fn The patching function.\n\t * @param {T=} data An argument passed to fn.\n\t * @template T\n\t */\n\tvar runPatch = function runPatch(node, fn, data) {\n\t  var prevContext = context;\n\t  var prevRoot = root;\n\t  var prevDoc = doc;\n\t  var prevCurrentNode = currentNode;\n\t  var prevCurrentParent = currentParent;\n\t  var previousInAttributes = false;\n\t  var previousInSkip = false;\n\n\t  context = new Context();\n\t  root = node;\n\t  doc = node.ownerDocument;\n\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    previousInAttributes = setInAttributes(false);\n\t    previousInSkip = setInSkip(false);\n\t  }\n\n\t  fn(data);\n\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertVirtualAttributesClosed();\n\t    setInAttributes(previousInAttributes);\n\t    setInSkip(previousInSkip);\n\t  }\n\n\t  context.notifyChanges();\n\n\t  context = prevContext;\n\t  root = prevRoot;\n\t  doc = prevDoc;\n\t  currentNode = prevCurrentNode;\n\t  currentParent = prevCurrentParent;\n\t};\n\n\t/**\n\t * Patches the document starting at node with the provided function. This\n\t * function may be called during an existing patch operation.\n\t * @param {!Element|!DocumentFragment} node The Element or Document\n\t *     to patch.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patch = function patchInner(node, fn, data) {\n\t  runPatch(node, function (data) {\n\t    currentNode = node;\n\t    currentParent = node.parentNode;\n\n\t    enterNode();\n\t    fn(data);\n\t    exitNode();\n\n\t    if (process.env.NODE_ENV !== 'production') {\n\t      assertNoUnclosedTags(currentNode, node);\n\t    }\n\t  }, data);\n\t};\n\n\t/**\n\t * Patches an Element with the the provided function. Exactly one top level\n\t * element call should be made corresponding to `node`.\n\t * @param {!Element} node The Element where the patch should start.\n\t * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n\t *     calls that describe the DOM. This should have at most one top level\n\t *     element call.\n\t * @param {T=} data An argument passed to fn to represent DOM state.\n\t * @template T\n\t */\n\tvar patchOuter = function patchOuter(node, fn, data) {\n\t  runPatch(node, function (data) {\n\t    currentNode = /** @type {!Element} */{ nextSibling: node };\n\t    currentParent = node.parentNode;\n\n\t    fn(data);\n\n\t    if (process.env.NODE_ENV !== 'production') {\n\t      assertPatchElementNotEmpty(node, currentNode.nextSibling);\n\t      assertPatchElementNoExtras(node, currentNode);\n\t    }\n\t  }, data);\n\t};\n\n\t/**\n\t * Checks whether or not the current node matches the specified nodeName and\n\t * key.\n\t *\n\t * @param {?string} nodeName The nodeName for this node.\n\t * @param {?string=} key An optional key that identifies a node.\n\t * @return {boolean} True if the node matches, false otherwise.\n\t */\n\tvar matches = function matches(nodeName, key) {\n\t  var data = getData(currentNode);\n\n\t  // Key check is done using double equals as we want to treat a null key the\n\t  // same as undefined. This should be okay as the only values allowed are\n\t  // strings, null and undefined so the == semantics are not too weird.\n\t  return nodeName === data.nodeName && key == data.key;\n\t};\n\n\t/**\n\t * Aligns the virtual Element definition with the actual DOM, moving the\n\t * corresponding DOM node to the correct location or creating it if necessary.\n\t * @param {string} nodeName For an Element, this should be a valid tag string.\n\t *     For a Text, this should be #text.\n\t * @param {?string=} key The key used to identify this element.\n\t * @param {?Array<*>=} statics For an Element, this should be an array of\n\t *     name-value pairs.\n\t */\n\tvar alignWithDOM = function alignWithDOM(nodeName, key, statics) {\n\t  if (currentNode && matches(nodeName, key)) {\n\t    return;\n\t  }\n\n\t  var node = void 0;\n\n\t  // Check to see if the node has moved within the parent.\n\t  if (key) {\n\t    node = getChild(currentParent, key);\n\t    if (node && process.env.NODE_ENV !== 'production') {\n\t      assertKeyedTagMatches(getData(node).nodeName, nodeName, key);\n\t    }\n\t  }\n\n\t  // Create the node if it doesn't exist.\n\t  if (!node) {\n\t    if (nodeName === '#text') {\n\t      node = createText(doc);\n\t    } else {\n\t      node = createElement(doc, currentParent, nodeName, key, statics);\n\t    }\n\n\t    if (key) {\n\t      registerChild(currentParent, key, node);\n\t    }\n\n\t    context.markCreated(node);\n\t  }\n\n\t  // If the node has a key, remove it from the DOM to prevent a large number\n\t  // of re-orders in the case that it moved far or was completely removed.\n\t  // Since we hold on to a reference through the keyMap, we can always add it\n\t  // back.\n\t  if (currentNode && getData(currentNode).key) {\n\t    currentParent.replaceChild(node, currentNode);\n\t    getData(currentParent).keyMapValid = false;\n\t  } else {\n\t    currentParent.insertBefore(node, currentNode);\n\t  }\n\n\t  currentNode = node;\n\t};\n\n\t/**\n\t * Clears out any unvisited Nodes, as the corresponding virtual element\n\t * functions were never called for them.\n\t */\n\tvar clearUnvisitedDOM = function clearUnvisitedDOM() {\n\t  var node = currentParent;\n\t  var data = getData(node);\n\t  var keyMap = data.keyMap;\n\t  var keyMapValid = data.keyMapValid;\n\t  var child = node.lastChild;\n\t  var key = void 0;\n\n\t  if (child === currentNode && keyMapValid) {\n\t    return;\n\t  }\n\n\t  if (data.attrs[symbols$2.placeholder] && node !== root) {\n\t    if (process.env.NODE_ENV !== 'production') {\n\t      console.warn('symbols.placeholder will be removed in Incremental DOM' + ' 0.5 use skip() instead');\n\t    }\n\t    return;\n\t  }\n\n\t  while (child !== currentNode) {\n\t    node.removeChild(child);\n\t    context.markDeleted( /** @type {!Node}*/child);\n\n\t    key = getData(child).key;\n\t    if (key) {\n\t      delete keyMap[key];\n\t    }\n\t    child = node.lastChild;\n\t  }\n\n\t  // Clean the keyMap, removing any unusued keys.\n\t  if (!keyMapValid) {\n\t    for (key in keyMap) {\n\t      child = keyMap[key];\n\t      if (child.parentNode !== node) {\n\t        context.markDeleted(child);\n\t        delete keyMap[key];\n\t      }\n\t    }\n\n\t    data.keyMapValid = true;\n\t  }\n\t};\n\n\t/**\n\t * Changes to the first child of the current node.\n\t */\n\tvar enterNode = function enterNode() {\n\t  currentParent = currentNode;\n\t  currentNode = null;\n\t};\n\n\t/**\n\t * Changes to the next sibling of the current node.\n\t */\n\tvar nextNode = function nextNode() {\n\t  if (currentNode) {\n\t    currentNode = currentNode.nextSibling;\n\t  } else {\n\t    currentNode = currentParent.firstChild;\n\t  }\n\t};\n\n\t/**\n\t * Changes to the parent of the current node, removing any unvisited children.\n\t */\n\tvar exitNode = function exitNode() {\n\t  clearUnvisitedDOM();\n\n\t  currentNode = currentParent;\n\t  currentParent = currentParent.parentNode;\n\t};\n\n\t/**\n\t * Makes sure that the current node is an Element with a matching tagName and\n\t * key.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementOpen = function elementOpen(tag, key, statics) {\n\t  nextNode();\n\t  alignWithDOM(tag, key, statics);\n\t  enterNode();\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\n\t/**\n\t * Closes the currently open Element, removing any unvisited children if\n\t * necessary.\n\t *\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar coreElementClose = function elementClose() {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    setInSkip(false);\n\t  }\n\n\t  exitNode();\n\t  return (/** @type {!Element} */currentNode\n\t  );\n\t};\n\n\t/**\n\t * Makes sure the current node is a Text node and creates a Text node if it is\n\t * not.\n\t *\n\t * @return {!Text} The corresponding Text Node.\n\t */\n\tvar coreText = function text() {\n\t  nextNode();\n\t  alignWithDOM('#text', null, null);\n\t  return (/** @type {!Text} */currentNode\n\t  );\n\t};\n\n\t/**\n\t * Gets the current Element being patched.\n\t * @return {!Element}\n\t */\n\tvar currentElement = function currentElement() {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertInPatch(context);\n\t    assertNotInAttributes('currentElement');\n\t  }\n\t  return (/** @type {!Element} */currentParent\n\t  );\n\t};\n\n\t/**\n\t * Skips the children in a subtree, allowing an Element to be closed without\n\t * clearing out the children.\n\t */\n\tvar skip$1 = function skip() {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNoChildrenDeclaredYet('skip', currentNode);\n\t    setInSkip(true);\n\t  }\n\t  currentNode = currentParent.lastChild;\n\t};\n\n\t/**\n\t * The offset in the virtual element declaration where the attributes are\n\t * specified.\n\t * @const\n\t */\n\tvar ATTRIBUTES_OFFSET = 3;\n\n\t/**\n\t * Builds an array of arguments for use with elementOpenStart, attr and\n\t * elementOpenEnd.\n\t * @const {Array<*>}\n\t */\n\tvar argsBuilder = [];\n\n\t/**\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpen$1 = function elementOpen(tag, key, statics, const_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes('elementOpen');\n\t    assertNotInSkip('elementOpen');\n\t  }\n\n\t  var node = coreElementOpen(tag, key, statics);\n\t  var data = getData(node);\n\n\t  /*\n\t   * Checks to see if one or more attributes have changed for a given Element.\n\t   * When no attributes have changed, this is much faster than checking each\n\t   * individual argument. When attributes have changed, the overhead of this is\n\t   * minimal.\n\t   */\n\t  var attrsArr = data.attrsArr;\n\t  var newAttrs = data.newAttrs;\n\t  var attrsChanged = false;\n\t  var i = ATTRIBUTES_OFFSET;\n\t  var j = 0;\n\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    if (attrsArr[j] !== arguments[i]) {\n\t      attrsChanged = true;\n\t      break;\n\t    }\n\t  }\n\n\t  for (; i < arguments.length; i += 1, j += 1) {\n\t    attrsArr[j] = arguments[i];\n\t  }\n\n\t  if (j < attrsArr.length) {\n\t    attrsChanged = true;\n\t    attrsArr.length = j;\n\t  }\n\n\t  /*\n\t   * Actually perform the attribute update.\n\t   */\n\t  if (attrsChanged) {\n\t    for (i = ATTRIBUTES_OFFSET; i < arguments.length; i += 2) {\n\t      newAttrs[arguments[i]] = arguments[i + 1];\n\t    }\n\n\t    for (var _attr in newAttrs) {\n\t      updateAttribute(node, _attr, newAttrs[_attr]);\n\t      newAttrs[_attr] = undefined;\n\t    }\n\t  }\n\n\t  return node;\n\t};\n\n\t/**\n\t * Declares a virtual Element at the current location in the document. This\n\t * corresponds to an opening tag and a elementClose tag is required. This is\n\t * like elementOpen, but the attributes are defined using the attr function\n\t * rather than being passed as arguments. Must be folllowed by 0 or more calls\n\t * to attr, then a call to elementOpenEnd.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t */\n\tvar elementOpenStart$1 = function elementOpenStart(tag, key, statics) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes('elementOpenStart');\n\t    setInAttributes(true);\n\t  }\n\n\t  argsBuilder[0] = tag;\n\t  argsBuilder[1] = key;\n\t  argsBuilder[2] = statics;\n\t};\n\n\t/***\n\t * Defines a virtual attribute at this point of the DOM. This is only valid\n\t * when called between elementOpenStart and elementOpenEnd.\n\t *\n\t * @param {string} name\n\t * @param {*} value\n\t */\n\tvar attr$1 = function attr(name, value) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertInAttributes('attr');\n\t  }\n\n\t  argsBuilder.push(name, value);\n\t};\n\n\t/**\n\t * Closes an open tag started with elementOpenStart.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementOpenEnd$1 = function elementOpenEnd() {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertInAttributes('elementOpenEnd');\n\t    setInAttributes(false);\n\t  }\n\n\t  var node = elementOpen$1.apply(null, argsBuilder);\n\t  argsBuilder.length = 0;\n\t  return node;\n\t};\n\n\t/**\n\t * Closes an open virtual Element.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementClose$1 = function elementClose(tag) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes('elementClose');\n\t  }\n\n\t  var node = coreElementClose();\n\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertCloseMatchesOpenTag(getData(node).nodeName, tag);\n\t  }\n\n\t  return node;\n\t};\n\n\t/**\n\t * Declares a virtual Element at the current location in the document that has\n\t * no children.\n\t * @param {string} tag The element's tag.\n\t * @param {?string=} key The key used to identify this element. This can be an\n\t *     empty string, but performance may be better if a unique value is used\n\t *     when iterating over an array of items.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementVoid = function elementVoid(tag, key, statics, const_args) {\n\t  var node = elementOpen$1.apply(null, arguments);\n\t  elementClose$1.apply(null, arguments);\n\t  return node;\n\t};\n\n\t/**\n\t * Declares a virtual Element at the current location in the document that is a\n\t * placeholder element. Children of this Element can be manually managed and\n\t * will not be cleared by the library.\n\t *\n\t * A key must be specified to make sure that this node is correctly preserved\n\t * across all conditionals.\n\t *\n\t * @param {string} tag The element's tag.\n\t * @param {string} key The key used to identify this element.\n\t * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n\t *     static attributes for the Element. These will only be set once when the\n\t *     Element is created.\n\t * @param {...*} const_args Attribute name/value pairs of the dynamic attributes\n\t *     for the Element.\n\t * @return {!Element} The corresponding Element.\n\t */\n\tvar elementPlaceholder = function elementPlaceholder(tag, key, statics, const_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertPlaceholderKeySpecified(key);\n\t    console.warn('elementPlaceholder will be removed in Incremental DOM 0.5' + ' use skip() instead');\n\t  }\n\n\t  elementOpen$1.apply(null, arguments);\n\t  skip$1();\n\t  return elementClose$1.apply(null, arguments);\n\t};\n\n\t/**\n\t * Declares a virtual Text at this point in the document.\n\t *\n\t * @param {string|number|boolean} value The value of the Text.\n\t * @param {...(function((string|number|boolean)):string)} const_args\n\t *     Functions to format the value which are called only when the value has\n\t *     changed.\n\t * @return {!Text} The corresponding text node.\n\t */\n\tvar text$1 = function text(value, const_args) {\n\t  if (process.env.NODE_ENV !== 'production') {\n\t    assertNotInAttributes('text');\n\t    assertNotInSkip('text');\n\t  }\n\n\t  var node = coreText();\n\t  var data = getData(node);\n\n\t  if (data.text !== value) {\n\t    data.text = /** @type {string} */value;\n\n\t    var formatted = value;\n\t    for (var i = 1; i < arguments.length; i += 1) {\n\t      /*\n\t       * Call the formatter function directly to prevent leaking arguments.\n\t       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n\t       */\n\t      var fn = arguments[i];\n\t      formatted = fn(formatted);\n\t    }\n\n\t    node.data = formatted;\n\t  }\n\n\t  return node;\n\t};\n\n\n\n\tvar IncrementalDOM = Object.freeze({\n\t\tpatch: patch,\n\t\tpatchInner: patch,\n\t\tpatchOuter: patchOuter,\n\t\tcurrentElement: currentElement,\n\t\tskip: skip$1,\n\t\telementVoid: elementVoid,\n\t\telementOpenStart: elementOpenStart$1,\n\t\telementOpenEnd: elementOpenEnd$1,\n\t\telementOpen: elementOpen$1,\n\t\telementClose: elementClose$1,\n\t\telementPlaceholder: elementPlaceholder,\n\t\ttext: text$1,\n\t\tattr: attr$1,\n\t\tsymbols: symbols$2,\n\t\tattributes: attributes$1,\n\t\tapplyAttr: applyAttr,\n\t\tapplyProp: applyProp$1,\n\t\tnotifications: notifications\n\t});\n\n\tvar div = document.createElement('div');\n\tvar customElementsV0 = !!document.registerElement;\n\tvar customElementsV1 = !!window.customElements;\n\tvar shadowDomV0 = !!div.createShadowRoot;\n\tvar shadowDomV1 = !!div.attachShadow;\n\n\t// Could import these, but we have to import all of IncrementalDOM anyways so\n\t// that we can export our configured IncrementalDOM.\n\tvar applyProp = applyProp$1;\n\tvar attr = attr$1;\n\tvar attributes = attributes$1;\n\tvar elementClose = elementClose$1;\n\tvar elementOpen = elementOpen$1;\n\tvar elementOpenEnd = elementOpenEnd$1;\n\tvar elementOpenStart = elementOpenStart$1;\n\tvar skip = skip$1;\n\tvar symbols$1 = symbols$2;\n\tvar text = text$1;\n\n\n\tvar applyDefault = attributes[symbols$1.default];\n\n\t// Attributes that are not handled by Incremental DOM.\n\tattributes.key = attributes.skip = attributes.statics = function () {};\n\n\t// Attributes that *must* be set via a property on all elements.\n\tattributes.checked = attributes.className = attributes.disabled = attributes.value = applyProp;\n\n\t// Default attribute applicator.\n\tattributes[symbols$1.default] = function (elem, name, value) {\n\t  // Boolean false values should not set attributes at all.\n\t  if (value === false) {\n\t    return;\n\t  }\n\n\t  // Custom element properties should be set as properties.\n\t  var props = elem.constructor.props;\n\t  if (props && name in props) {\n\t    return applyProp(elem, name, value);\n\t  }\n\n\t  // Handle built-in and custom events.\n\t  if (name.indexOf('on') === 0) {\n\t    return name in elem ? applyProp(elem, name, value) : applyEvent(elem, name.substring(2), name, value);\n\t  }\n\n\t  // Fallback to default IncrementalDOM behaviour.\n\t  applyDefault(elem, name, value);\n\t};\n\n\t// Adds or removes an event listener for an element.\n\tfunction applyEvent(elem, ename, name, value) {\n\t  var events = elem.__events;\n\n\t  if (!events) {\n\t    events = elem.__events = {};\n\t  }\n\n\t  var eFunc = events[ename];\n\n\t  // Remove old listener so they don't double up.\n\t  if (eFunc) {\n\t    elem.removeEventListener(ename, eFunc);\n\t  }\n\n\t  // Bind new listener.\n\t  if (value) {\n\t    elem.addEventListener(ename, events[ename] = value);\n\t  }\n\t}\n\n\tfunction element(tname, attrs, chren) {\n\t  // Allow a component constructor to be passed in.\n\t  if (typeof tname === 'function') {\n\t    tname = tname[name];\n\t  }\n\n\t  var shouldBeContentTag = tname === 'slot' && !shadowDomV1 && shadowDomV0;\n\n\t  // Abstract Shadow DOM V0 <content> behind Shadow DOM V1 <slot>.\n\t  if (shouldBeContentTag) {\n\t    tname = 'content';\n\t  }\n\n\t  if (attrs && (typeof attrs === 'undefined' ? 'undefined' : babelHelpers.typeof(attrs)) === 'object') {\n\t    // Abstract Shadow DOM V0 <content> behind Shadow DOM V1 <slot>.\n\t    if (shouldBeContentTag && attrs.name) {\n\t      attrs.select = '[slot=\"' + attrs.name + '\"]';\n\t      delete attrs.slot;\n\t    }\n\n\t    elementOpenStart(tname, attrs.key, attrs.statics);\n\t    for (var a in attrs) {\n\t      attr(a, attrs[a]);\n\t    }\n\t    elementOpenEnd();\n\t  } else {\n\t    elementOpen(tname);\n\t    chren = attrs;\n\t    attrs = {};\n\t  }\n\n\t  if (attrs.skip) {\n\t    skip();\n\t  } else {\n\t    var chrenType = typeof chren === 'undefined' ? 'undefined' : babelHelpers.typeof(chren);\n\t    if (chrenType === 'function') {\n\t      chren();\n\t    } else if (chrenType === 'string' || chrenType === 'number') {\n\t      text(chren);\n\t    }\n\t  }\n\n\t  return elementClose(tname);\n\t}\n\n\n\n\tvar vdom = Object.freeze({\n\t  element: element,\n\t  text: text,\n\t  IncrementalDOM: IncrementalDOM\n\t});\n\n\tfunction data (element) {\n\t  var namespace = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];\n\n\t  var data = element.__SKATE_DATA || (element.__SKATE_DATA = {});\n\t  return namespace && (data[namespace] || (data[namespace] = {})) || data;\n\t}\n\n\tfunction getOwnPropertyDescriptors (obj) {\n\t  return Object.getOwnPropertyNames(obj || {}).reduce(function (prev, curr) {\n\t    prev[curr] = Object.getOwnPropertyDescriptor(obj, curr);\n\t    return prev;\n\t  }, {});\n\t}\n\n\tvar Component = function (_HTMLElement) {\n\t  babelHelpers.inherits(Component, _HTMLElement);\n\n\t  function Component() {\n\t    babelHelpers.classCallCheck(this, Component);\n\n\t    var _this = babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(Component).call(this));\n\n\t    _this.createdCallback();\n\t    return _this;\n\t  }\n\n\t  babelHelpers.createClass(Component, [{\n\t    key: 'connectedCallback',\n\t    value: function connectedCallback() {\n\t      var cb = this.constructor.attached;\n\t      cb && cb(this);\n\t    }\n\t  }, {\n\t    key: 'disconnectedCallback',\n\t    value: function disconnectedCallback() {\n\t      var cb = this.constructor.detached;\n\t      cb && cb(this);\n\t    }\n\t  }, {\n\t    key: 'attributeChangedCallback',\n\t    value: function attributeChangedCallback(name, oldValue, newValue) {\n\t      var _constructor = this.constructor;\n\t      var attributeChanged = _constructor.attributeChanged;\n\t      var observedAttributes = _constructor.observedAttributes;\n\n\t      var propertyName = data(this, 'attributeLinks')[name];\n\n\t      // In V0 we have to ensure the attribute is being observed.\n\t      if (customElementsV0 && observedAttributes.indexOf(name) === -1) {\n\t        return;\n\t      }\n\n\t      if (propertyName) {\n\t        var propData = data(this, 'api/property/' + propertyName);\n\n\t        // This ensures a property set doesn't cause the attribute changed\n\t        // handler to run again once we set this flag. This only ever has a\n\t        // chance to run when you set an attribute, it then sets a property and\n\t        // then that causes the attribute to be set again.\n\t        if (propData.syncingAttribute) {\n\t          propData.syncingAttribute = false;\n\t          return;\n\t        }\n\n\t        // Sync up the property.\n\t        var propOpts = this.constructor.props[propertyName];\n\t        propData.settingAttribute = true;\n\t        this[propertyName] = newValue !== null && propOpts.deserialize ? propOpts.deserialize(newValue) : newValue;\n\t      }\n\n\t      if (attributeChanged) {\n\t        attributeChanged(this, { name: name, newValue: newValue, oldValue: oldValue });\n\t      }\n\t    }\n\t  }, {\n\t    key: 'createdCallback',\n\t    value: function createdCallback() {\n\t      var _this2 = this;\n\n\t      var elemData = data(this);\n\t      var readyCallbacks = elemData.readyCallbacks;\n\t      var Ctor = this.constructor;\n\t      var definedAttribute = Ctor.definedAttribute;\n\t      var events$$ = Ctor.events;\n\t      var created$$ = Ctor.created;\n\t      var observedAttributes = Ctor.observedAttributes;\n\t      var props$$ = Ctor.props;\n\t      var ready = Ctor.ready;\n\t      var renderedAttribute = Ctor.renderedAttribute;\n\n\t      var renderer$$ = Ctor[renderer];\n\n\t      // TODO: This prevents an element from being initialised multiple times. For\n\t      // some reason this is happening in the event tests. It's possibly creating\n\t      // elements in a way that the causes the custom element v1 polyfill to call\n\t      // the constructor twice.\n\t      if (this[created]) return;\n\t      this[created] = true;\n\n\t      if (props$$) {\n\t        Ctor[props](this);\n\t      }\n\n\t      if (events$$) {\n\t        Ctor[events](this);\n\t      }\n\n\t      if (created$$) {\n\t        created$$(this);\n\t      }\n\n\t      if (renderer$$ && !this.hasAttribute(renderedAttribute)) {\n\t        renderer$$(this);\n\t      }\n\n\t      if (ready) {\n\t        ready(this);\n\t      }\n\n\t      if (!this.hasAttribute(definedAttribute)) {\n\t        this.setAttribute(definedAttribute, '');\n\t      }\n\n\t      if (readyCallbacks) {\n\t        readyCallbacks.forEach(function (cb) {\n\t          return cb(_this2);\n\t        });\n\t        delete elemData.readyCallbacks;\n\t      }\n\n\t      // In v0 we must ensure the attributeChangedCallback is called for attrs\n\t      // that aren't linked to props so that the callback behaves the same no\n\t      // matter if v0 or v1 is being used.\n\t      if (customElementsV0) {\n\t        observedAttributes.forEach(function (name) {\n\t          var propertyName = data(_this2, 'attributeLinks')[name];\n\t          if (!propertyName) {\n\t            _this2.attributeChangedCallback(name, null, _this2.getAttribute(name));\n\t          }\n\t        });\n\t      }\n\t    }\n\t  }, {\n\t    key: 'attachedCallback',\n\t    value: function attachedCallback() {\n\t      this.connectedCallback();\n\t    }\n\t  }, {\n\t    key: 'detachedCallback',\n\t    value: function detachedCallback() {\n\t      this.disconnectedCallback();\n\t    }\n\t  }], [{\n\t    key: 'extend',\n\t    value: function extend() {\n\t      var definition = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\t      var Base = arguments.length <= 1 || arguments[1] === undefined ? this : arguments[1];\n\n\t      // Create class for the user.\n\n\t      var Ctor = function (_Base) {\n\t        babelHelpers.inherits(Ctor, _Base);\n\n\t        function Ctor() {\n\t          babelHelpers.classCallCheck(this, Ctor);\n\t          return babelHelpers.possibleConstructorReturn(this, Object.getPrototypeOf(Ctor).apply(this, arguments));\n\t        }\n\n\t        return Ctor;\n\t      }(Base);\n\n\t      // For inheriting from the object literal.\n\n\n\t      var opts = getOwnPropertyDescriptors(definition);\n\t      var prot = getOwnPropertyDescriptors(definition.prototype);\n\n\t      // Prototype is non configurable (but is writable) s\n\t      delete opts.prototype;\n\n\t      // Pass on static and instance members from the definition.\n\t      Object.defineProperties(Ctor, opts);\n\t      Object.defineProperties(Ctor.prototype, prot);\n\n\t      return Ctor;\n\t    }\n\t  }, {\n\t    key: 'definedAttribute',\n\t    get: function get() {\n\t      return 'defined';\n\t    }\n\t  }, {\n\t    key: 'events',\n\t    get: function get() {\n\t      return {};\n\t    }\n\t  }, {\n\t    key: 'observedAttributes',\n\t    get: function get() {\n\t      return [];\n\t    }\n\t  }, {\n\t    key: 'props',\n\t    get: function get() {\n\t      return {};\n\t    }\n\t  }, {\n\t    key: 'renderedAttribute',\n\t    get: function get() {\n\t      return 'rendered';\n\t    }\n\t  }]);\n\t  return Component;\n\t}(HTMLElement);\n\n\tvar elProto = window.HTMLElement.prototype;\n\tvar nativeMatchesSelector = elProto.matches || elProto.msMatchesSelector || elProto.webkitMatchesSelector || elProto.mozMatchesSelector || elProto.oMatchesSelector;\n\n\t// Only IE9 has this msMatchesSelector bug, but best to detect it.\n\tvar hasNativeMatchesSelectorDetattachedBug = !nativeMatchesSelector.call(document.createElement('div'), 'div');\n\n\tfunction matches$1 (element, selector) {\n\t  if (hasNativeMatchesSelectorDetattachedBug) {\n\t    var clone = element.cloneNode();\n\t    document.createElement('div').appendChild(clone);\n\t    return nativeMatchesSelector.call(clone, selector);\n\t  }\n\t  return nativeMatchesSelector.call(element, selector);\n\t}\n\n\tfunction readonly(obj, prop, val) {\n\t  Object.defineProperty(obj, prop, {\n\t    configurable: true,\n\t    get: function get() {\n\t      return val;\n\t    }\n\t  });\n\t}\n\n\tfunction parseEvent(e) {\n\t  var indexOfSpace = e.indexOf(' ');\n\t  var hasSpace = indexOfSpace > 0;\n\t  var name = hasSpace ? e.substring(0, indexOfSpace) : e;\n\t  var selector = hasSpace ? e.substring(indexOfSpace + 1) : '';\n\t  return {\n\t    name: name,\n\t    selector: selector\n\t  };\n\t}\n\n\tfunction makeDelegateHandler(elem, handler, parsed) {\n\t  return function (e) {\n\t    var current = e.path ? e.path[0] : e.target;\n\t    var selector = parsed.selector;\n\t    while (current && current !== elem.parentNode) {\n\t      if (matches$1(current, selector)) {\n\t        readonly(e, 'currentTarget', current);\n\t        readonly(e, 'delegateTarget', elem);\n\t        return handler(elem, e);\n\t      }\n\t      current = current.parentNode;\n\t    }\n\t  };\n\t}\n\n\tfunction makeNormalHandler(elem, handler) {\n\t  return function (e) {\n\t    readonly(e, 'delegateTarget', elem);\n\t    handler(elem, e);\n\t  };\n\t}\n\n\tfunction bindEvent(elem, event, handler) {\n\t  var parsed = parseEvent(event);\n\t  var name = parsed.name;\n\t  var selector = parsed.selector;\n\n\t  var capture = selector && (name === 'blur' || name === 'focus');\n\t  handler = selector ? makeDelegateHandler(elem, handler, parsed) : makeNormalHandler(elem, handler);\n\t  elem.addEventListener(name, handler, capture);\n\t}\n\n\tfunction events$1(opts) {\n\t  var events = opts.events || {};\n\t  return function (elem) {\n\t    for (var name in events) {\n\t      bindEvent(elem, name, events[name]);\n\t    }\n\t  };\n\t}\n\n\tvar patch$1 = patch;\n\n\n\tfunction createRenderer (Ctor) {\n\t  var render = Ctor.render;\n\n\n\t  return function (elem) {\n\t    if (!render) {\n\t      return;\n\t    }\n\n\t    if (!elem[shadowRoot]) {\n\t      var sr = void 0;\n\n\t      if (shadowDomV1) {\n\t        sr = elem.attachShadow({ mode: 'open' });\n\t      } else if (shadowDomV0) {\n\t        sr = elem.createShadowRoot();\n\t      } else {\n\t        sr = elem;\n\t      }\n\n\t      elem[shadowRoot] = sr;\n\t    }\n\n\t    patch$1(elem[shadowRoot], render, elem);\n\t  };\n\t}\n\n\tfunction dashCase (str) {\n\t  return str.split(/([A-Z])/).reduce(function (one, two, idx) {\n\t    var dash = !one || idx % 2 === 0 ? '' : '-';\n\t    return '' + one + dash + two.toLowerCase();\n\t  });\n\t}\n\n\tvar raf = window.requestAnimationFrame || setTimeout;\n\tfunction debounce (fn) {\n\t  var called = false;\n\n\t  return function () {\n\t    var _this = this;\n\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\n\t    if (!called) {\n\t      called = true;\n\t      raf(function () {\n\t        called = false;\n\t        fn.apply(_this, args);\n\t      });\n\t    }\n\t  };\n\t}\n\n\tvar CustomEvent = function (CustomEvent) {\n\t  if (CustomEvent) {\n\t    try {\n\t      new CustomEvent();\n\t    } catch (e) {\n\t      return undefined;\n\t    }\n\t  }\n\t  return CustomEvent;\n\t}(window.CustomEvent);\n\n\tfunction createCustomEvent(name) {\n\t  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n\t  if (CustomEvent) {\n\t    return new CustomEvent(name, opts);\n\t  }\n\t  var e = document.createEvent('CustomEvent');\n\t  e.initCustomEvent(name, opts.bubbles, opts.cancelable, opts.detail);\n\t  return e;\n\t}\n\n\tfunction emit (elem, name) {\n\t  var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n\t  /* jshint expr: true */\n\t  opts.bubbles === undefined && (opts.bubbles = true);\n\t  opts.cancelable === undefined && (opts.cancelable = true);\n\t  return elem.disabled ? true : elem.dispatchEvent(createCustomEvent(name, opts));\n\t}\n\n\tfunction getDefaultValue(elem, name, opts) {\n\t  return typeof opts.default === 'function' ? opts.default(elem, { name: name }) : opts.default;\n\t}\n\n\tfunction getInitialValue(elem, name, opts) {\n\t  return typeof opts.initial === 'function' ? opts.initial(elem, { name: name }) : opts.initial;\n\t}\n\n\tfunction createNativePropertyDefinition(name, opts) {\n\t  var prop = {\n\t    configurable: true,\n\t    enumerable: true\n\t  };\n\n\t  prop.created = function (elem) {\n\t    var propData = data(elem, 'api/property/' + name);\n\t    var attributeName = opts.attribute;\n\t    var initialValue = elem[name];\n\t    var shouldSyncAttribute = false;\n\n\t    // Store property to attribute link information.\n\t    data(elem, 'attributeLinks')[attributeName] = name;\n\t    data(elem, 'propertyLinks')[name] = attributeName;\n\n\t    // Set up initial value if it wasn't specified.\n\t    if (empty(initialValue)) {\n\t      if (attributeName && elem.hasAttribute(attributeName)) {\n\t        initialValue = opts.deserialize(elem.getAttribute(attributeName));\n\t      } else if ('initial' in opts) {\n\t        initialValue = getInitialValue(elem, name, opts);\n\t        shouldSyncAttribute = true;\n\t      } else if ('default' in opts) {\n\t        initialValue = getDefaultValue(elem, name, opts);\n\t      }\n\t    }\n\n\t    if (shouldSyncAttribute) {\n\t      prop.set.call(elem, initialValue);\n\t    } else {\n\t      propData.internalValue = opts.coerce ? opts.coerce(initialValue) : initialValue;\n\t    }\n\t  };\n\n\t  prop.get = function () {\n\t    var propData = data(this, 'api/property/' + name);\n\t    var internalValue = propData.internalValue;\n\n\t    if (typeof opts.get === 'function') {\n\t      return opts.get(this, { name: name, internalValue: internalValue });\n\t    }\n\t    return internalValue;\n\t  };\n\n\t  prop.render = function () {\n\t    var shouldUpdate = opts.render;\n\t    if (typeof shouldUpdate === 'undefined') {\n\t      return function (elem, data) {\n\t        return data.newValue !== data.oldValue;\n\t      };\n\t    }\n\t    if (typeof shouldUpdate === 'function') {\n\t      return shouldUpdate;\n\t    }\n\t    return function () {\n\t      return !!shouldUpdate;\n\t    };\n\t  }();\n\n\t  prop.set = function (newValue) {\n\t    var propData = data(this, 'api/property/' + name);\n\t    var oldValue = propData.oldValue;\n\n\t    var shouldRemoveAttribute = false;\n\n\t    if (empty(oldValue)) {\n\t      oldValue = null;\n\t    }\n\n\t    if (empty(newValue)) {\n\t      newValue = getDefaultValue(this, name, opts);\n\t      shouldRemoveAttribute = true;\n\t    }\n\n\t    if (typeof opts.coerce === 'function') {\n\t      newValue = opts.coerce(newValue);\n\t    }\n\n\t    var propertyHasChanged = newValue !== oldValue;\n\t    if (propertyHasChanged && opts.event) {\n\t      var canceled = !emit(this, String(opts.event), {\n\t        bubbles: false,\n\t        detail: { name: name, oldValue: oldValue, newValue: newValue }\n\t      });\n\n\t      if (canceled) {\n\t        return;\n\t      }\n\t    }\n\n\t    propData.internalValue = newValue;\n\n\t    var changeData = { name: name, newValue: newValue, oldValue: oldValue };\n\n\t    if (typeof opts.set === 'function') {\n\t      opts.set(this, changeData);\n\t    }\n\n\t    // Re-render on property updates if the should-update check passes.\n\t    if (prop.render(this, changeData)) {\n\t      var deb = this[rendererDebounced] || (this[rendererDebounced] = debounce(this.constructor[renderer]));\n\t      deb(this);\n\t    }\n\n\t    propData.oldValue = newValue;\n\n\t    // Link up the attribute.\n\t    var attributeName = data(this, 'propertyLinks')[name];\n\t    if (attributeName && !propData.settingAttribute) {\n\t      var serializedValue = opts.serialize(newValue);\n\t      propData.syncingAttribute = true;\n\t      if (shouldRemoveAttribute || empty(serializedValue)) {\n\t        this.removeAttribute(attributeName);\n\t      } else {\n\t        this.setAttribute(attributeName, serializedValue);\n\t      }\n\t    }\n\n\t    // Allow the attribute to be linked again.\n\t    propData.settingAttribute = false;\n\t  };\n\n\t  return prop;\n\t}\n\n\tfunction initProps (opts) {\n\t  opts = opts || {};\n\n\t  if (typeof opts === 'function') {\n\t    opts = { coerce: opts };\n\t  }\n\n\t  return function (name) {\n\t    return createNativePropertyDefinition(name, assign({\n\t      default: null,\n\t      deserialize: function deserialize(value) {\n\t        return value;\n\t      },\n\t      serialize: function serialize(value) {\n\t        return value;\n\t      }\n\t    }, opts));\n\t  };\n\t}\n\n\t// Ensures that definitions passed as part of the constructor are functions\n\t// that return property definitions used on the element.\n\tfunction ensurePropertyFunctions(Ctor) {\n\t  var props = Ctor.props;\n\t  var names = Object.keys(props || {});\n\t  return names.reduce(function (descriptors, descriptorName) {\n\t    descriptors[descriptorName] = props[descriptorName];\n\t    if (typeof descriptors[descriptorName] !== 'function') {\n\t      descriptors[descriptorName] = initProps(descriptors[descriptorName]);\n\t    }\n\t    return descriptors;\n\t  }, {});\n\t}\n\n\t// Ensures the property definitions are transformed to objects that can be used\n\t// to create properties on the element.\n\tfunction ensurePropertyDefinitions(Ctor) {\n\t  var props = ensurePropertyFunctions(Ctor);\n\t  return Object.keys(props).reduce(function (descriptors, descriptorName) {\n\t    descriptors[descriptorName] = props[descriptorName](descriptorName);\n\t    return descriptors;\n\t  }, {});\n\t}\n\n\t// Makes a function / constructor for the custom element that automates the\n\t// boilerplate of ensuring the parent constructor is called first and ensures\n\t// that the element is returned at the end.\n\tfunction createConstructor(name$$, Ctor) {\n\t  if ((typeof Ctor === 'undefined' ? 'undefined' : babelHelpers.typeof(Ctor)) === 'object') {\n\t    Ctor = Component.extend(Ctor);\n\t  }\n\n\t  // Internal data.\n\t  Ctor[name] = name$$;\n\n\t  return Ctor;\n\t}\n\n\t// Ensures linked properties that have linked attributes are pre-formatted to\n\t// the attribute name in which they are linked.\n\tfunction formatLinkedAttributes(Ctor) {\n\t  var observedAttributes = Ctor.observedAttributes;\n\t  var props = Ctor.props;\n\n\n\t  if (!props) {\n\t    return;\n\t  }\n\n\t  Object.keys(props).forEach(function (name) {\n\t    var prop = props[name];\n\t    var attr = prop.attribute;\n\t    if (attr) {\n\t      // Ensure the property is updated.\n\t      var linkedAttr = prop.attribute = attr === true ? dashCase(name) : attr;\n\n\t      // Automatically observe the attribute since they're linked from the\n\t      // attributeChangedCallback.\n\t      if (observedAttributes.indexOf(linkedAttr) === -1) {\n\t        observedAttributes.push(linkedAttr);\n\t      }\n\t    }\n\t  });\n\n\t  // Merge observed attributes.\n\t  Object.defineProperty(Ctor, 'observedAttributes', {\n\t    get: function get() {\n\t      return observedAttributes;\n\t    }\n\t  });\n\t}\n\n\tfunction createInitProps(Ctor) {\n\t  var props = ensurePropertyDefinitions(Ctor);\n\n\t  return function (elem) {\n\t    if (!props) {\n\t      return;\n\t    }\n\n\t    Object.keys(props).forEach(function (name) {\n\t      var prop = props[name];\n\t      prop.created(elem);\n\n\t      // https://bugs.webkit.org/show_bug.cgi?id=49739\n\t      //\n\t      // When Webkit fixes that bug so that native property accessors can be\n\t      // retrieved, we can move defining the property to the prototype and away\n\t      // from having to do if for every instance as all other browsers support\n\t      // this.\n\t      Object.defineProperty(elem, name, prop);\n\t    });\n\t  };\n\t}\n\n\tfunction define (name, Ctor) {\n\t  Ctor = createConstructor(name, Ctor);\n\t  formatLinkedAttributes(Ctor);\n\n\t  Ctor[events] = events$1(Ctor);\n\t  Ctor[props] = createInitProps(Ctor);\n\t  Ctor[renderer] = createRenderer(Ctor);\n\n\t  if (customElementsV0) {\n\t    return document.registerElement(name, Ctor);\n\t  } else if (customElementsV1) {\n\t    window.customElements.define(name, Ctor, { extends: Ctor.extends });\n\t    return Ctor;\n\t  } else {\n\t    throw new Error('Skate requires native custom element support or a polyfill.');\n\t  }\n\t}\n\n\tfunction get(elem) {\n\t  var props = elem.constructor.props;\n\t  var state = {};\n\t  for (var key in props) {\n\t    var val = elem[key];\n\t    if (typeof val !== 'undefined') {\n\t      state[key] = val;\n\t    }\n\t  }\n\t  return state;\n\t}\n\n\tfunction set(elem, newState) {\n\t  assign(elem, newState);\n\t  if (elem.constructor.render) {\n\t    elem.constructor[renderer](elem);\n\t  }\n\t}\n\n\tfunction state (elem, newState) {\n\t  return typeof newState === 'undefined' ? get(elem) : set(elem, newState);\n\t}\n\n\tfunction getValue(elem) {\n\t  var type = elem.type;\n\t  if (type === 'checkbox' || type === 'radio') {\n\t    return elem.checked ? elem.value || true : false;\n\t  }\n\t  return elem.value;\n\t}\n\n\tfunction link (elem, target) {\n\t  return function (e) {\n\t    var value = getValue(e.target);\n\t    var localTarget = target || e.target.name || 'value';\n\n\t    if (localTarget.indexOf('.') > -1) {\n\t      var parts = localTarget.split('.');\n\t      var firstPart = parts[0];\n\t      var propName = parts.pop();\n\t      var obj = parts.reduce(function (prev, curr) {\n\t        return prev && prev[curr];\n\t      }, elem);\n\n\t      obj[propName || e.target.name] = value;\n\t      state(elem, babelHelpers.defineProperty({}, firstPart, elem[firstPart]));\n\t    } else {\n\t      state(elem, babelHelpers.defineProperty({}, localTarget, value));\n\t    }\n\t  };\n\t}\n\n\tfunction ready (elem, done) {\n\t  var info = data(elem);\n\t  if (elem.hasAttribute(elem.constructor.definedAttribute)) {\n\t    done(elem);\n\t  } else if (info.readyCallbacks) {\n\t    info.readyCallbacks.push(done);\n\t  } else {\n\t    info.readyCallbacks = [done];\n\t  }\n\t}\n\n\texports.Component = Component;\n\texports.define = define;\n\texports.emit = emit;\n\texports.link = link;\n\texports.prop = prop;\n\texports.ready = ready;\n\texports.state = state;\n\texports.symbols = symbols;\n\texports.vdom = vdom;\n\n}));\n//# sourceMappingURL=index.js.map\n\n\n/** WEBPACK FOOTER **\n ** ./~/skatejs/dist/index.js\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\n(function () {\n  try {\n    cachedSetTimeout = setTimeout;\n  } catch (e) {\n    cachedSetTimeout = function () {\n      throw new Error('setTimeout is not defined');\n    }\n  }\n  try {\n    cachedClearTimeout = clearTimeout;\n  } catch (e) {\n    cachedClearTimeout = function () {\n      throw new Error('clearTimeout is not defined');\n    }\n  }\n} ())\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = cachedSetTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    cachedClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        cachedSetTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/process/browser.js\n **/","import { define, prop } from 'skatejs';\nimport css from './index.css';\nimport elements from '../_/elements';\n\nconst { a, div, h1, li, style, ul } = elements;\n\nfunction item (text, href = '#') {\n  li({ class: 'header-list-item' }, () => a({ class: 'header-link', href }, text));\n}\n\nexport default define('sk-header', {\n  props: {\n    title: prop.string(),\n  },\n  render(elem) {\n    style(css.toString());\n    div({ class: 'header' }, () => {\n      h1({ class: 'header-title' }, elem.title);\n      ul({ class: 'header-list-item' }, () => {\n        item('Docs');\n        item('Github');\n        item('Community');\n      });\n    });\n  },\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/header/index.js\n **/","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".header{background-color:#333;color:#eee;height:60px}.header-list{list-style:none}.header-list,.header-list-item{display:inline-block;margin:0;padding:0}.header-title{display:inline-block;font-size:24px;line-height:24px;margin:-2px 0 0;padding:18px}.header-link{color:#eee;font-size:18px;margin:0;padding:20px;text-decoration:none}.header-link:hover{background-color:#444}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/header/index.css\n ** module id = 5\n ** module chunks = 0 1\n **/","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/css-loader/lib/css-base.js\n **/","import { vdom } from 'skatejs';\n\nconst specials = ['a', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ol', 'p', 'ul'];\n\nexport default Object.getOwnPropertyNames(window)\n  .filter(name => name.indexOf('HTML') === 0 && name.indexOf('Element') > 0)\n  .map(name => name.replace(/^HTML/, '').replace(/Element$/, ''))\n  .map(name => name.toLowerCase())\n  .concat(specials)\n  .filter(name => !!name)\n  .reduce((prev, curr) => (prev[curr] = vdom.element.bind(null, curr)) && prev, {});\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_/elements.js\n **/","export default function (title) {\n  document.title = title;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/_/title.js\n **/","exports = module.exports = require(\"./../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"html{font-family:Helvetica;font-size:14px}body{margin:0}a{color:#333}\", \"\"]);\n\n// exports\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/index.css\n ** module id = 9\n ** module chunks = 0 1\n **/"],"sourceRoot":""}